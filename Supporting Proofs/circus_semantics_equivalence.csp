--This is to check if the circus version of the AnglePIDANN semanntics, are equivalent to the CSPM binarized version. 
--Write this in Circus, has multiple layers. 

--Binary ANN constants (Binarised Segway with core_real) -- 
Value = {0,1}
insize = 6
outsize = 3
layerstructure = <3, 1, 3> 
layerNo = #layerstructure 
maxSize = 6
weights = < 
		< 
			<1,0,0,0,0,0>, 
			<0,1,0,0,0,0>, 
			<0,0,1,0,0,0> 
		>, 
		< 
			<0,1,0>
		>, 
		< 
			<0>,
			<0>,
			<1>
		> 
	>
biases = < <0,0,1>, <0>, <0,1,0> >


-- CHANNELS --
channel layerRes:{0..layerNo}.{1..maxSize}.Value
channel nodeOut:{1..layerNo}.{1..maxSize}.{1..maxSize}.Value
channel end


-- PROCESSES --

NodeIn(layer, node, index) = layerRes.(layer - 1).index?x -> nodeOut.layer.node.index.(x * extract_weights(layer, node, index)) -> SKIP

Node(layer, node, inputSize) = (||| i:{1..inputSize} @ NodeIn(layer, node, i)) [| {| nodeOut.layer.node |} |] Collator(layer, node, inputSize) \ {| nodeOut |} 

HiddenLayer(layer, size, inputSize) = [| {| layerRes.(layer-1) |} |] i: {1..size} @ Node(layer, i, inputSize) 

HiddenLayers = || i : {1..(layerNo-1)} @ [ {| layerRes.(i-1), layerRes.i |} ] HiddenLayer(i, layerSize(i), layerSize(i-1))  

Collator(layer, node, index) = let
	C(layer, node, 0, sum) = layerRes.layer.node.sign(sum + extract_biases(layer, node)) -> SKIP
	C(layer, node, index, sum) = nodeOut.layer.node.index?n -> 
										C(layer, node, (index-1), (sum+n))
	within 
		C(layer, node, index, 0)

OutputLayer = [| {| layerRes.(layerNo-1) |} |] i: {1..outsize} @ Node(layerNo, i, layerSize(layerNo-1)) \ {| nodeOut |}

ANN = ((HiddenLayers [| {| layerRes.(layerNo-1) |} |] OutputLayer) \ ANNHiddenEvts) /\ end -> SKIP

--This is exactly the same, as y1 always 0, y2 always 1, y3 is x2. 

--First, let's define some channels, rename scheme. 

--Channels, no indexed channels, so we can write it in circus
channel in1, in2, in3, in4, in5, in6 : Value
channel out1, out2, out3 : Value
BNN_TEST = ANN[[layerRes.0.1 <- in1, layerRes.0.2 <- in2, layerRes.0.3 <- in3, layerRes.0.4 <- in4, layerRes.0.5 <- in5, 
		  layerRes.0.6 <- in6, layerRes.3.1 <- out1, layerRes.3.2 <- out2, layerRes.3.3 <- out3]]

--Some possible traces of BNN. 
BNN_Trace1 = in1.0 -> in2.0 -> in3.0 -> in4.0 -> in5.0 -> in6.0 -> out1.0 -> out2.1 -> out3.0 -> SKIP

assert BNN_TEST [T= BNN_Trace1
	
assert BNN_TEST;RUN({end}) :[deadlock-free]	
assert BNN_TEST :[deterministic] 
assert BNN_TEST :[divergence-free]
	
--Sign is the sign binary activation function.
sign(x) = if (x > 0) then 1 else 0

ANNHiddenEvts = diff(Events, {| layerRes.0, layerRes.3, end |})

-- Extraction Functions, because random access not implemented in CSPM, implemented as lists not a type of function --

extract_sequence(1, sequence) = head(sequence)
extract_sequence(index, sequence) = extract_sequence((index-1), tail(sequence))

layerSize(0) = insize
layerSize(layer) = extract_sequence(layer, layerstructure)

--Extract single weights value
extract_weights(layer, node, index) = extract_sequence(index, 
					(extract_sequence(node, 
						(extract_sequence(layer, weights)))))
--Extract weights of node
extract_weights_node(layer, node) = extract_sequence(node, 
							(extract_sequence(layer, weights)))
extract_biases(layer, node) = (extract_sequence(node, 
											(extract_sequence(layer, biases))))
