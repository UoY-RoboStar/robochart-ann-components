
--
-- RoboChart generator version 3.0.0.202306261132
-- Automatically generated on 22-08-2023 01:53:01
--
-- Iterated compression status: true
-- Assertions compression status: false
--

module Segway
	exports
	
	transparent diamond
	transparent sbisim
	transparent dbisim
	transparent chase
	
	-- declaring channels
	-- declaring robotic platform events
	channel leftMotorVelocity: InOut.core_real
	channel rightMotorVelocity: InOut.core_real
	channel angle: InOut.core_real
	channel gyroX: InOut.core_real
	channel gyroY: InOut.core_real
	channel gyroZ: InOut.core_real
	
	channel setLeftMotorSpeedCall: core_real
	channel setRightMotorSpeedCall: core_real
	channel enableInterruptsCall
	channel disableInterruptsCall
	
	-- declaring module termination channel
	channel terminate
	
	-- declaring robotic platform variables
	
	-- channel set with all visible events
	sem__events = {|
		leftMotorVelocity,
		rightMotorVelocity,
		angle,
		gyroX,
		gyroY,
		gyroZ
	,	setLeftMotorSpeedCall,
		setRightMotorSpeedCall,
		enableInterruptsCall,
		disableInterruptsCall
	|}
	
	-- declaring controller
		module SegwayController
			shared_variable_events = {|
			|}
			
		exports
			transparent diamond
			transparent sbisim
			transparent dbisim
			transparent chase
	
			-- declaring controller events
			channel leftMotorVelocity: InOut.core_real
			channel rightMotorVelocity: InOut.core_real
			channel angle: InOut.core_real
			channel gyroX: InOut.core_real
			channel gyroY: InOut.core_real
			channel gyroZ: InOut.core_real
			
			
			
			-- declaring call and ret events for undefined operations
			channel setLeftMotorSpeedCall: core_real
			channel enableInterruptsCall
			channel setRightMotorSpeedCall: core_real
			channel disableInterruptsCall
			
			-- declaring controller termination channel
			channel terminate
			
			-- channel set with all visible events
			sem__events = {|
				terminate
			,	leftMotorVelocity,
				rightMotorVelocity,
				angle,
				gyroX,
				gyroY,
				gyroZ
			,	setLeftMotorSpeedCall,
				enableInterruptsCall,
				setRightMotorSpeedCall,
				disableInterruptsCall
			|}
			
			-- set of visible memory events
			visibleMemoryEvents = {||}
	
			-- defined operations
			-- compileOperationDef
			module OP_AnglePID
			exports
				transparent diamond
				transparent sbisim
				transparent dbisim
				transparent chase
				
				-- Transition identifiers
				-- declaring identifiers of transitions
				datatype NIDS = 
				              NID_i0|
				              NID_UpdateOutput|
				              NID_f0
				
				channel internal__ : NIDS
				
				-- Flow channels		
				channel interrupt
				channel exited
				channel exit
				channel terminate
				
				-- Variable channels
				channel get_angleOutput, set_angleOutput, setL_angleOutput, setR_angleOutput: core_real
				
				-- Shared variable channels
				channel set_EXT_angleOutput: core_real
				
				-- Local variable channels for defined operations that are required by the state machine
				
				-- Declaring state machine events
				
				-- Declaring call and ret events for undefined operations
				
				enterSS = {|
				i0::enter,
				UpdateOutput::enter,
				f0::enter
				|}
				
				enteredSS = 	{|
				UpdateOutput::entered,
				f0::entered
				|}
				
				internal_events = union(enteredSS,union(enterSS,{|interrupt,exited|}))
				
				shared_variable_events = {|
					set_EXT_angleOutput
				|}
				
				-- channel set with all visible events
				sem__events = {|
					terminate
				,	set_EXT_angleOutput, set_angleOutput
					, share__
					|}
				
				channel clockReset, clockResetL, clockResetR 
				
				localClockResets = {||}
				
				
				channel get_CLID_UpdateOutput : core_clock_type 
				channel get_CLID_f0 : core_clock_type 
				--channel increment__
				
				CLID_UpdateOutput_clock_type(id__,
						          const_AnglePID_P,
						          const_AnglePID_D) = 
					let
						max = (clock_type_max(Union({
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_f0_clock_type(id__,
						          const_AnglePID_P,
						          const_AnglePID_D) = 
					let
						max = (clock_type_max(Union({
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				
				
					-- Nodes --
					-- declaring all nodes
					
					----------------------------------------------------------------------
					-- Initial: i0
					module i0
					exports
					
						channel enter, interrupt
						
						Timed(OneStep) {
							D__(id__,
										param_newError,
										param_diff,
									    const_AnglePID_P,
									    const_AnglePID_D) = 
								dbisim(let
									Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
									
									Termination = terminate -> SKIP
									
									Active 		= share__choice(interrupt -> SKIP) ; Inactive
								within
									Inactive [| {terminate} |> SKIP)
							
							VS_O__(id__,
										param_newError,
										param_diff,
									    const_AnglePID_P,
									    const_AnglePID_D) = D__(id__,
										param_newError,
										param_diff,
									    const_AnglePID_P,
									    const_AnglePID_D)
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: UpdateOutput
					module UpdateOutput
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
										param_newError,
										param_diff,
									    const_AnglePID_P,
									    const_AnglePID_D) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(true & (share__choice(set_angleOutput!Plus(Mult(param_newError, const_AnglePID_P, core_real), Mult(param_diff, const_AnglePID_D, core_real), core_real) -> SKIP))) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
										param_newError,
										param_diff,
									    const_AnglePID_P,
									    const_AnglePID_D) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(true & (share__choice(set_angleOutput!Plus(Mult(param_newError, const_AnglePID_P, core_real), Mult(param_diff, const_AnglePID_D, core_real), core_real) -> SKIP))) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_AnglePID_P,
									          const_AnglePID_D) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- Final state: f0
					module f0
					
					exports
					
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							D__(id__,
										param_newError,
										param_diff,
									    const_AnglePID_P,
									    const_AnglePID_D) = 
								dbisim(let
									Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Entering
									
									Entering 	= entered -> SKIP ; Active
									Active		= share__choice(terminate -> SKIP [] interrupt -> SKIP) ; Interrupted
									Interrupted	= share__choice(exit -> exited -> Inactive)
								within
									Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
										param_newError,
										param_diff,
									    const_AnglePID_P,
									    const_AnglePID_D) = D__(id__,
										param_newError,
										param_diff,
									    const_AnglePID_P,
									    const_AnglePID_D)
						}
					
					endmodule
					----------------------------------------------------------------------
					
					-- END of Nodes --
					
					Timed(OneStep) {
					-- Operation calls --
					-- Only the undefined operations are declared here.
					-- If the state machine is in isolation, all required operations will be undefined.
					-- If it is in the context of a controller, the required operations not provided by the
					-- controller will be declared here, and the defined operations will be defined in the
					-- context of the Controller module, and therefore within scope of the state machine module.
					
					-- END of Operation calls --
				
					-- STM processes
					STM(id__,
								param_newError,
								param_diff,
							    const_AnglePID_P,
							    const_AnglePID_D) = -- RULE: [[stm:OperationDef]]_STM^nops : CSPProcess
					Stateful(id__,
								param_newError,
								param_diff,
							    const_AnglePID_P,
							    const_AnglePID_D) \ {terminate}
					
					STM_VS_O(id__,
								param_newError,
								param_diff,
							    const_AnglePID_P,
							    const_AnglePID_D) = -- RULE: [[stm:OperationDef]]_STM^nops : CSPProcess
					Stateful(id__,
								param_newError,
								param_diff,
							    const_AnglePID_P,
							    const_AnglePID_D) \ {terminate}
					
					-- Transitions
					Transitions(id__,
								param_newError,
								param_diff,
							    const_AnglePID_P,
							    const_AnglePID_D) = ((let
						Trans = TimeOut_1(
							 (share__ -> SKIP
							 [] dbisim((true)&(internal__!NID_i0 -> SKIP ;  ((SKIP ; UpdateOutput::enter -> SKIP))))
							 [] dbisim((true)&(internal__!NID_UpdateOutput -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; f0::enter -> SKIP)))
							 []
							 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
							 []
							 terminate -> SKIP
							 )
						,SKIP);Trans
					within
						Trans [|{terminate}|> SKIP
					)
					)
					
					-- Stateful
					-- RULE: Stateful(stm:StateMachineBody) : CSPProcess
					
					-- Named process definitions
					MachineBody(id__,
								param_newError,
								param_diff,
							    const_AnglePID_P,
							    const_AnglePID_D) = 
						dbisim((
						let
							finalNodesEntered = {|f0::entered|}
						within
							(dbisim((dbisim((let
								-- IMPLEMENTATION NOTE:
								-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
								-- modules for defining the semantics of each node.
								enterSS = {|
								i0::enter,
								UpdateOutput::enter,
								f0::enter
								|}
								hideSet = union(enterSS,{|exit,exited,internal__|})
							within 
								((let
									-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
									-- because CSPM modules are used for the semantics of Node.
									flowevts = union(enterSS,{|exit,exited,interrupt|})
									transSync = {|internal__.NID_i0,internal__.NID_UpdateOutput|}
								within
									((
									 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
									   i0::D__(id__,
									   			param_newError,
									   			param_diff,
									   		    const_AnglePID_P,
									   		    const_AnglePID_D)
									   [| { share__, terminate } |] (
									   UpdateOutput::D__(id__,
									   			param_newError,
									   			param_diff,
									   		    const_AnglePID_P,
									   		    const_AnglePID_D)
									   [| { share__, terminate } |] (
									   f0::D__(id__,
									   			param_newError,
									   			param_diff,
									   		    const_AnglePID_P,
									   		    const_AnglePID_D)
									   )
									   )
									 )
									 [[UpdateOutput::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_UpdateOutput|}]]
									 [[f0::interrupt <- x__ | x__ <- {|interrupt|}]]
									 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
									 )
									  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
									 )
									 [| union(union(union(flowevts,transSync),{terminate}),{|share__
									|}) |]
									 ((i0::enter -> Transitions(id__,
									 			param_newError,
									 			param_diff,
									 		    const_AnglePID_P,
									 		    const_AnglePID_D))
									  [[ share__ <- x__ | x__ <- {| share__ |} ]]
									 )
									)
									)
								)
								 \ hideSet)
							)
							)
							 [| union(stateClockSync,{terminate}) |]
							 StateClocks(id__,
							 		          const_AnglePID_P,
							 		          const_AnglePID_D)
							)\diff(stateClockSync,enteredSS))
							 [| {| interrupt |} |] SKIP)
						)
						)
					
					Behaviour(id__,
								param_newError,
								param_diff,
							    const_AnglePID_P,
							    const_AnglePID_D) = 
						dbisim((let
							stateClockSync = {|get_CLID_UpdateOutput,UpdateOutput::entered|}
						 within
							(MachineBody(id__,
										param_newError,
										param_diff,
									    const_AnglePID_P,
									    const_AnglePID_D) [| union(stateClockSync,{terminate}) |] StateClocks(id__,
									          const_AnglePID_P,
									          const_AnglePID_D)) \ union(stateClockSync,enteredSS)
						)
						)
					
					
					Stateful(id__,
								param_newError,
								param_diff,
							    const_AnglePID_P,
							    const_AnglePID_D) = 
						((let
							getsetLocalChannels = {||}
							clockSync = {||}
						within
							(Behaviour(id__,
										param_newError,
										param_diff,
									    const_AnglePID_P,
									    const_AnglePID_D) 
							 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
							 (varMemory(id__,
							 			param_newError,
							 			param_diff,
							 		    const_AnglePID_P,
							 		    const_AnglePID_D) [| {terminate} |] Clocks(id__,
							 		          const_AnglePID_P,
							 		          const_AnglePID_D))
						 	)\union(getsetLocalChannels,clockSync)
						)
						)
					
					
					-- Visible counterparts
					MachineBody_VS_O(id__,
								param_newError,
								param_diff,
							    const_AnglePID_P,
							    const_AnglePID_D) = 
						dbisim((
						let
							finalNodesEntered = {|f0::entered|}
						within
							(dbisim((dbisim((let
								-- IMPLEMENTATION NOTE:
								-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
								-- modules for defining the semantics of each node.
								enterSS = {|
								i0::enter,
								UpdateOutput::enter,
								f0::enter
								|}
								hideSet = union(enterSS,{|exit,exited,internal__|})
							within 
								((let
									-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
									-- because CSPM modules are used for the semantics of Node.
									flowevts = union(enterSS,{|exit,exited,interrupt|})
									transSync = {|internal__.NID_i0,internal__.NID_UpdateOutput|}
								within
									((
									 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
									   i0::VS_O__(id__,
									   			param_newError,
									   			param_diff,
									   		    const_AnglePID_P,
									   		    const_AnglePID_D)
									   [| { share__, terminate } |] (
									   UpdateOutput::VS_O__(id__,
									   			param_newError,
									   			param_diff,
									   		    const_AnglePID_P,
									   		    const_AnglePID_D)
									   [| { share__, terminate } |] (
									   f0::VS_O__(id__,
									   			param_newError,
									   			param_diff,
									   		    const_AnglePID_P,
									   		    const_AnglePID_D)
									   )
									   )
									 )
									 [[UpdateOutput::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_UpdateOutput|}]]
									 [[f0::interrupt <- x__ | x__ <- {|interrupt|}]]
									 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
									 )
									  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
									 )
									 [| union(union(union(flowevts,transSync),{terminate}),{|share__
									|}) |]
									 ((i0::enter -> Transitions(id__,
									 			param_newError,
									 			param_diff,
									 		    const_AnglePID_P,
									 		    const_AnglePID_D))
									  [[ share__ <- x__ | x__ <- {| share__ |} ]]
									 )
									)
									)
								)
								 \ hideSet)
							)
							)
							 [| union(stateClockSync,{terminate}) |]
							 StateClocks(id__,
							 		          const_AnglePID_P,
							 		          const_AnglePID_D)
							)\diff(stateClockSync,enteredSS))
							 [| {| interrupt |} |] SKIP)
						)
						)
					
					Behaviour_VS_O(id__,
								param_newError,
								param_diff,
							    const_AnglePID_P,
							    const_AnglePID_D) = 
						dbisim((let
							stateClockSync = {|get_CLID_UpdateOutput,UpdateOutput::entered|}
						 within
							(MachineBody_VS_O(id__,
										param_newError,
										param_diff,
									    const_AnglePID_P,
									    const_AnglePID_D) [| union(stateClockSync,{terminate}) |] StateClocks(id__,
									          const_AnglePID_P,
									          const_AnglePID_D)) \ diff(union(stateClockSync,enteredSS),enteredSS)
						)
						)
					
					
					Stateful_VS_O(id__,
								param_newError,
								param_diff,
							    const_AnglePID_P,
							    const_AnglePID_D) = 
						dbisim((let
							getsetLocalChannels = {||}
							clockSync = {||}
						within
							(Behaviour_VS_O(id__,
										param_newError,
										param_diff,
									    const_AnglePID_P,
									    const_AnglePID_D) 
							 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
							 (varMemory(id__,
							 			param_newError,
							 			param_diff,
							 		    const_AnglePID_P,
							 		    const_AnglePID_D) [| {terminate} |] Clocks(id__,
							 		          const_AnglePID_P,
							 		          const_AnglePID_D))
						 	)\union(getsetLocalChannels,clockSync)
						)
						)
					
					
					-- END
					
					-- Memory
					-- Memory variables
					
					-- varMemory process
					varMemory(id__,
								param_newError,
								param_diff,
							    const_AnglePID_P,
							    const_AnglePID_D) = terminate -> SKIP
					
					getsetLocalChannels = {||}
					
					-- Definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
					FVS__(id__,
								param_newError,
								param_diff,
							    const_AnglePID_P,
							    const_AnglePID_D) = STM_VS_O(id__,
								param_newError,
								param_diff,
							    const_AnglePID_P,
							    const_AnglePID_D) \ localClockResets
					D__(id__,
								param_newError,
								param_diff,
							    const_AnglePID_P,
							    const_AnglePID_D) = timed_priority(STM(id__,
								param_newError,
								param_diff,
							    const_AnglePID_P,
							    const_AnglePID_D) \ union(internal_events,localClockResets))
					O__(id__,
								param_newError,
								param_diff,
							    const_AnglePID_P,
							    const_AnglePID_D) = dbisim(D__(id__,
								param_newError,
								param_diff,
							    const_AnglePID_P,
							    const_AnglePID_D))
					VS__(id__,
								param_newError,
								param_diff,
							    const_AnglePID_P,
							    const_AnglePID_D) = FVS__(id__,
								param_newError,
								param_diff,
							    const_AnglePID_P,
							    const_AnglePID_D)
					VS_O__(id__,
								param_newError,
								param_diff,
							    const_AnglePID_P,
							    const_AnglePID_D) = dbisim(FVS__(id__,
								param_newError,
								param_diff,
							    const_AnglePID_P,
							    const_AnglePID_D))
					HEXT__(id__,
								param_newError,
								param_diff,
							    const_AnglePID_P,
							    const_AnglePID_D) = O__(id__,
								param_newError,
								param_diff,
							    const_AnglePID_P,
							    const_AnglePID_D) [|shared_variable_events|] SKIP
					FVS_C__(id__,
								param_newError,
								param_diff,
							    const_AnglePID_P,
							    const_AnglePID_D) = dbisim(timed_priority(STM(id__,
								param_newError,
								param_diff,
							    const_AnglePID_P,
							    const_AnglePID_D) \ internal_events))
					HUP__(id__,
								param_newError,
								param_diff,
							    const_AnglePID_P,
							    const_AnglePID_D) = timed_priority(O__(id__,
								param_newError,
								param_diff,
							    const_AnglePID_P,
							    const_AnglePID_D) [|{share__}|] SKIP)
					
					-- Clocks
					
					Clocks(id__,
							          const_AnglePID_P,
							          const_AnglePID_D) = terminate -> SKIP
					
					clockSync = {||}
					
					Clock_CLID_UpdateOutput(id__,x__,
							          const_AnglePID_P,
							          const_AnglePID_D) = 
						TimeOut_1(
							UpdateOutput::entered -> Clock_CLID_UpdateOutput(id__,0,
									          const_AnglePID_P,
									          const_AnglePID_D)
							[]
							get_CLID_UpdateOutput!x__ -> Clock_CLID_UpdateOutput(id__,x__,
									          const_AnglePID_P,
									          const_AnglePID_D)
							[]
							terminate -> SKIP,Clock_CLID_UpdateOutput(id__,clock_type_plus(x__,1,CLID_UpdateOutput_clock_type(id__,
									          const_AnglePID_P,
									          const_AnglePID_D)),
									          const_AnglePID_P,
									          const_AnglePID_D))
					
					StateClocks(id__,
							          const_AnglePID_P,
							          const_AnglePID_D) = dbisim(Clock_CLID_UpdateOutput(id__,0,
							          const_AnglePID_P,
							          const_AnglePID_D))
					
					stateClockSync = {|get_CLID_UpdateOutput,UpdateOutput::entered|}
					}
						endmodule
			-- compileOperationDef
			module OP_SpeedPID
			exports
				transparent diamond
				transparent sbisim
				transparent dbisim
				transparent chase
				
				-- Transition identifiers
				-- declaring identifiers of transitions
				datatype NIDS = 
				              NID_i0|
				              NID_UpdateIntegral|
				              NID_UpdateOutput|
				              NID_f0
				
				channel internal__ : NIDS
				
				-- Flow channels		
				channel interrupt
				channel exited
				channel exit
				channel terminate
				
				-- Variable channels
				channel get_speedIntegral, set_speedIntegral, setL_speedIntegral, setR_speedIntegral: core_real
				channel get_speedOutput, set_speedOutput, setL_speedOutput, setR_speedOutput: core_real
				
				-- Shared variable channels
				channel set_EXT_speedIntegral: core_real
				channel set_EXT_speedOutput: core_real
				
				-- Local variable channels for defined operations that are required by the state machine
				
				-- Declaring state machine events
				
				-- Declaring call and ret events for undefined operations
				
				enterSS = {|
				i0::enter,
				UpdateIntegral::enter,
				UpdateOutput::enter,
				f0::enter
				|}
				
				enteredSS = 	{|
				UpdateIntegral::entered,
				UpdateOutput::entered,
				f0::entered
				|}
				
				internal_events = union(enteredSS,union(enterSS,{|interrupt,exited|}))
				
				shared_variable_events = {|
					set_EXT_speedIntegral,
					set_EXT_speedOutput
				|}
				
				-- channel set with all visible events
				sem__events = {|
					terminate
				,	set_EXT_speedIntegral, set_speedIntegral,
					set_EXT_speedOutput, set_speedOutput
					, share__
					|}
				
				channel clockReset, clockResetL, clockResetR 
				
				localClockResets = {||}
				
				
				channel get_CLID_f0 : core_clock_type 
				channel get_CLID_UpdateIntegral : core_clock_type 
				channel get_CLID_UpdateOutput : core_clock_type 
				--channel increment__
				
				CLID_f0_clock_type(id__,
						          const_SpeedPID_P,
						          const_SpeedPID_I,
						          const_SpeedPID_maxIntegral) = 
					let
						max = (clock_type_max(Union({
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_UpdateIntegral_clock_type(id__,
						          const_SpeedPID_P,
						          const_SpeedPID_I,
						          const_SpeedPID_maxIntegral) = 
					let
						max = (clock_type_max(Union({
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_UpdateOutput_clock_type(id__,
						          const_SpeedPID_P,
						          const_SpeedPID_I,
						          const_SpeedPID_maxIntegral) = 
					let
						max = (clock_type_max(Union({
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				
				
					-- Nodes --
					-- declaring all nodes
					
					----------------------------------------------------------------------
					-- Initial: i0
					module i0
					exports
					
						channel enter, interrupt
						
						Timed(OneStep) {
							D__(id__,
										param_newError,
									    const_SpeedPID_P,
									    const_SpeedPID_I,
									    const_SpeedPID_maxIntegral) = 
								dbisim(let
									Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
									
									Termination = terminate -> SKIP
									
									Active 		= share__choice(interrupt -> SKIP) ; Inactive
								within
									Inactive [| {terminate} |> SKIP)
							
							VS_O__(id__,
										param_newError,
									    const_SpeedPID_P,
									    const_SpeedPID_I,
									    const_SpeedPID_maxIntegral) = D__(id__,
										param_newError,
									    const_SpeedPID_P,
									    const_SpeedPID_I,
									    const_SpeedPID_maxIntegral)
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: UpdateIntegral
					module UpdateIntegral
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
										param_newError,
									    const_SpeedPID_P,
									    const_SpeedPID_I,
									    const_SpeedPID_maxIntegral) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(share__choice(get_speedIntegral?speedIntegral -> true & (share__choice(set_speedIntegral!Plus(speedIntegral, param_newError, core_real) -> SKIP))));share__choice(share__choice(get_speedIntegral?speedIntegral -> true & (share__choice(set_speedIntegral!(if (speedIntegral>const_SpeedPID_maxIntegral) then const_SpeedPID_maxIntegral else (if (speedIntegral<Neg(const_SpeedPID_maxIntegral, core_real)) then Neg(const_SpeedPID_maxIntegral, core_real) else speedIntegral)) -> SKIP)))) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
										param_newError,
									    const_SpeedPID_P,
									    const_SpeedPID_I,
									    const_SpeedPID_maxIntegral) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(share__choice(get_speedIntegral?speedIntegral -> true & (share__choice(set_speedIntegral!Plus(speedIntegral, param_newError, core_real) -> SKIP))));share__choice(share__choice(get_speedIntegral?speedIntegral -> true & (share__choice(set_speedIntegral!(if (speedIntegral>const_SpeedPID_maxIntegral) then const_SpeedPID_maxIntegral else (if (speedIntegral<Neg(const_SpeedPID_maxIntegral, core_real)) then Neg(const_SpeedPID_maxIntegral, core_real) else speedIntegral)) -> SKIP)))) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_SpeedPID_P,
									          const_SpeedPID_I,
									          const_SpeedPID_maxIntegral) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: UpdateOutput
					module UpdateOutput
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
										param_newError,
									    const_SpeedPID_P,
									    const_SpeedPID_I,
									    const_SpeedPID_maxIntegral) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(share__choice(get_speedIntegral?speedIntegral -> true & (share__choice(set_speedOutput!Plus(Mult(param_newError, const_SpeedPID_P, core_real), Mult(speedIntegral, const_SpeedPID_I, core_real), core_real) -> SKIP)))) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
										param_newError,
									    const_SpeedPID_P,
									    const_SpeedPID_I,
									    const_SpeedPID_maxIntegral) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(share__choice(get_speedIntegral?speedIntegral -> true & (share__choice(set_speedOutput!Plus(Mult(param_newError, const_SpeedPID_P, core_real), Mult(speedIntegral, const_SpeedPID_I, core_real), core_real) -> SKIP)))) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_SpeedPID_P,
									          const_SpeedPID_I,
									          const_SpeedPID_maxIntegral) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- Final state: f0
					module f0
					
					exports
					
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							D__(id__,
										param_newError,
									    const_SpeedPID_P,
									    const_SpeedPID_I,
									    const_SpeedPID_maxIntegral) = 
								dbisim(let
									Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Entering
									
									Entering 	= entered -> SKIP ; Active
									Active		= share__choice(terminate -> SKIP [] interrupt -> SKIP) ; Interrupted
									Interrupted	= share__choice(exit -> exited -> Inactive)
								within
									Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
										param_newError,
									    const_SpeedPID_P,
									    const_SpeedPID_I,
									    const_SpeedPID_maxIntegral) = D__(id__,
										param_newError,
									    const_SpeedPID_P,
									    const_SpeedPID_I,
									    const_SpeedPID_maxIntegral)
						}
					
					endmodule
					----------------------------------------------------------------------
					
					-- END of Nodes --
					
					Timed(OneStep) {
					-- Operation calls --
					-- Only the undefined operations are declared here.
					-- If the state machine is in isolation, all required operations will be undefined.
					-- If it is in the context of a controller, the required operations not provided by the
					-- controller will be declared here, and the defined operations will be defined in the
					-- context of the Controller module, and therefore within scope of the state machine module.
					
					-- END of Operation calls --
				
					-- STM processes
					STM(id__,
								param_newError,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral) = -- RULE: [[stm:OperationDef]]_STM^nops : CSPProcess
					Stateful(id__,
								param_newError,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral) \ {terminate}
					
					STM_VS_O(id__,
								param_newError,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral) = -- RULE: [[stm:OperationDef]]_STM^nops : CSPProcess
					Stateful(id__,
								param_newError,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral) \ {terminate}
					
					-- Transitions
					Transitions(id__,
								param_newError,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral) = ((let
						Trans = TimeOut_1(
							 (share__ -> SKIP
							 [] dbisim((true)&(internal__!NID_i0 -> SKIP ;  ((SKIP ; UpdateIntegral::enter -> SKIP))))
							 [] dbisim((true)&(internal__!NID_UpdateIntegral -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; UpdateOutput::enter -> SKIP)))
							 [] dbisim((true)&(internal__!NID_UpdateOutput -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; f0::enter -> SKIP)))
							 []
							 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
							 []
							 terminate -> SKIP
							 )
						,SKIP);Trans
					within
						Trans [|{terminate}|> SKIP
					)
					)
					
					-- Stateful
					-- RULE: Stateful(stm:StateMachineBody) : CSPProcess
					
					-- Named process definitions
					MachineBody(id__,
								param_newError,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral) = 
						dbisim((
						let
							finalNodesEntered = {|f0::entered|}
						within
							(dbisim((dbisim((let
								-- IMPLEMENTATION NOTE:
								-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
								-- modules for defining the semantics of each node.
								enterSS = {|
								i0::enter,
								UpdateIntegral::enter,
								UpdateOutput::enter,
								f0::enter
								|}
								hideSet = union(enterSS,{|exit,exited,internal__|})
							within 
								((let
									-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
									-- because CSPM modules are used for the semantics of Node.
									flowevts = union(enterSS,{|exit,exited,interrupt|})
									transSync = {|internal__.NID_i0,internal__.NID_UpdateIntegral,internal__.NID_UpdateOutput|}
								within
									((
									 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
									   i0::D__(id__,
									   			param_newError,
									   		    const_SpeedPID_P,
									   		    const_SpeedPID_I,
									   		    const_SpeedPID_maxIntegral)
									   [| { share__, terminate } |] (
									   UpdateIntegral::D__(id__,
									   			param_newError,
									   		    const_SpeedPID_P,
									   		    const_SpeedPID_I,
									   		    const_SpeedPID_maxIntegral)
									   [| { share__, terminate } |] (
									   UpdateOutput::D__(id__,
									   			param_newError,
									   		    const_SpeedPID_P,
									   		    const_SpeedPID_I,
									   		    const_SpeedPID_maxIntegral)
									   [| { share__, terminate } |] (
									   f0::D__(id__,
									   			param_newError,
									   		    const_SpeedPID_P,
									   		    const_SpeedPID_I,
									   		    const_SpeedPID_maxIntegral)
									   )
									   )
									   )
									 )
									 [[UpdateIntegral::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_UpdateIntegral|}]]
									 [[UpdateOutput::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_UpdateOutput|}]]
									 [[f0::interrupt <- x__ | x__ <- {|interrupt|}]]
									 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
									 )
									  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
									 )
									 [| union(union(union(flowevts,transSync),{terminate}),{|share__
									|}) |]
									 ((i0::enter -> Transitions(id__,
									 			param_newError,
									 		    const_SpeedPID_P,
									 		    const_SpeedPID_I,
									 		    const_SpeedPID_maxIntegral))
									  [[ share__ <- x__ | x__ <- {| share__ |} ]]
									 )
									)
									)
								)
								 \ hideSet)
							)
							)
							 [| union(stateClockSync,{terminate}) |]
							 StateClocks(id__,
							 		          const_SpeedPID_P,
							 		          const_SpeedPID_I,
							 		          const_SpeedPID_maxIntegral)
							)\diff(stateClockSync,enteredSS))
							 [| {| interrupt |} |] SKIP)
						)
						)
					
					Behaviour(id__,
								param_newError,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral) = 
						dbisim((let
							stateClockSync = {|get_CLID_UpdateIntegral,UpdateIntegral::entered,get_CLID_UpdateOutput,UpdateOutput::entered|}
						 within
							(MachineBody(id__,
										param_newError,
									    const_SpeedPID_P,
									    const_SpeedPID_I,
									    const_SpeedPID_maxIntegral) [| union(stateClockSync,{terminate}) |] StateClocks(id__,
									          const_SpeedPID_P,
									          const_SpeedPID_I,
									          const_SpeedPID_maxIntegral)) \ union(stateClockSync,enteredSS)
						)
						)
					
					
					Stateful(id__,
								param_newError,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral) = 
						((let
							getsetLocalChannels = {||}
							clockSync = {||}
						within
							(Behaviour(id__,
										param_newError,
									    const_SpeedPID_P,
									    const_SpeedPID_I,
									    const_SpeedPID_maxIntegral) 
							 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
							 (varMemory(id__,
							 			param_newError,
							 		    const_SpeedPID_P,
							 		    const_SpeedPID_I,
							 		    const_SpeedPID_maxIntegral) [| {terminate} |] Clocks(id__,
							 		          const_SpeedPID_P,
							 		          const_SpeedPID_I,
							 		          const_SpeedPID_maxIntegral))
						 	)\union(getsetLocalChannels,clockSync)
						)
						)
					
					
					-- Visible counterparts
					MachineBody_VS_O(id__,
								param_newError,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral) = 
						dbisim((
						let
							finalNodesEntered = {|f0::entered|}
						within
							(dbisim((dbisim((let
								-- IMPLEMENTATION NOTE:
								-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
								-- modules for defining the semantics of each node.
								enterSS = {|
								i0::enter,
								UpdateIntegral::enter,
								UpdateOutput::enter,
								f0::enter
								|}
								hideSet = union(enterSS,{|exit,exited,internal__|})
							within 
								((let
									-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
									-- because CSPM modules are used for the semantics of Node.
									flowevts = union(enterSS,{|exit,exited,interrupt|})
									transSync = {|internal__.NID_i0,internal__.NID_UpdateIntegral,internal__.NID_UpdateOutput|}
								within
									((
									 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
									   i0::VS_O__(id__,
									   			param_newError,
									   		    const_SpeedPID_P,
									   		    const_SpeedPID_I,
									   		    const_SpeedPID_maxIntegral)
									   [| { share__, terminate } |] (
									   UpdateIntegral::VS_O__(id__,
									   			param_newError,
									   		    const_SpeedPID_P,
									   		    const_SpeedPID_I,
									   		    const_SpeedPID_maxIntegral)
									   [| { share__, terminate } |] (
									   UpdateOutput::VS_O__(id__,
									   			param_newError,
									   		    const_SpeedPID_P,
									   		    const_SpeedPID_I,
									   		    const_SpeedPID_maxIntegral)
									   [| { share__, terminate } |] (
									   f0::VS_O__(id__,
									   			param_newError,
									   		    const_SpeedPID_P,
									   		    const_SpeedPID_I,
									   		    const_SpeedPID_maxIntegral)
									   )
									   )
									   )
									 )
									 [[UpdateIntegral::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_UpdateIntegral|}]]
									 [[UpdateOutput::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_UpdateOutput|}]]
									 [[f0::interrupt <- x__ | x__ <- {|interrupt|}]]
									 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
									 )
									  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
									 )
									 [| union(union(union(flowevts,transSync),{terminate}),{|share__
									|}) |]
									 ((i0::enter -> Transitions(id__,
									 			param_newError,
									 		    const_SpeedPID_P,
									 		    const_SpeedPID_I,
									 		    const_SpeedPID_maxIntegral))
									  [[ share__ <- x__ | x__ <- {| share__ |} ]]
									 )
									)
									)
								)
								 \ hideSet)
							)
							)
							 [| union(stateClockSync,{terminate}) |]
							 StateClocks(id__,
							 		          const_SpeedPID_P,
							 		          const_SpeedPID_I,
							 		          const_SpeedPID_maxIntegral)
							)\diff(stateClockSync,enteredSS))
							 [| {| interrupt |} |] SKIP)
						)
						)
					
					Behaviour_VS_O(id__,
								param_newError,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral) = 
						dbisim((let
							stateClockSync = {|get_CLID_UpdateIntegral,UpdateIntegral::entered,get_CLID_UpdateOutput,UpdateOutput::entered|}
						 within
							(MachineBody_VS_O(id__,
										param_newError,
									    const_SpeedPID_P,
									    const_SpeedPID_I,
									    const_SpeedPID_maxIntegral) [| union(stateClockSync,{terminate}) |] StateClocks(id__,
									          const_SpeedPID_P,
									          const_SpeedPID_I,
									          const_SpeedPID_maxIntegral)) \ diff(union(stateClockSync,enteredSS),enteredSS)
						)
						)
					
					
					Stateful_VS_O(id__,
								param_newError,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral) = 
						dbisim((let
							getsetLocalChannels = {||}
							clockSync = {||}
						within
							(Behaviour_VS_O(id__,
										param_newError,
									    const_SpeedPID_P,
									    const_SpeedPID_I,
									    const_SpeedPID_maxIntegral) 
							 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
							 (varMemory(id__,
							 			param_newError,
							 		    const_SpeedPID_P,
							 		    const_SpeedPID_I,
							 		    const_SpeedPID_maxIntegral) [| {terminate} |] Clocks(id__,
							 		          const_SpeedPID_P,
							 		          const_SpeedPID_I,
							 		          const_SpeedPID_maxIntegral))
						 	)\union(getsetLocalChannels,clockSync)
						)
						)
					
					
					-- END
					
					-- Memory
					-- Memory variables
					
					-- varMemory process
					varMemory(id__,
								param_newError,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral) = terminate -> SKIP
					
					getsetLocalChannels = {||}
					
					-- Definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
					FVS__(id__,
								param_newError,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral) = STM_VS_O(id__,
								param_newError,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral) \ localClockResets
					D__(id__,
								param_newError,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral) = timed_priority(STM(id__,
								param_newError,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral) \ union(internal_events,localClockResets))
					O__(id__,
								param_newError,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral) = dbisim(D__(id__,
								param_newError,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral))
					VS__(id__,
								param_newError,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral) = FVS__(id__,
								param_newError,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral)
					VS_O__(id__,
								param_newError,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral) = dbisim(FVS__(id__,
								param_newError,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral))
					HEXT__(id__,
								param_newError,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral) = O__(id__,
								param_newError,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral) [|shared_variable_events|] SKIP
					FVS_C__(id__,
								param_newError,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral) = dbisim(timed_priority(STM(id__,
								param_newError,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral) \ internal_events))
					HUP__(id__,
								param_newError,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral) = timed_priority(O__(id__,
								param_newError,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral) [|{share__}|] SKIP)
					
					-- Clocks
					
					Clocks(id__,
							          const_SpeedPID_P,
							          const_SpeedPID_I,
							          const_SpeedPID_maxIntegral) = terminate -> SKIP
					
					clockSync = {||}
					
					Clock_CLID_UpdateIntegral(id__,x__,
							          const_SpeedPID_P,
							          const_SpeedPID_I,
							          const_SpeedPID_maxIntegral) = 
						TimeOut_1(
							UpdateIntegral::entered -> Clock_CLID_UpdateIntegral(id__,0,
									          const_SpeedPID_P,
									          const_SpeedPID_I,
									          const_SpeedPID_maxIntegral)
							[]
							get_CLID_UpdateIntegral!x__ -> Clock_CLID_UpdateIntegral(id__,x__,
									          const_SpeedPID_P,
									          const_SpeedPID_I,
									          const_SpeedPID_maxIntegral)
							[]
							terminate -> SKIP,Clock_CLID_UpdateIntegral(id__,clock_type_plus(x__,1,CLID_UpdateIntegral_clock_type(id__,
									          const_SpeedPID_P,
									          const_SpeedPID_I,
									          const_SpeedPID_maxIntegral)),
									          const_SpeedPID_P,
									          const_SpeedPID_I,
									          const_SpeedPID_maxIntegral))
					Clock_CLID_UpdateOutput(id__,x__,
							          const_SpeedPID_P,
							          const_SpeedPID_I,
							          const_SpeedPID_maxIntegral) = 
						TimeOut_1(
							UpdateOutput::entered -> Clock_CLID_UpdateOutput(id__,0,
									          const_SpeedPID_P,
									          const_SpeedPID_I,
									          const_SpeedPID_maxIntegral)
							[]
							get_CLID_UpdateOutput!x__ -> Clock_CLID_UpdateOutput(id__,x__,
									          const_SpeedPID_P,
									          const_SpeedPID_I,
									          const_SpeedPID_maxIntegral)
							[]
							terminate -> SKIP,Clock_CLID_UpdateOutput(id__,clock_type_plus(x__,1,CLID_UpdateOutput_clock_type(id__,
									          const_SpeedPID_P,
									          const_SpeedPID_I,
									          const_SpeedPID_maxIntegral)),
									          const_SpeedPID_P,
									          const_SpeedPID_I,
									          const_SpeedPID_maxIntegral))
					
					StateClocks(id__,
							          const_SpeedPID_P,
							          const_SpeedPID_I,
							          const_SpeedPID_maxIntegral) = dbisim(Clock_CLID_UpdateIntegral(id__,0,
							          const_SpeedPID_P,
							          const_SpeedPID_I,
							          const_SpeedPID_maxIntegral))
					[| { terminate } |] (
					dbisim(Clock_CLID_UpdateOutput(id__,0,
							          const_SpeedPID_P,
							          const_SpeedPID_I,
							          const_SpeedPID_maxIntegral))
					)
					
					stateClockSync = {|get_CLID_UpdateIntegral,UpdateIntegral::entered,get_CLID_UpdateOutput,UpdateOutput::entered|}
					}
						endmodule
			-- compileOperationDef
			module OP_RotationPID
			exports
				transparent diamond
				transparent sbisim
				transparent dbisim
				transparent chase
				
				-- Transition identifiers
				-- declaring identifiers of transitions
				datatype NIDS = 
				              NID_i0|
				              NID_f0
				
				channel internal__ : NIDS
				
				-- Flow channels		
				channel interrupt
				channel exited
				channel exit
				channel terminate
				
				-- Variable channels
				channel get_rotationOutput, set_rotationOutput, setL_rotationOutput, setR_rotationOutput: core_real
				
				-- Shared variable channels
				channel set_EXT_rotationOutput: core_real
				
				-- Local variable channels for defined operations that are required by the state machine
				
				-- Declaring state machine events
				
				-- Declaring call and ret events for undefined operations
				
				enterSS = {|
				i0::enter,
				f0::enter
				|}
				
				enteredSS = 	{|
				f0::entered
				|}
				
				internal_events = union(enteredSS,union(enterSS,{|interrupt,exited|}))
				
				shared_variable_events = {|
					set_EXT_rotationOutput
				|}
				
				-- channel set with all visible events
				sem__events = {|
					terminate
				,	set_EXT_rotationOutput, set_rotationOutput
					, share__
					|}
				
				channel clockReset, clockResetL, clockResetR 
				
				localClockResets = {||}
				
				
				channel get_CLID_f0 : core_clock_type 
				--channel increment__
				
				CLID_f0_clock_type(id__,
						          const_RotationPID_D) = 
					let
						max = (clock_type_max(Union({
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				
				
					-- Nodes --
					-- declaring all nodes
					
					----------------------------------------------------------------------
					-- Initial: i0
					module i0
					exports
					
						channel enter, interrupt
						
						Timed(OneStep) {
							D__(id__,
										param_diff,
									    const_RotationPID_D) = 
								dbisim(let
									Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
									
									Termination = terminate -> SKIP
									
									Active 		= share__choice(interrupt -> SKIP) ; Inactive
								within
									Inactive [| {terminate} |> SKIP)
							
							VS_O__(id__,
										param_diff,
									    const_RotationPID_D) = D__(id__,
										param_diff,
									    const_RotationPID_D)
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- Final state: f0
					module f0
					
					exports
					
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							D__(id__,
										param_diff,
									    const_RotationPID_D) = 
								dbisim(let
									Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Entering
									
									Entering 	= entered -> SKIP ; Active
									Active		= share__choice(terminate -> SKIP [] interrupt -> SKIP) ; Interrupted
									Interrupted	= share__choice(exit -> exited -> Inactive)
								within
									Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
										param_diff,
									    const_RotationPID_D) = D__(id__,
										param_diff,
									    const_RotationPID_D)
						}
					
					endmodule
					----------------------------------------------------------------------
					
					-- END of Nodes --
					
					Timed(OneStep) {
					-- Operation calls --
					-- Only the undefined operations are declared here.
					-- If the state machine is in isolation, all required operations will be undefined.
					-- If it is in the context of a controller, the required operations not provided by the
					-- controller will be declared here, and the defined operations will be defined in the
					-- context of the Controller module, and therefore within scope of the state machine module.
					
					-- END of Operation calls --
				
					-- STM processes
					STM(id__,
								param_diff,
							    const_RotationPID_D) = -- RULE: [[stm:OperationDef]]_STM^nops : CSPProcess
					Stateful(id__,
								param_diff,
							    const_RotationPID_D) \ {terminate}
					
					STM_VS_O(id__,
								param_diff,
							    const_RotationPID_D) = -- RULE: [[stm:OperationDef]]_STM^nops : CSPProcess
					Stateful(id__,
								param_diff,
							    const_RotationPID_D) \ {terminate}
					
					-- Transitions
					Transitions(id__,
								param_diff,
							    const_RotationPID_D) = ((let
						Trans = TimeOut_1(
							 (share__ -> SKIP
							 [] dbisim((true)&(internal__!NID_i0 -> SKIP ;  ((share__choice(true & (share__choice(set_rotationOutput!Mult(const_RotationPID_D, param_diff, core_real) -> SKIP))) ; f0::enter -> SKIP))))
							 []
							 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
							 []
							 terminate -> SKIP
							 )
						,SKIP);Trans
					within
						Trans [|{terminate}|> SKIP
					)
					)
					
					-- Stateful
					-- RULE: Stateful(stm:StateMachineBody) : CSPProcess
					
					-- Named process definitions
					MachineBody(id__,
								param_diff,
							    const_RotationPID_D) = 
						dbisim((
						let
							finalNodesEntered = {|f0::entered|}
						within
							(dbisim((dbisim((let
								-- IMPLEMENTATION NOTE:
								-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
								-- modules for defining the semantics of each node.
								enterSS = {|
								i0::enter,
								f0::enter
								|}
								hideSet = union(enterSS,{|exit,exited,internal__|})
							within 
								((let
									-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
									-- because CSPM modules are used for the semantics of Node.
									flowevts = union(enterSS,{|exit,exited,interrupt|})
									transSync = {|internal__.NID_i0|}
								within
									((
									 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
									   i0::D__(id__,
									   			param_diff,
									   		    const_RotationPID_D)
									   [| { share__, terminate } |] (
									   f0::D__(id__,
									   			param_diff,
									   		    const_RotationPID_D)
									   )
									 )
									 [[f0::interrupt <- x__ | x__ <- {|interrupt|}]]
									 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
									 )
									  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
									 )
									 [| union(union(union(flowevts,transSync),{terminate}),{|share__
									|}) |]
									 ((i0::enter -> Transitions(id__,
									 			param_diff,
									 		    const_RotationPID_D))
									  [[ share__ <- x__ | x__ <- {| share__ |} ]]
									 )
									)
									)
								)
								 \ hideSet)
							)
							)
							 [| union(stateClockSync,{terminate}) |]
							 StateClocks(id__,
							 		          const_RotationPID_D)
							)\diff(stateClockSync,enteredSS))
							 [| {| interrupt |} |] SKIP)
						)
						)
					
					Behaviour(id__,
								param_diff,
							    const_RotationPID_D) = 
						dbisim((let
							stateClockSync = {||}
						 within
							(MachineBody(id__,
										param_diff,
									    const_RotationPID_D) [| union(stateClockSync,{terminate}) |] StateClocks(id__,
									          const_RotationPID_D)) \ union(stateClockSync,enteredSS)
						)
						)
					
					
					Stateful(id__,
								param_diff,
							    const_RotationPID_D) = 
						((let
							getsetLocalChannels = {||}
							clockSync = {||}
						within
							(Behaviour(id__,
										param_diff,
									    const_RotationPID_D) 
							 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
							 (varMemory(id__,
							 			param_diff,
							 		    const_RotationPID_D) [| {terminate} |] Clocks(id__,
							 		          const_RotationPID_D))
						 	)\union(getsetLocalChannels,clockSync)
						)
						)
					
					
					-- Visible counterparts
					MachineBody_VS_O(id__,
								param_diff,
							    const_RotationPID_D) = 
						dbisim((
						let
							finalNodesEntered = {|f0::entered|}
						within
							(dbisim((dbisim((let
								-- IMPLEMENTATION NOTE:
								-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
								-- modules for defining the semantics of each node.
								enterSS = {|
								i0::enter,
								f0::enter
								|}
								hideSet = union(enterSS,{|exit,exited,internal__|})
							within 
								((let
									-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
									-- because CSPM modules are used for the semantics of Node.
									flowevts = union(enterSS,{|exit,exited,interrupt|})
									transSync = {|internal__.NID_i0|}
								within
									((
									 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
									   i0::VS_O__(id__,
									   			param_diff,
									   		    const_RotationPID_D)
									   [| { share__, terminate } |] (
									   f0::VS_O__(id__,
									   			param_diff,
									   		    const_RotationPID_D)
									   )
									 )
									 [[f0::interrupt <- x__ | x__ <- {|interrupt|}]]
									 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
									 )
									  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
									 )
									 [| union(union(union(flowevts,transSync),{terminate}),{|share__
									|}) |]
									 ((i0::enter -> Transitions(id__,
									 			param_diff,
									 		    const_RotationPID_D))
									  [[ share__ <- x__ | x__ <- {| share__ |} ]]
									 )
									)
									)
								)
								 \ hideSet)
							)
							)
							 [| union(stateClockSync,{terminate}) |]
							 StateClocks(id__,
							 		          const_RotationPID_D)
							)\diff(stateClockSync,enteredSS))
							 [| {| interrupt |} |] SKIP)
						)
						)
					
					Behaviour_VS_O(id__,
								param_diff,
							    const_RotationPID_D) = 
						dbisim((let
							stateClockSync = {||}
						 within
							(MachineBody_VS_O(id__,
										param_diff,
									    const_RotationPID_D) [| union(stateClockSync,{terminate}) |] StateClocks(id__,
									          const_RotationPID_D)) \ diff(union(stateClockSync,enteredSS),enteredSS)
						)
						)
					
					
					Stateful_VS_O(id__,
								param_diff,
							    const_RotationPID_D) = 
						dbisim((let
							getsetLocalChannels = {||}
							clockSync = {||}
						within
							(Behaviour_VS_O(id__,
										param_diff,
									    const_RotationPID_D) 
							 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
							 (varMemory(id__,
							 			param_diff,
							 		    const_RotationPID_D) [| {terminate} |] Clocks(id__,
							 		          const_RotationPID_D))
						 	)\union(getsetLocalChannels,clockSync)
						)
						)
					
					
					-- END
					
					-- Memory
					-- Memory variables
					
					-- varMemory process
					varMemory(id__,
								param_diff,
							    const_RotationPID_D) = terminate -> SKIP
					
					getsetLocalChannels = {||}
					
					-- Definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
					FVS__(id__,
								param_diff,
							    const_RotationPID_D) = STM_VS_O(id__,
								param_diff,
							    const_RotationPID_D) \ localClockResets
					D__(id__,
								param_diff,
							    const_RotationPID_D) = timed_priority(STM(id__,
								param_diff,
							    const_RotationPID_D) \ union(internal_events,localClockResets))
					O__(id__,
								param_diff,
							    const_RotationPID_D) = dbisim(D__(id__,
								param_diff,
							    const_RotationPID_D))
					VS__(id__,
								param_diff,
							    const_RotationPID_D) = FVS__(id__,
								param_diff,
							    const_RotationPID_D)
					VS_O__(id__,
								param_diff,
							    const_RotationPID_D) = dbisim(FVS__(id__,
								param_diff,
							    const_RotationPID_D))
					HEXT__(id__,
								param_diff,
							    const_RotationPID_D) = O__(id__,
								param_diff,
							    const_RotationPID_D) [|shared_variable_events|] SKIP
					FVS_C__(id__,
								param_diff,
							    const_RotationPID_D) = dbisim(timed_priority(STM(id__,
								param_diff,
							    const_RotationPID_D) \ internal_events))
					HUP__(id__,
								param_diff,
							    const_RotationPID_D) = timed_priority(O__(id__,
								param_diff,
							    const_RotationPID_D) [|{share__}|] SKIP)
					
					-- Clocks
					
					Clocks(id__,
							          const_RotationPID_D) = terminate -> SKIP
					
					clockSync = {||}
					
					
					StateClocks(id__,
							          const_RotationPID_D) = terminate -> SKIP
					
					stateClockSync = {||}
					}
						endmodule
		
			-- declaring machines
			module stm_ref0
			exports
				transparent diamond
				transparent sbisim
				transparent dbisim
				transparent chase
			
				-- Transition identifiers
				-- declaring identifiers of transitions
				datatype NIDS = 
				              NID_i0|
				              NID_CalculateAngle|
				              NID_CalculateSpeed|
				              NID_CalculateRotation|
				              NID_SetMotors|
				              NID_j0|
				              NID_j1|
				              NID_j2|
				              NID_StopMotors|
				              NID_WaitForNextIteration|
				              NID_Initialisation|
				              NID_j3
				
				channel internal__ : NIDS
				
				-- Flow channels		
				channel interrupt
				channel exited
				channel exit
				channel terminate
				
				-- Variable channels
				channel get_currAngle, set_currAngle, setL_currAngle, setR_currAngle: core_real
				channel get_currGyroX, set_currGyroX, setL_currGyroX, setR_currGyroX: core_real
				channel get_currGyroY, set_currGyroY, setL_currGyroY, setR_currGyroY: core_real
				channel get_currGyroZ, set_currGyroZ, setL_currGyroZ, setR_currGyroZ: core_real
				channel get_currLeftVel, set_currLeftVel, setL_currLeftVel, setR_currLeftVel: core_real
				channel get_currRightVel, set_currRightVel, setL_currRightVel, setR_currRightVel: core_real
				channel get_speedCount, set_speedCount, setL_speedCount, setR_speedCount: core_nat
				channel get_rotationCount, set_rotationCount, setL_rotationCount, setR_rotationCount: core_nat
				channel get_angleOutput, set_angleOutput, setL_angleOutput, setR_angleOutput: core_real
				channel get_speedIntegral, set_speedIntegral, setL_speedIntegral, setR_speedIntegral: core_real
				channel get_speedOutput, set_speedOutput, setL_speedOutput, setR_speedOutput: core_real
				channel get_rotationOutput, set_rotationOutput, setL_rotationOutput, setR_rotationOutput: core_real
				
				-- Shared variable channels
				
				-- Local variable channels for defined operations that are required by the state machine
				
				-- Declaring state machine events
				channel leftMotorVelocity__: NIDS.InOut.core_real
				channel leftMotorVelocity: InOut.core_real
				channel rightMotorVelocity__: NIDS.InOut.core_real
				channel rightMotorVelocity: InOut.core_real
				channel angle__: NIDS.InOut.core_real
				channel angle: InOut.core_real
				channel gyroX__: NIDS.InOut.core_real
				channel gyroX: InOut.core_real
				channel gyroY__: NIDS.InOut.core_real
				channel gyroY: InOut.core_real
				channel gyroZ__: NIDS.InOut.core_real
				channel gyroZ: InOut.core_real
				
				-- Declaring call and ret events for undefined operations
				channel setLeftMotorSpeedCall: core_real
				channel enableInterruptsCall
				channel setRightMotorSpeedCall: core_real
				channel disableInterruptsCall
				
				enterSS = {|
				i0::enter,
				CalculateAngle::enter,
				CalculateSpeed::enter,
				CalculateRotation::enter,
				SetMotors::enter,
				j0::enter,
				j1::enter,
				j2::enter,
				StopMotors::enter,
				WaitForNextIteration::enter,
				Initialisation::enter,
				j3::enter
				|}
				
				enteredSS = 	{|
				CalculateAngle::entered,
				CalculateSpeed::entered,
				CalculateRotation::entered,
				SetMotors::entered,
				StopMotors::entered,
				WaitForNextIteration::entered,
				Initialisation::entered
				|}
				
				internal_events = union(enteredSS,union(enterSS,{|interrupt,exited|}))
				
				shared_variable_events = {|
				|}
				
				-- channel set with all visible events
				sem__events = {|
					terminate
				,	leftMotorVelocity,
					rightMotorVelocity,
					angle,
					gyroX,
					gyroY,
					gyroZ
				,	setLeftMotorSpeedCall,
					enableInterruptsCall,
					setRightMotorSpeedCall,
					disableInterruptsCall
					|}
				datatype ClockSet = 
					CLID_loopTimer
				
				channel clockReset, clockResetL, clockResetR : ClockSet
				
				localClockResets = {|clockReset.CLID_loopTimer|}
				
				
				channel get_CLID_CalculateAngle : core_clock_type 
				channel get_CLID_CalculateSpeed : core_clock_type 
				channel get_CLID_SetMotors : core_clock_type 
				channel get_CLID_CalculateRotation : core_clock_type 
				channel get_CLID_WaitForNextIteration : core_clock_type 
				channel get_CLID_loopTimer : core_clock_type 
				channel get_CLID_Initialisation : core_clock_type 
				channel get_CLID_StopMotors : core_clock_type 
				--channel increment__
				
				CLID_CalculateAngle_clock_type(id__,
						          const_BalanceSTM_maxAngle,
						          const_BalanceSTM_loopTime,
						          const_BalanceSTM_startupDelay,
						          const_BalanceSTM_speedUpdate,
						          const_BalanceSTM_rotationUpdate,
						          const_BalanceSTM_angleBudget,
						          const_BalanceSTM_speedBudget,
						          const_BalanceSTM_rotationBudget,
						          const_BalanceSTM_motorBudget,
						          const_AnglePID_P,
						          const_AnglePID_D,
						          const_SpeedPID_P,
						          const_SpeedPID_I,
						          const_SpeedPID_maxIntegral,
						          const_RotationPID_D) = 
					let
						max = (clock_type_max(Union({
				{}
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_CalculateSpeed_clock_type(id__,
						          const_BalanceSTM_maxAngle,
						          const_BalanceSTM_loopTime,
						          const_BalanceSTM_startupDelay,
						          const_BalanceSTM_speedUpdate,
						          const_BalanceSTM_rotationUpdate,
						          const_BalanceSTM_angleBudget,
						          const_BalanceSTM_speedBudget,
						          const_BalanceSTM_rotationBudget,
						          const_BalanceSTM_motorBudget,
						          const_AnglePID_P,
						          const_AnglePID_D,
						          const_SpeedPID_P,
						          const_SpeedPID_I,
						          const_SpeedPID_maxIntegral,
						          const_RotationPID_D) = 
					let
						max = (clock_type_max(Union({
				{}
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_SetMotors_clock_type(id__,
						          const_BalanceSTM_maxAngle,
						          const_BalanceSTM_loopTime,
						          const_BalanceSTM_startupDelay,
						          const_BalanceSTM_speedUpdate,
						          const_BalanceSTM_rotationUpdate,
						          const_BalanceSTM_angleBudget,
						          const_BalanceSTM_speedBudget,
						          const_BalanceSTM_rotationBudget,
						          const_BalanceSTM_motorBudget,
						          const_AnglePID_P,
						          const_AnglePID_D,
						          const_SpeedPID_P,
						          const_SpeedPID_I,
						          const_SpeedPID_maxIntegral,
						          const_RotationPID_D) = 
					let
						max = (clock_type_max(Union({
				{}
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_CalculateRotation_clock_type(id__,
						          const_BalanceSTM_maxAngle,
						          const_BalanceSTM_loopTime,
						          const_BalanceSTM_startupDelay,
						          const_BalanceSTM_speedUpdate,
						          const_BalanceSTM_rotationUpdate,
						          const_BalanceSTM_angleBudget,
						          const_BalanceSTM_speedBudget,
						          const_BalanceSTM_rotationBudget,
						          const_BalanceSTM_motorBudget,
						          const_AnglePID_P,
						          const_AnglePID_D,
						          const_SpeedPID_P,
						          const_SpeedPID_I,
						          const_SpeedPID_maxIntegral,
						          const_RotationPID_D) = 
					let
						max = (clock_type_max(Union({
				{}
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_WaitForNextIteration_clock_type(id__,
						          const_BalanceSTM_maxAngle,
						          const_BalanceSTM_loopTime,
						          const_BalanceSTM_startupDelay,
						          const_BalanceSTM_speedUpdate,
						          const_BalanceSTM_rotationUpdate,
						          const_BalanceSTM_angleBudget,
						          const_BalanceSTM_speedBudget,
						          const_BalanceSTM_rotationBudget,
						          const_BalanceSTM_motorBudget,
						          const_AnglePID_P,
						          const_AnglePID_D,
						          const_SpeedPID_P,
						          const_SpeedPID_I,
						          const_SpeedPID_maxIntegral,
						          const_RotationPID_D) = 
					let
						max = (clock_type_max(Union({
				{}
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_loopTimer_clock_type(id__,
						          const_BalanceSTM_maxAngle,
						          const_BalanceSTM_loopTime,
						          const_BalanceSTM_startupDelay,
						          const_BalanceSTM_speedUpdate,
						          const_BalanceSTM_rotationUpdate,
						          const_BalanceSTM_angleBudget,
						          const_BalanceSTM_speedBudget,
						          const_BalanceSTM_rotationBudget,
						          const_BalanceSTM_motorBudget,
						          const_AnglePID_P,
						          const_AnglePID_D,
						          const_SpeedPID_P,
						          const_SpeedPID_I,
						          const_SpeedPID_maxIntegral,
						          const_RotationPID_D) = 
					let
						max = (clock_type_max(Union({
				{},
				({const_BalanceSTM_loopTime|loopTime <- core_real})
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_Initialisation_clock_type(id__,
						          const_BalanceSTM_maxAngle,
						          const_BalanceSTM_loopTime,
						          const_BalanceSTM_startupDelay,
						          const_BalanceSTM_speedUpdate,
						          const_BalanceSTM_rotationUpdate,
						          const_BalanceSTM_angleBudget,
						          const_BalanceSTM_speedBudget,
						          const_BalanceSTM_rotationBudget,
						          const_BalanceSTM_motorBudget,
						          const_AnglePID_P,
						          const_AnglePID_D,
						          const_SpeedPID_P,
						          const_SpeedPID_I,
						          const_SpeedPID_maxIntegral,
						          const_RotationPID_D) = 
					let
						max = (clock_type_max(Union({
				{}
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_StopMotors_clock_type(id__,
						          const_BalanceSTM_maxAngle,
						          const_BalanceSTM_loopTime,
						          const_BalanceSTM_startupDelay,
						          const_BalanceSTM_speedUpdate,
						          const_BalanceSTM_rotationUpdate,
						          const_BalanceSTM_angleBudget,
						          const_BalanceSTM_speedBudget,
						          const_BalanceSTM_rotationBudget,
						          const_BalanceSTM_motorBudget,
						          const_AnglePID_P,
						          const_AnglePID_D,
						          const_SpeedPID_P,
						          const_SpeedPID_I,
						          const_SpeedPID_maxIntegral,
						          const_RotationPID_D) = 
					let
						max = (clock_type_max(Union({
				{}
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				
			
					-- Nodes --
					-- declaring all nodes
					
					----------------------------------------------------------------------
					-- Initial: i0
					module i0
					exports
					
						channel enter, interrupt
						
						Timed(OneStep) {
							D__(id__,
									    const_BalanceSTM_maxAngle,
									    const_BalanceSTM_loopTime,
									    const_BalanceSTM_startupDelay,
									    const_BalanceSTM_speedUpdate,
									    const_BalanceSTM_rotationUpdate,
									    const_BalanceSTM_angleBudget,
									    const_BalanceSTM_speedBudget,
									    const_BalanceSTM_rotationBudget,
									    const_BalanceSTM_motorBudget,
									    const_AnglePID_P,
									    const_AnglePID_D,
									    const_SpeedPID_P,
									    const_SpeedPID_I,
									    const_SpeedPID_maxIntegral,
									    const_RotationPID_D) = 
								dbisim(let
									Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
									
									Termination = terminate -> SKIP
									
									Active 		= share__choice(interrupt -> SKIP) ; Inactive
								within
									Inactive [| {terminate} |> SKIP)
							
							VS_O__(id__,
									    const_BalanceSTM_maxAngle,
									    const_BalanceSTM_loopTime,
									    const_BalanceSTM_startupDelay,
									    const_BalanceSTM_speedUpdate,
									    const_BalanceSTM_rotationUpdate,
									    const_BalanceSTM_angleBudget,
									    const_BalanceSTM_speedBudget,
									    const_BalanceSTM_rotationBudget,
									    const_BalanceSTM_motorBudget,
									    const_AnglePID_P,
									    const_AnglePID_D,
									    const_SpeedPID_P,
									    const_SpeedPID_I,
									    const_SpeedPID_maxIntegral,
									    const_RotationPID_D) = D__(id__,
									    const_BalanceSTM_maxAngle,
									    const_BalanceSTM_loopTime,
									    const_BalanceSTM_startupDelay,
									    const_BalanceSTM_speedUpdate,
									    const_BalanceSTM_rotationUpdate,
									    const_BalanceSTM_angleBudget,
									    const_BalanceSTM_speedBudget,
									    const_BalanceSTM_rotationBudget,
									    const_BalanceSTM_motorBudget,
									    const_AnglePID_P,
									    const_AnglePID_D,
									    const_SpeedPID_P,
									    const_SpeedPID_I,
									    const_SpeedPID_maxIntegral,
									    const_RotationPID_D)
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: CalculateAngle
					module CalculateAngle
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_BalanceSTM_maxAngle,
									    const_BalanceSTM_loopTime,
									    const_BalanceSTM_startupDelay,
									    const_BalanceSTM_speedUpdate,
									    const_BalanceSTM_rotationUpdate,
									    const_BalanceSTM_angleBudget,
									    const_BalanceSTM_speedBudget,
									    const_BalanceSTM_rotationBudget,
									    const_BalanceSTM_motorBudget,
									    const_AnglePID_P,
									    const_AnglePID_D,
									    const_SpeedPID_P,
									    const_SpeedPID_I,
									    const_SpeedPID_maxIntegral,
									    const_RotationPID_D) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= true&CALL__enableInterrupts(
											id__,
										    const_BalanceSTM_maxAngle,
										    const_BalanceSTM_loopTime,
										    const_BalanceSTM_startupDelay,
										    const_BalanceSTM_speedUpdate,
										    const_BalanceSTM_rotationUpdate,
										    const_BalanceSTM_angleBudget,
										    const_BalanceSTM_speedBudget,
										    const_BalanceSTM_rotationBudget,
										    const_BalanceSTM_motorBudget,
											const_AnglePID_P,
											const_AnglePID_D,
											const_SpeedPID_P,
											const_SpeedPID_I,
											const_SpeedPID_maxIntegral,
											const_RotationPID_D
										);Deadline(true&(share__choice(angle.in?currAngle -> (SStop /\ set_currAngle!currAngle -> SKIP))),0);Deadline(true&(share__choice(gyroX.in?currGyroX -> (SStop /\ set_currGyroX!currGyroX -> SKIP))),0);share__choice(get_currGyroX?currGyroX -> share__choice(get_currAngle?currAngle -> true&CALL__AnglePID(
											id__,
										    const_BalanceSTM_maxAngle,
										    const_BalanceSTM_loopTime,
										    const_BalanceSTM_startupDelay,
										    const_BalanceSTM_speedUpdate,
										    const_BalanceSTM_rotationUpdate,
										    const_BalanceSTM_angleBudget,
										    const_BalanceSTM_speedBudget,
										    const_BalanceSTM_rotationBudget,
										    const_BalanceSTM_motorBudget,
											currAngle,
											currGyroX, 
											const_AnglePID_P, 
											const_AnglePID_D,
											const_SpeedPID_P,
											const_SpeedPID_I,
											const_SpeedPID_maxIntegral,
											const_RotationPID_D
										)));SHARE_WAIT_INTERVAL({ x | x <- { 0..const_BalanceSTM_angleBudget}, 0<= x, x <=const_BalanceSTM_angleBudget}) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_BalanceSTM_maxAngle,
									    const_BalanceSTM_loopTime,
									    const_BalanceSTM_startupDelay,
									    const_BalanceSTM_speedUpdate,
									    const_BalanceSTM_rotationUpdate,
									    const_BalanceSTM_angleBudget,
									    const_BalanceSTM_speedBudget,
									    const_BalanceSTM_rotationBudget,
									    const_BalanceSTM_motorBudget,
									    const_AnglePID_P,
									    const_AnglePID_D,
									    const_SpeedPID_P,
									    const_SpeedPID_I,
									    const_SpeedPID_maxIntegral,
									    const_RotationPID_D) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= true&CALL__enableInterrupts(
											id__,
										    const_BalanceSTM_maxAngle,
										    const_BalanceSTM_loopTime,
										    const_BalanceSTM_startupDelay,
										    const_BalanceSTM_speedUpdate,
										    const_BalanceSTM_rotationUpdate,
										    const_BalanceSTM_angleBudget,
										    const_BalanceSTM_speedBudget,
										    const_BalanceSTM_rotationBudget,
										    const_BalanceSTM_motorBudget,
											const_AnglePID_P,
											const_AnglePID_D,
											const_SpeedPID_P,
											const_SpeedPID_I,
											const_SpeedPID_maxIntegral,
											const_RotationPID_D
										);Deadline(true&(share__choice(angle.in?currAngle -> (SStop /\ set_currAngle!currAngle -> SKIP))),0);Deadline(true&(share__choice(gyroX.in?currGyroX -> (SStop /\ set_currGyroX!currGyroX -> SKIP))),0);share__choice(get_currGyroX?currGyroX -> share__choice(get_currAngle?currAngle -> true&CALL__AnglePID(
											id__,
										    const_BalanceSTM_maxAngle,
										    const_BalanceSTM_loopTime,
										    const_BalanceSTM_startupDelay,
										    const_BalanceSTM_speedUpdate,
										    const_BalanceSTM_rotationUpdate,
										    const_BalanceSTM_angleBudget,
										    const_BalanceSTM_speedBudget,
										    const_BalanceSTM_rotationBudget,
										    const_BalanceSTM_motorBudget,
											currAngle,
											currGyroX, 
											const_AnglePID_P, 
											const_AnglePID_D,
											const_SpeedPID_P,
											const_SpeedPID_I,
											const_SpeedPID_maxIntegral,
											const_RotationPID_D
										)));SHARE_WAIT_INTERVAL({ x | x <- { 0..const_BalanceSTM_angleBudget}, 0<= x, x <=const_BalanceSTM_angleBudget}) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_BalanceSTM_maxAngle,
									          const_BalanceSTM_loopTime,
									          const_BalanceSTM_startupDelay,
									          const_BalanceSTM_speedUpdate,
									          const_BalanceSTM_rotationUpdate,
									          const_BalanceSTM_angleBudget,
									          const_BalanceSTM_speedBudget,
									          const_BalanceSTM_rotationBudget,
									          const_BalanceSTM_motorBudget,
									          const_AnglePID_P,
									          const_AnglePID_D,
									          const_SpeedPID_P,
									          const_SpeedPID_I,
									          const_SpeedPID_maxIntegral,
									          const_RotationPID_D) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: CalculateSpeed
					module CalculateSpeed
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_BalanceSTM_maxAngle,
									    const_BalanceSTM_loopTime,
									    const_BalanceSTM_startupDelay,
									    const_BalanceSTM_speedUpdate,
									    const_BalanceSTM_rotationUpdate,
									    const_BalanceSTM_angleBudget,
									    const_BalanceSTM_speedBudget,
									    const_BalanceSTM_rotationBudget,
									    const_BalanceSTM_motorBudget,
									    const_AnglePID_P,
									    const_AnglePID_D,
									    const_SpeedPID_P,
									    const_SpeedPID_I,
									    const_SpeedPID_maxIntegral,
									    const_RotationPID_D) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= Deadline(true&(share__choice(leftMotorVelocity.in?currLeftVel -> (SStop /\ set_currLeftVel!currLeftVel -> SKIP))),0);Deadline(true&(share__choice(rightMotorVelocity.in?currRightVel -> (SStop /\ set_currRightVel!currRightVel -> SKIP))),0);share__choice(get_currRightVel?currRightVel -> share__choice(get_currLeftVel?currLeftVel -> true&CALL__SpeedPID(
											id__,
										    const_BalanceSTM_maxAngle,
										    const_BalanceSTM_loopTime,
										    const_BalanceSTM_startupDelay,
										    const_BalanceSTM_speedUpdate,
										    const_BalanceSTM_rotationUpdate,
										    const_BalanceSTM_angleBudget,
										    const_BalanceSTM_speedBudget,
										    const_BalanceSTM_rotationBudget,
										    const_BalanceSTM_motorBudget,
											Plus(currLeftVel, currRightVel, core_real), 
											const_SpeedPID_P, 
											const_SpeedPID_I, 
											const_SpeedPID_maxIntegral,
											const_AnglePID_P,
											const_AnglePID_D,
											const_RotationPID_D
										)));share__choice(true & (share__choice(set_speedCount!0 -> SKIP)));SHARE_WAIT_INTERVAL({ x | x <- { 0..const_BalanceSTM_speedBudget}, 0<= x, x <=const_BalanceSTM_speedBudget}) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_BalanceSTM_maxAngle,
									    const_BalanceSTM_loopTime,
									    const_BalanceSTM_startupDelay,
									    const_BalanceSTM_speedUpdate,
									    const_BalanceSTM_rotationUpdate,
									    const_BalanceSTM_angleBudget,
									    const_BalanceSTM_speedBudget,
									    const_BalanceSTM_rotationBudget,
									    const_BalanceSTM_motorBudget,
									    const_AnglePID_P,
									    const_AnglePID_D,
									    const_SpeedPID_P,
									    const_SpeedPID_I,
									    const_SpeedPID_maxIntegral,
									    const_RotationPID_D) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= Deadline(true&(share__choice(leftMotorVelocity.in?currLeftVel -> (SStop /\ set_currLeftVel!currLeftVel -> SKIP))),0);Deadline(true&(share__choice(rightMotorVelocity.in?currRightVel -> (SStop /\ set_currRightVel!currRightVel -> SKIP))),0);share__choice(get_currRightVel?currRightVel -> share__choice(get_currLeftVel?currLeftVel -> true&CALL__SpeedPID(
											id__,
										    const_BalanceSTM_maxAngle,
										    const_BalanceSTM_loopTime,
										    const_BalanceSTM_startupDelay,
										    const_BalanceSTM_speedUpdate,
										    const_BalanceSTM_rotationUpdate,
										    const_BalanceSTM_angleBudget,
										    const_BalanceSTM_speedBudget,
										    const_BalanceSTM_rotationBudget,
										    const_BalanceSTM_motorBudget,
											Plus(currLeftVel, currRightVel, core_real), 
											const_SpeedPID_P, 
											const_SpeedPID_I, 
											const_SpeedPID_maxIntegral,
											const_AnglePID_P,
											const_AnglePID_D,
											const_RotationPID_D
										)));share__choice(true & (share__choice(set_speedCount!0 -> SKIP)));SHARE_WAIT_INTERVAL({ x | x <- { 0..const_BalanceSTM_speedBudget}, 0<= x, x <=const_BalanceSTM_speedBudget}) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_BalanceSTM_maxAngle,
									          const_BalanceSTM_loopTime,
									          const_BalanceSTM_startupDelay,
									          const_BalanceSTM_speedUpdate,
									          const_BalanceSTM_rotationUpdate,
									          const_BalanceSTM_angleBudget,
									          const_BalanceSTM_speedBudget,
									          const_BalanceSTM_rotationBudget,
									          const_BalanceSTM_motorBudget,
									          const_AnglePID_P,
									          const_AnglePID_D,
									          const_SpeedPID_P,
									          const_SpeedPID_I,
									          const_SpeedPID_maxIntegral,
									          const_RotationPID_D) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: CalculateRotation
					module CalculateRotation
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_BalanceSTM_maxAngle,
									    const_BalanceSTM_loopTime,
									    const_BalanceSTM_startupDelay,
									    const_BalanceSTM_speedUpdate,
									    const_BalanceSTM_rotationUpdate,
									    const_BalanceSTM_angleBudget,
									    const_BalanceSTM_speedBudget,
									    const_BalanceSTM_rotationBudget,
									    const_BalanceSTM_motorBudget,
									    const_AnglePID_P,
									    const_AnglePID_D,
									    const_SpeedPID_P,
									    const_SpeedPID_I,
									    const_SpeedPID_maxIntegral,
									    const_RotationPID_D) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= Deadline(true&(share__choice(gyroZ.in?currGyroZ -> (SStop /\ set_currGyroZ!currGyroZ -> SKIP))),0);share__choice(get_currGyroZ?currGyroZ -> true&CALL__RotationPID(
											id__,
										    const_BalanceSTM_maxAngle,
										    const_BalanceSTM_loopTime,
										    const_BalanceSTM_startupDelay,
										    const_BalanceSTM_speedUpdate,
										    const_BalanceSTM_rotationUpdate,
										    const_BalanceSTM_angleBudget,
										    const_BalanceSTM_speedBudget,
										    const_BalanceSTM_rotationBudget,
										    const_BalanceSTM_motorBudget,
											currGyroZ, 
											const_RotationPID_D,
											const_AnglePID_P,
											const_AnglePID_D,
											const_SpeedPID_P,
											const_SpeedPID_I,
											const_SpeedPID_maxIntegral
										));share__choice(true & (share__choice(set_rotationCount!0 -> SKIP)));SHARE_WAIT_INTERVAL({ x | x <- { 0..const_BalanceSTM_rotationBudget}, 0<= x, x <=const_BalanceSTM_rotationBudget}) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_BalanceSTM_maxAngle,
									    const_BalanceSTM_loopTime,
									    const_BalanceSTM_startupDelay,
									    const_BalanceSTM_speedUpdate,
									    const_BalanceSTM_rotationUpdate,
									    const_BalanceSTM_angleBudget,
									    const_BalanceSTM_speedBudget,
									    const_BalanceSTM_rotationBudget,
									    const_BalanceSTM_motorBudget,
									    const_AnglePID_P,
									    const_AnglePID_D,
									    const_SpeedPID_P,
									    const_SpeedPID_I,
									    const_SpeedPID_maxIntegral,
									    const_RotationPID_D) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= Deadline(true&(share__choice(gyroZ.in?currGyroZ -> (SStop /\ set_currGyroZ!currGyroZ -> SKIP))),0);share__choice(get_currGyroZ?currGyroZ -> true&CALL__RotationPID(
											id__,
										    const_BalanceSTM_maxAngle,
										    const_BalanceSTM_loopTime,
										    const_BalanceSTM_startupDelay,
										    const_BalanceSTM_speedUpdate,
										    const_BalanceSTM_rotationUpdate,
										    const_BalanceSTM_angleBudget,
										    const_BalanceSTM_speedBudget,
										    const_BalanceSTM_rotationBudget,
										    const_BalanceSTM_motorBudget,
											currGyroZ, 
											const_RotationPID_D,
											const_AnglePID_P,
											const_AnglePID_D,
											const_SpeedPID_P,
											const_SpeedPID_I,
											const_SpeedPID_maxIntegral
										));share__choice(true & (share__choice(set_rotationCount!0 -> SKIP)));SHARE_WAIT_INTERVAL({ x | x <- { 0..const_BalanceSTM_rotationBudget}, 0<= x, x <=const_BalanceSTM_rotationBudget}) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_BalanceSTM_maxAngle,
									          const_BalanceSTM_loopTime,
									          const_BalanceSTM_startupDelay,
									          const_BalanceSTM_speedUpdate,
									          const_BalanceSTM_rotationUpdate,
									          const_BalanceSTM_angleBudget,
									          const_BalanceSTM_speedBudget,
									          const_BalanceSTM_rotationBudget,
									          const_BalanceSTM_motorBudget,
									          const_AnglePID_P,
									          const_AnglePID_D,
									          const_SpeedPID_P,
									          const_SpeedPID_I,
									          const_SpeedPID_maxIntegral,
									          const_RotationPID_D) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: SetMotors
					module SetMotors
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_BalanceSTM_maxAngle,
									    const_BalanceSTM_loopTime,
									    const_BalanceSTM_startupDelay,
									    const_BalanceSTM_speedUpdate,
									    const_BalanceSTM_rotationUpdate,
									    const_BalanceSTM_angleBudget,
									    const_BalanceSTM_speedBudget,
									    const_BalanceSTM_rotationBudget,
									    const_BalanceSTM_motorBudget,
									    const_AnglePID_P,
									    const_AnglePID_D,
									    const_SpeedPID_P,
									    const_SpeedPID_I,
									    const_SpeedPID_maxIntegral,
									    const_RotationPID_D) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(get_speedOutput?speedOutput -> share__choice(get_rotationOutput?rotationOutput -> share__choice(get_angleOutput?angleOutput -> true&CALL__setLeftMotorSpeed(
											id__,
										    const_BalanceSTM_maxAngle,
										    const_BalanceSTM_loopTime,
										    const_BalanceSTM_startupDelay,
										    const_BalanceSTM_speedUpdate,
										    const_BalanceSTM_rotationUpdate,
										    const_BalanceSTM_angleBudget,
										    const_BalanceSTM_speedBudget,
										    const_BalanceSTM_rotationBudget,
										    const_BalanceSTM_motorBudget,
											Minus(Plus(angleOutput, speedOutput, core_real), rotationOutput, core_real),
											const_AnglePID_P,
											const_AnglePID_D,
											const_SpeedPID_P,
											const_SpeedPID_I,
											const_SpeedPID_maxIntegral,
											const_RotationPID_D
										))));share__choice(get_speedOutput?speedOutput -> share__choice(get_rotationOutput?rotationOutput -> share__choice(get_angleOutput?angleOutput -> true&CALL__setRightMotorSpeed(
											id__,
										    const_BalanceSTM_maxAngle,
										    const_BalanceSTM_loopTime,
										    const_BalanceSTM_startupDelay,
										    const_BalanceSTM_speedUpdate,
										    const_BalanceSTM_rotationUpdate,
										    const_BalanceSTM_angleBudget,
										    const_BalanceSTM_speedBudget,
										    const_BalanceSTM_rotationBudget,
										    const_BalanceSTM_motorBudget,
											Plus(Plus(angleOutput, speedOutput, core_real), rotationOutput, core_real),
											const_AnglePID_P,
											const_AnglePID_D,
											const_SpeedPID_P,
											const_SpeedPID_I,
											const_SpeedPID_maxIntegral,
											const_RotationPID_D
										))));SHARE_WAIT_INTERVAL({ x | x <- { 0..const_BalanceSTM_motorBudget}, 0<= x, x <=const_BalanceSTM_motorBudget}) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_BalanceSTM_maxAngle,
									    const_BalanceSTM_loopTime,
									    const_BalanceSTM_startupDelay,
									    const_BalanceSTM_speedUpdate,
									    const_BalanceSTM_rotationUpdate,
									    const_BalanceSTM_angleBudget,
									    const_BalanceSTM_speedBudget,
									    const_BalanceSTM_rotationBudget,
									    const_BalanceSTM_motorBudget,
									    const_AnglePID_P,
									    const_AnglePID_D,
									    const_SpeedPID_P,
									    const_SpeedPID_I,
									    const_SpeedPID_maxIntegral,
									    const_RotationPID_D) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(get_speedOutput?speedOutput -> share__choice(get_rotationOutput?rotationOutput -> share__choice(get_angleOutput?angleOutput -> true&CALL__setLeftMotorSpeed(
											id__,
										    const_BalanceSTM_maxAngle,
										    const_BalanceSTM_loopTime,
										    const_BalanceSTM_startupDelay,
										    const_BalanceSTM_speedUpdate,
										    const_BalanceSTM_rotationUpdate,
										    const_BalanceSTM_angleBudget,
										    const_BalanceSTM_speedBudget,
										    const_BalanceSTM_rotationBudget,
										    const_BalanceSTM_motorBudget,
											Minus(Plus(angleOutput, speedOutput, core_real), rotationOutput, core_real),
											const_AnglePID_P,
											const_AnglePID_D,
											const_SpeedPID_P,
											const_SpeedPID_I,
											const_SpeedPID_maxIntegral,
											const_RotationPID_D
										))));share__choice(get_speedOutput?speedOutput -> share__choice(get_rotationOutput?rotationOutput -> share__choice(get_angleOutput?angleOutput -> true&CALL__setRightMotorSpeed(
											id__,
										    const_BalanceSTM_maxAngle,
										    const_BalanceSTM_loopTime,
										    const_BalanceSTM_startupDelay,
										    const_BalanceSTM_speedUpdate,
										    const_BalanceSTM_rotationUpdate,
										    const_BalanceSTM_angleBudget,
										    const_BalanceSTM_speedBudget,
										    const_BalanceSTM_rotationBudget,
										    const_BalanceSTM_motorBudget,
											Plus(Plus(angleOutput, speedOutput, core_real), rotationOutput, core_real),
											const_AnglePID_P,
											const_AnglePID_D,
											const_SpeedPID_P,
											const_SpeedPID_I,
											const_SpeedPID_maxIntegral,
											const_RotationPID_D
										))));SHARE_WAIT_INTERVAL({ x | x <- { 0..const_BalanceSTM_motorBudget}, 0<= x, x <=const_BalanceSTM_motorBudget}) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_BalanceSTM_maxAngle,
									          const_BalanceSTM_loopTime,
									          const_BalanceSTM_startupDelay,
									          const_BalanceSTM_speedUpdate,
									          const_BalanceSTM_rotationUpdate,
									          const_BalanceSTM_angleBudget,
									          const_BalanceSTM_speedBudget,
									          const_BalanceSTM_rotationBudget,
									          const_BalanceSTM_motorBudget,
									          const_AnglePID_P,
									          const_AnglePID_D,
									          const_SpeedPID_P,
									          const_SpeedPID_I,
									          const_SpeedPID_maxIntegral,
									          const_RotationPID_D) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- Junction: j0
					module j0
					exports
					
						channel enter, interrupt
						
						Timed(OneStep) {
							D__(id__,
									    const_BalanceSTM_maxAngle,
									    const_BalanceSTM_loopTime,
									    const_BalanceSTM_startupDelay,
									    const_BalanceSTM_speedUpdate,
									    const_BalanceSTM_rotationUpdate,
									    const_BalanceSTM_angleBudget,
									    const_BalanceSTM_speedBudget,
									    const_BalanceSTM_rotationBudget,
									    const_BalanceSTM_motorBudget,
									    const_AnglePID_P,
									    const_AnglePID_D,
									    const_SpeedPID_P,
									    const_SpeedPID_I,
									    const_SpeedPID_maxIntegral,
									    const_RotationPID_D) = 
								dbisim(let
									Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
									
									Active 		= share__choice(interrupt -> SKIP) ; Inactive
								within
									Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_BalanceSTM_maxAngle,
									    const_BalanceSTM_loopTime,
									    const_BalanceSTM_startupDelay,
									    const_BalanceSTM_speedUpdate,
									    const_BalanceSTM_rotationUpdate,
									    const_BalanceSTM_angleBudget,
									    const_BalanceSTM_speedBudget,
									    const_BalanceSTM_rotationBudget,
									    const_BalanceSTM_motorBudget,
									    const_AnglePID_P,
									    const_AnglePID_D,
									    const_SpeedPID_P,
									    const_SpeedPID_I,
									    const_SpeedPID_maxIntegral,
									    const_RotationPID_D) = D__(id__,
									    const_BalanceSTM_maxAngle,
									    const_BalanceSTM_loopTime,
									    const_BalanceSTM_startupDelay,
									    const_BalanceSTM_speedUpdate,
									    const_BalanceSTM_rotationUpdate,
									    const_BalanceSTM_angleBudget,
									    const_BalanceSTM_speedBudget,
									    const_BalanceSTM_rotationBudget,
									    const_BalanceSTM_motorBudget,
									    const_AnglePID_P,
									    const_AnglePID_D,
									    const_SpeedPID_P,
									    const_SpeedPID_I,
									    const_SpeedPID_maxIntegral,
									    const_RotationPID_D)
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- Junction: j1
					module j1
					exports
					
						channel enter, interrupt
						
						Timed(OneStep) {
							D__(id__,
									    const_BalanceSTM_maxAngle,
									    const_BalanceSTM_loopTime,
									    const_BalanceSTM_startupDelay,
									    const_BalanceSTM_speedUpdate,
									    const_BalanceSTM_rotationUpdate,
									    const_BalanceSTM_angleBudget,
									    const_BalanceSTM_speedBudget,
									    const_BalanceSTM_rotationBudget,
									    const_BalanceSTM_motorBudget,
									    const_AnglePID_P,
									    const_AnglePID_D,
									    const_SpeedPID_P,
									    const_SpeedPID_I,
									    const_SpeedPID_maxIntegral,
									    const_RotationPID_D) = 
								dbisim(let
									Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
									
									Active 		= share__choice(interrupt -> SKIP) ; Inactive
								within
									Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_BalanceSTM_maxAngle,
									    const_BalanceSTM_loopTime,
									    const_BalanceSTM_startupDelay,
									    const_BalanceSTM_speedUpdate,
									    const_BalanceSTM_rotationUpdate,
									    const_BalanceSTM_angleBudget,
									    const_BalanceSTM_speedBudget,
									    const_BalanceSTM_rotationBudget,
									    const_BalanceSTM_motorBudget,
									    const_AnglePID_P,
									    const_AnglePID_D,
									    const_SpeedPID_P,
									    const_SpeedPID_I,
									    const_SpeedPID_maxIntegral,
									    const_RotationPID_D) = D__(id__,
									    const_BalanceSTM_maxAngle,
									    const_BalanceSTM_loopTime,
									    const_BalanceSTM_startupDelay,
									    const_BalanceSTM_speedUpdate,
									    const_BalanceSTM_rotationUpdate,
									    const_BalanceSTM_angleBudget,
									    const_BalanceSTM_speedBudget,
									    const_BalanceSTM_rotationBudget,
									    const_BalanceSTM_motorBudget,
									    const_AnglePID_P,
									    const_AnglePID_D,
									    const_SpeedPID_P,
									    const_SpeedPID_I,
									    const_SpeedPID_maxIntegral,
									    const_RotationPID_D)
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- Junction: j2
					module j2
					exports
					
						channel enter, interrupt
						
						Timed(OneStep) {
							D__(id__,
									    const_BalanceSTM_maxAngle,
									    const_BalanceSTM_loopTime,
									    const_BalanceSTM_startupDelay,
									    const_BalanceSTM_speedUpdate,
									    const_BalanceSTM_rotationUpdate,
									    const_BalanceSTM_angleBudget,
									    const_BalanceSTM_speedBudget,
									    const_BalanceSTM_rotationBudget,
									    const_BalanceSTM_motorBudget,
									    const_AnglePID_P,
									    const_AnglePID_D,
									    const_SpeedPID_P,
									    const_SpeedPID_I,
									    const_SpeedPID_maxIntegral,
									    const_RotationPID_D) = 
								dbisim(let
									Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
									
									Active 		= share__choice(interrupt -> SKIP) ; Inactive
								within
									Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_BalanceSTM_maxAngle,
									    const_BalanceSTM_loopTime,
									    const_BalanceSTM_startupDelay,
									    const_BalanceSTM_speedUpdate,
									    const_BalanceSTM_rotationUpdate,
									    const_BalanceSTM_angleBudget,
									    const_BalanceSTM_speedBudget,
									    const_BalanceSTM_rotationBudget,
									    const_BalanceSTM_motorBudget,
									    const_AnglePID_P,
									    const_AnglePID_D,
									    const_SpeedPID_P,
									    const_SpeedPID_I,
									    const_SpeedPID_maxIntegral,
									    const_RotationPID_D) = D__(id__,
									    const_BalanceSTM_maxAngle,
									    const_BalanceSTM_loopTime,
									    const_BalanceSTM_startupDelay,
									    const_BalanceSTM_speedUpdate,
									    const_BalanceSTM_rotationUpdate,
									    const_BalanceSTM_angleBudget,
									    const_BalanceSTM_speedBudget,
									    const_BalanceSTM_rotationBudget,
									    const_BalanceSTM_motorBudget,
									    const_AnglePID_P,
									    const_AnglePID_D,
									    const_SpeedPID_P,
									    const_SpeedPID_I,
									    const_SpeedPID_maxIntegral,
									    const_RotationPID_D)
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: StopMotors
					module StopMotors
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_BalanceSTM_maxAngle,
									    const_BalanceSTM_loopTime,
									    const_BalanceSTM_startupDelay,
									    const_BalanceSTM_speedUpdate,
									    const_BalanceSTM_rotationUpdate,
									    const_BalanceSTM_angleBudget,
									    const_BalanceSTM_speedBudget,
									    const_BalanceSTM_rotationBudget,
									    const_BalanceSTM_motorBudget,
									    const_AnglePID_P,
									    const_AnglePID_D,
									    const_SpeedPID_P,
									    const_SpeedPID_I,
									    const_SpeedPID_maxIntegral,
									    const_RotationPID_D) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= true&CALL__setLeftMotorSpeed(
											id__,
										    const_BalanceSTM_maxAngle,
										    const_BalanceSTM_loopTime,
										    const_BalanceSTM_startupDelay,
										    const_BalanceSTM_speedUpdate,
										    const_BalanceSTM_rotationUpdate,
										    const_BalanceSTM_angleBudget,
										    const_BalanceSTM_speedBudget,
										    const_BalanceSTM_rotationBudget,
										    const_BalanceSTM_motorBudget,
											0,
											const_AnglePID_P,
											const_AnglePID_D,
											const_SpeedPID_P,
											const_SpeedPID_I,
											const_SpeedPID_maxIntegral,
											const_RotationPID_D
										);true&CALL__setRightMotorSpeed(
											id__,
										    const_BalanceSTM_maxAngle,
										    const_BalanceSTM_loopTime,
										    const_BalanceSTM_startupDelay,
										    const_BalanceSTM_speedUpdate,
										    const_BalanceSTM_rotationUpdate,
										    const_BalanceSTM_angleBudget,
										    const_BalanceSTM_speedBudget,
										    const_BalanceSTM_rotationBudget,
										    const_BalanceSTM_motorBudget,
											0,
											const_AnglePID_P,
											const_AnglePID_D,
											const_SpeedPID_P,
											const_SpeedPID_I,
											const_SpeedPID_maxIntegral,
											const_RotationPID_D
										);SHARE_WAIT_INTERVAL({ x | x <- { 0..const_BalanceSTM_motorBudget}, 0<= x, x <=const_BalanceSTM_motorBudget}) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_BalanceSTM_maxAngle,
									    const_BalanceSTM_loopTime,
									    const_BalanceSTM_startupDelay,
									    const_BalanceSTM_speedUpdate,
									    const_BalanceSTM_rotationUpdate,
									    const_BalanceSTM_angleBudget,
									    const_BalanceSTM_speedBudget,
									    const_BalanceSTM_rotationBudget,
									    const_BalanceSTM_motorBudget,
									    const_AnglePID_P,
									    const_AnglePID_D,
									    const_SpeedPID_P,
									    const_SpeedPID_I,
									    const_SpeedPID_maxIntegral,
									    const_RotationPID_D) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= true&CALL__setLeftMotorSpeed(
											id__,
										    const_BalanceSTM_maxAngle,
										    const_BalanceSTM_loopTime,
										    const_BalanceSTM_startupDelay,
										    const_BalanceSTM_speedUpdate,
										    const_BalanceSTM_rotationUpdate,
										    const_BalanceSTM_angleBudget,
										    const_BalanceSTM_speedBudget,
										    const_BalanceSTM_rotationBudget,
										    const_BalanceSTM_motorBudget,
											0,
											const_AnglePID_P,
											const_AnglePID_D,
											const_SpeedPID_P,
											const_SpeedPID_I,
											const_SpeedPID_maxIntegral,
											const_RotationPID_D
										);true&CALL__setRightMotorSpeed(
											id__,
										    const_BalanceSTM_maxAngle,
										    const_BalanceSTM_loopTime,
										    const_BalanceSTM_startupDelay,
										    const_BalanceSTM_speedUpdate,
										    const_BalanceSTM_rotationUpdate,
										    const_BalanceSTM_angleBudget,
										    const_BalanceSTM_speedBudget,
										    const_BalanceSTM_rotationBudget,
										    const_BalanceSTM_motorBudget,
											0,
											const_AnglePID_P,
											const_AnglePID_D,
											const_SpeedPID_P,
											const_SpeedPID_I,
											const_SpeedPID_maxIntegral,
											const_RotationPID_D
										);SHARE_WAIT_INTERVAL({ x | x <- { 0..const_BalanceSTM_motorBudget}, 0<= x, x <=const_BalanceSTM_motorBudget}) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_BalanceSTM_maxAngle,
									          const_BalanceSTM_loopTime,
									          const_BalanceSTM_startupDelay,
									          const_BalanceSTM_speedUpdate,
									          const_BalanceSTM_rotationUpdate,
									          const_BalanceSTM_angleBudget,
									          const_BalanceSTM_speedBudget,
									          const_BalanceSTM_rotationBudget,
									          const_BalanceSTM_motorBudget,
									          const_AnglePID_P,
									          const_AnglePID_D,
									          const_SpeedPID_P,
									          const_SpeedPID_I,
									          const_SpeedPID_maxIntegral,
									          const_RotationPID_D) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: WaitForNextIteration
					module WaitForNextIteration
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_BalanceSTM_maxAngle,
									    const_BalanceSTM_loopTime,
									    const_BalanceSTM_startupDelay,
									    const_BalanceSTM_speedUpdate,
									    const_BalanceSTM_rotationUpdate,
									    const_BalanceSTM_angleBudget,
									    const_BalanceSTM_speedBudget,
									    const_BalanceSTM_rotationBudget,
									    const_BalanceSTM_motorBudget,
									    const_AnglePID_P,
									    const_AnglePID_D,
									    const_SpeedPID_P,
									    const_SpeedPID_I,
									    const_SpeedPID_maxIntegral,
									    const_RotationPID_D) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_BalanceSTM_maxAngle,
									    const_BalanceSTM_loopTime,
									    const_BalanceSTM_startupDelay,
									    const_BalanceSTM_speedUpdate,
									    const_BalanceSTM_rotationUpdate,
									    const_BalanceSTM_angleBudget,
									    const_BalanceSTM_speedBudget,
									    const_BalanceSTM_rotationBudget,
									    const_BalanceSTM_motorBudget,
									    const_AnglePID_P,
									    const_AnglePID_D,
									    const_SpeedPID_P,
									    const_SpeedPID_I,
									    const_SpeedPID_maxIntegral,
									    const_RotationPID_D) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_BalanceSTM_maxAngle,
									          const_BalanceSTM_loopTime,
									          const_BalanceSTM_startupDelay,
									          const_BalanceSTM_speedUpdate,
									          const_BalanceSTM_rotationUpdate,
									          const_BalanceSTM_angleBudget,
									          const_BalanceSTM_speedBudget,
									          const_BalanceSTM_rotationBudget,
									          const_BalanceSTM_motorBudget,
									          const_AnglePID_P,
									          const_AnglePID_D,
									          const_SpeedPID_P,
									          const_SpeedPID_I,
									          const_SpeedPID_maxIntegral,
									          const_RotationPID_D) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: Initialisation
					module Initialisation
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_BalanceSTM_maxAngle,
									    const_BalanceSTM_loopTime,
									    const_BalanceSTM_startupDelay,
									    const_BalanceSTM_speedUpdate,
									    const_BalanceSTM_rotationUpdate,
									    const_BalanceSTM_angleBudget,
									    const_BalanceSTM_speedBudget,
									    const_BalanceSTM_rotationBudget,
									    const_BalanceSTM_motorBudget,
									    const_AnglePID_P,
									    const_AnglePID_D,
									    const_SpeedPID_P,
									    const_SpeedPID_I,
									    const_SpeedPID_maxIntegral,
									    const_RotationPID_D) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(true & (share__choice(set_speedCount!0 -> SKIP)));share__choice(true & (share__choice(set_rotationCount!0 -> SKIP)));SHARE_WAIT(const_BalanceSTM_startupDelay);share__choice(clockReset.CLID_loopTimer -> SKIP) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_BalanceSTM_maxAngle,
									    const_BalanceSTM_loopTime,
									    const_BalanceSTM_startupDelay,
									    const_BalanceSTM_speedUpdate,
									    const_BalanceSTM_rotationUpdate,
									    const_BalanceSTM_angleBudget,
									    const_BalanceSTM_speedBudget,
									    const_BalanceSTM_rotationBudget,
									    const_BalanceSTM_motorBudget,
									    const_AnglePID_P,
									    const_AnglePID_D,
									    const_SpeedPID_P,
									    const_SpeedPID_I,
									    const_SpeedPID_maxIntegral,
									    const_RotationPID_D) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(true & (share__choice(set_speedCount!0 -> SKIP)));share__choice(true & (share__choice(set_rotationCount!0 -> SKIP)));SHARE_WAIT(const_BalanceSTM_startupDelay);share__choice(clockReset.CLID_loopTimer -> SKIP) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_BalanceSTM_maxAngle,
									          const_BalanceSTM_loopTime,
									          const_BalanceSTM_startupDelay,
									          const_BalanceSTM_speedUpdate,
									          const_BalanceSTM_rotationUpdate,
									          const_BalanceSTM_angleBudget,
									          const_BalanceSTM_speedBudget,
									          const_BalanceSTM_rotationBudget,
									          const_BalanceSTM_motorBudget,
									          const_AnglePID_P,
									          const_AnglePID_D,
									          const_SpeedPID_P,
									          const_SpeedPID_I,
									          const_SpeedPID_maxIntegral,
									          const_RotationPID_D) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- Junction: j3
					module j3
					exports
					
						channel enter, interrupt
						
						Timed(OneStep) {
							D__(id__,
									    const_BalanceSTM_maxAngle,
									    const_BalanceSTM_loopTime,
									    const_BalanceSTM_startupDelay,
									    const_BalanceSTM_speedUpdate,
									    const_BalanceSTM_rotationUpdate,
									    const_BalanceSTM_angleBudget,
									    const_BalanceSTM_speedBudget,
									    const_BalanceSTM_rotationBudget,
									    const_BalanceSTM_motorBudget,
									    const_AnglePID_P,
									    const_AnglePID_D,
									    const_SpeedPID_P,
									    const_SpeedPID_I,
									    const_SpeedPID_maxIntegral,
									    const_RotationPID_D) = 
								dbisim(let
									Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
									
									Active 		= share__choice(interrupt -> SKIP) ; Inactive
								within
									Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_BalanceSTM_maxAngle,
									    const_BalanceSTM_loopTime,
									    const_BalanceSTM_startupDelay,
									    const_BalanceSTM_speedUpdate,
									    const_BalanceSTM_rotationUpdate,
									    const_BalanceSTM_angleBudget,
									    const_BalanceSTM_speedBudget,
									    const_BalanceSTM_rotationBudget,
									    const_BalanceSTM_motorBudget,
									    const_AnglePID_P,
									    const_AnglePID_D,
									    const_SpeedPID_P,
									    const_SpeedPID_I,
									    const_SpeedPID_maxIntegral,
									    const_RotationPID_D) = D__(id__,
									    const_BalanceSTM_maxAngle,
									    const_BalanceSTM_loopTime,
									    const_BalanceSTM_startupDelay,
									    const_BalanceSTM_speedUpdate,
									    const_BalanceSTM_rotationUpdate,
									    const_BalanceSTM_angleBudget,
									    const_BalanceSTM_speedBudget,
									    const_BalanceSTM_rotationBudget,
									    const_BalanceSTM_motorBudget,
									    const_AnglePID_P,
									    const_AnglePID_D,
									    const_SpeedPID_P,
									    const_SpeedPID_I,
									    const_SpeedPID_maxIntegral,
									    const_RotationPID_D)
						}
					
					endmodule
					----------------------------------------------------------------------
					
					-- END of Nodes --
					
					Timed(OneStep) {
					-- Operation calls --
					-- Only the undefined operations are declared here.
					-- If the state machine is in isolation, all required operations will be undefined.
					-- If it is in the context of a controller, the required operations not provided by the
					-- controller will be declared here, and the defined operations will be defined in the
					-- context of the Controller module, and therefore within scope of the state machine module.
					CALL__setLeftMotorSpeed(id__,
							    const_BalanceSTM_maxAngle,
							    const_BalanceSTM_loopTime,
							    const_BalanceSTM_startupDelay,
							    const_BalanceSTM_speedUpdate,
							    const_BalanceSTM_rotationUpdate,
							    const_BalanceSTM_angleBudget,
							    const_BalanceSTM_speedBudget,
							    const_BalanceSTM_rotationBudget,
							    const_BalanceSTM_motorBudget,
								param_speed,
							    const_AnglePID_P,
							    const_AnglePID_D,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral,
							    const_RotationPID_D) = EDeadline(setLeftMotorSpeedCall.param_speed,0)
					CALL__enableInterrupts(id__,
							    const_BalanceSTM_maxAngle,
							    const_BalanceSTM_loopTime,
							    const_BalanceSTM_startupDelay,
							    const_BalanceSTM_speedUpdate,
							    const_BalanceSTM_rotationUpdate,
							    const_BalanceSTM_angleBudget,
							    const_BalanceSTM_speedBudget,
							    const_BalanceSTM_rotationBudget,
							    const_BalanceSTM_motorBudget,
							    const_AnglePID_P,
							    const_AnglePID_D,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral,
							    const_RotationPID_D) = EDeadline(enableInterruptsCall,0)
					CALL__setRightMotorSpeed(id__,
							    const_BalanceSTM_maxAngle,
							    const_BalanceSTM_loopTime,
							    const_BalanceSTM_startupDelay,
							    const_BalanceSTM_speedUpdate,
							    const_BalanceSTM_rotationUpdate,
							    const_BalanceSTM_angleBudget,
							    const_BalanceSTM_speedBudget,
							    const_BalanceSTM_rotationBudget,
							    const_BalanceSTM_motorBudget,
								param_speed,
							    const_AnglePID_P,
							    const_AnglePID_D,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral,
							    const_RotationPID_D) = EDeadline(setRightMotorSpeedCall.param_speed,0)
					CALL__disableInterrupts(id__,
							    const_BalanceSTM_maxAngle,
							    const_BalanceSTM_loopTime,
							    const_BalanceSTM_startupDelay,
							    const_BalanceSTM_speedUpdate,
							    const_BalanceSTM_rotationUpdate,
							    const_BalanceSTM_angleBudget,
							    const_BalanceSTM_speedBudget,
							    const_BalanceSTM_rotationBudget,
							    const_BalanceSTM_motorBudget,
							    const_AnglePID_P,
							    const_AnglePID_D,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral,
							    const_RotationPID_D) = EDeadline(disableInterruptsCall,0)
					
					CALL__AnglePID(id__,
							    const_BalanceSTM_maxAngle,
							    const_BalanceSTM_loopTime,
							    const_BalanceSTM_startupDelay,
							    const_BalanceSTM_speedUpdate,
							    const_BalanceSTM_rotationUpdate,
							    const_BalanceSTM_angleBudget,
							    const_BalanceSTM_speedBudget,
							    const_BalanceSTM_rotationBudget,
							    const_BalanceSTM_motorBudget,
								param_newError,
								param_diff,
							    const_AnglePID_P,
							    const_AnglePID_D,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral,
							    const_RotationPID_D) = (OP_AnglePID::O__(id__,
								param_newError,
								param_diff,
							    const_AnglePID_P,
							    const_AnglePID_D))
					[[
						OP_AnglePID::get_angleOutput <- get_angleOutput,
						OP_AnglePID::set_angleOutput <- set_angleOutput
					]]
					CALL__SpeedPID(id__,
							    const_BalanceSTM_maxAngle,
							    const_BalanceSTM_loopTime,
							    const_BalanceSTM_startupDelay,
							    const_BalanceSTM_speedUpdate,
							    const_BalanceSTM_rotationUpdate,
							    const_BalanceSTM_angleBudget,
							    const_BalanceSTM_speedBudget,
							    const_BalanceSTM_rotationBudget,
							    const_BalanceSTM_motorBudget,
								param_newError,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral,
							    const_AnglePID_P,
							    const_AnglePID_D,
							    const_RotationPID_D) = (OP_SpeedPID::O__(id__,
								param_newError,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral))
					[[
						OP_SpeedPID::get_speedIntegral <- get_speedIntegral,
						OP_SpeedPID::set_speedIntegral <- set_speedIntegral,
						OP_SpeedPID::get_speedOutput <- get_speedOutput,
						OP_SpeedPID::set_speedOutput <- set_speedOutput
					]]
					CALL__RotationPID(id__,
							    const_BalanceSTM_maxAngle,
							    const_BalanceSTM_loopTime,
							    const_BalanceSTM_startupDelay,
							    const_BalanceSTM_speedUpdate,
							    const_BalanceSTM_rotationUpdate,
							    const_BalanceSTM_angleBudget,
							    const_BalanceSTM_speedBudget,
							    const_BalanceSTM_rotationBudget,
							    const_BalanceSTM_motorBudget,
								param_diff,
							    const_RotationPID_D,
							    const_AnglePID_P,
							    const_AnglePID_D,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral) = (OP_RotationPID::O__(id__,
								param_diff,
							    const_RotationPID_D))
					[[
						OP_RotationPID::get_rotationOutput <- get_rotationOutput,
						OP_RotationPID::set_rotationOutput <- set_rotationOutput
					]]
					-- END of Operation calls --
				
					-- STM processes
					STM(id__,
							    const_BalanceSTM_maxAngle,
							    const_BalanceSTM_loopTime,
							    const_BalanceSTM_startupDelay,
							    const_BalanceSTM_speedUpdate,
							    const_BalanceSTM_rotationUpdate,
							    const_BalanceSTM_angleBudget,
							    const_BalanceSTM_speedBudget,
							    const_BalanceSTM_rotationBudget,
							    const_BalanceSTM_motorBudget,
							    const_AnglePID_P,
							    const_AnglePID_D,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral,
							    const_RotationPID_D) = prioritise(-- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
					( 
						(
							(
								(IteratedStateful(id__,
										    const_BalanceSTM_maxAngle,
										    const_BalanceSTM_loopTime,
										    const_BalanceSTM_startupDelay,
										    const_BalanceSTM_speedUpdate,
										    const_BalanceSTM_rotationUpdate,
										    const_BalanceSTM_angleBudget,
										    const_BalanceSTM_speedBudget,
										    const_BalanceSTM_rotationBudget,
										    const_BalanceSTM_motorBudget,
										    const_AnglePID_P,
										    const_AnglePID_D,
										    const_SpeedPID_P,
										    const_SpeedPID_I,
										    const_SpeedPID_maxIntegral,
										    const_RotationPID_D) \ {terminate} ; share__choice(terminate -> SKIP))
							 	[[ share__ <- x__ | x__ <- {||} ]]
							)
						[| {share__} |]
						SKIP
						)
						[| union(sharedVarSync,{terminate}) |]
						dbisim(sharedVarMemory(id__,
								    const_BalanceSTM_maxAngle,
								    const_BalanceSTM_loopTime,
								    const_BalanceSTM_startupDelay,
								    const_BalanceSTM_speedUpdate,
								    const_BalanceSTM_rotationUpdate,
								    const_BalanceSTM_angleBudget,
								    const_BalanceSTM_speedBudget,
								    const_BalanceSTM_rotationBudget,
								    const_BalanceSTM_motorBudget,
								    const_AnglePID_P,
								    const_AnglePID_D,
								    const_SpeedPID_P,
								    const_SpeedPID_I,
								    const_SpeedPID_maxIntegral,
								    const_RotationPID_D))
					)\sharedVarHide
					,<{terminate},{tock}>)
					
					STM_VS_O(id__,
							    const_BalanceSTM_maxAngle,
							    const_BalanceSTM_loopTime,
							    const_BalanceSTM_startupDelay,
							    const_BalanceSTM_speedUpdate,
							    const_BalanceSTM_rotationUpdate,
							    const_BalanceSTM_angleBudget,
							    const_BalanceSTM_speedBudget,
							    const_BalanceSTM_rotationBudget,
							    const_BalanceSTM_motorBudget,
							    const_AnglePID_P,
							    const_AnglePID_D,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral,
							    const_RotationPID_D) = prioritise(-- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
					( 
						(
							(
								(IteratedStateful_VS_O(id__,
										    const_BalanceSTM_maxAngle,
										    const_BalanceSTM_loopTime,
										    const_BalanceSTM_startupDelay,
										    const_BalanceSTM_speedUpdate,
										    const_BalanceSTM_rotationUpdate,
										    const_BalanceSTM_angleBudget,
										    const_BalanceSTM_speedBudget,
										    const_BalanceSTM_rotationBudget,
										    const_BalanceSTM_motorBudget,
										    const_AnglePID_P,
										    const_AnglePID_D,
										    const_SpeedPID_P,
										    const_SpeedPID_I,
										    const_SpeedPID_maxIntegral,
										    const_RotationPID_D) \ {terminate} ; share__choice(terminate -> SKIP))
							 	[[ share__ <- x__ | x__ <- {||} ]]
							)
						[| {share__} |]
						SKIP
						)
						[| union(sharedVarSync,{terminate}) |]
						dbisim(sharedVarMemory(id__,
								    const_BalanceSTM_maxAngle,
								    const_BalanceSTM_loopTime,
								    const_BalanceSTM_startupDelay,
								    const_BalanceSTM_speedUpdate,
								    const_BalanceSTM_rotationUpdate,
								    const_BalanceSTM_angleBudget,
								    const_BalanceSTM_speedBudget,
								    const_BalanceSTM_rotationBudget,
								    const_BalanceSTM_motorBudget,
								    const_AnglePID_P,
								    const_AnglePID_D,
								    const_SpeedPID_P,
								    const_SpeedPID_I,
								    const_SpeedPID_maxIntegral,
								    const_RotationPID_D))
					)\sharedVarHide
					,<{terminate},{tock}>)
					
					-- Transitions
					Transitions(id__,
							    const_BalanceSTM_maxAngle,
							    const_BalanceSTM_loopTime,
							    const_BalanceSTM_startupDelay,
							    const_BalanceSTM_speedUpdate,
							    const_BalanceSTM_rotationUpdate,
							    const_BalanceSTM_angleBudget,
							    const_BalanceSTM_speedBudget,
							    const_BalanceSTM_rotationBudget,
							    const_BalanceSTM_motorBudget,
							    const_AnglePID_P,
							    const_AnglePID_D,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral,
							    const_RotationPID_D) = ((let
						Trans = share__choice(get_speedCount?speedCount -> get_rotationCount?rotationCount -> get_CLID_loopTimer?loopTimer:CLID_loopTimer_clock_type(id__,
								          const_BalanceSTM_maxAngle,
								          const_BalanceSTM_loopTime,
								          const_BalanceSTM_startupDelay,
								          const_BalanceSTM_speedUpdate,
								          const_BalanceSTM_rotationUpdate,
								          const_BalanceSTM_angleBudget,
								          const_BalanceSTM_speedBudget,
								          const_BalanceSTM_rotationBudget,
								          const_BalanceSTM_motorBudget,
								          const_AnglePID_P,
								          const_AnglePID_D,
								          const_SpeedPID_P,
								          const_SpeedPID_I,
								          const_SpeedPID_maxIntegral,
								          const_RotationPID_D) -> get_currAngle?currAngle -> TimeOut_1(
							 (share__ -> SKIP
							 [] dbisim(((speedCount>=const_BalanceSTM_speedUpdate))&(internal__!NID_j0 -> SKIP ;  ((SKIP ; CalculateSpeed::enter -> SKIP))))
							 [] dbisim((true)&(internal__!NID_CalculateSpeed -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; j1::enter -> SKIP)))
							 [] dbisim((true)&(internal__!NID_CalculateAngle -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(share__choice(get_speedCount?speedCount -> true & (share__choice(set_speedCount!Plus(speedCount, 1, core_nat) -> SKIP)))) ; j0::enter -> SKIP)))
							 [] dbisim(((speedCount<const_BalanceSTM_speedUpdate))&(internal__!NID_j0 -> SKIP ;  ((SKIP ; j1::enter -> SKIP))))
							 [] dbisim((true)&(internal__!NID_CalculateRotation -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; j2::enter -> SKIP)))
							 [] dbisim((((currAngle<=const_BalanceSTM_maxAngle) and (currAngle>=Neg(const_BalanceSTM_maxAngle, core_real))))&(internal__!NID_j2 -> SKIP ;  ((SKIP ; SetMotors::enter -> SKIP))))
							 [] dbisim((((currAngle>const_BalanceSTM_maxAngle) or (currAngle<Neg(const_BalanceSTM_maxAngle, core_real))))&(internal__!NID_j2 -> SKIP ;  ((SKIP ; StopMotors::enter -> SKIP))))
							 [] dbisim(((loopTimer>=const_BalanceSTM_loopTime))&(internal__!NID_WaitForNextIteration -> SKIP ; (share__choice(clockReset.CLID_loopTimer -> SKIP) ; share__choice(SKIP))
							 ; share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; true&CALL__disableInterrupts(
							 			id__,
							 		    const_BalanceSTM_maxAngle,
							 		    const_BalanceSTM_loopTime,
							 		    const_BalanceSTM_startupDelay,
							 		    const_BalanceSTM_speedUpdate,
							 		    const_BalanceSTM_rotationUpdate,
							 		    const_BalanceSTM_angleBudget,
							 		    const_BalanceSTM_speedBudget,
							 		    const_BalanceSTM_rotationBudget,
							 		    const_BalanceSTM_motorBudget,
							 			const_AnglePID_P,
							 			const_AnglePID_D,
							 			const_SpeedPID_P,
							 			const_SpeedPID_I,
							 			const_SpeedPID_maxIntegral,
							 			const_RotationPID_D
							 		) ; CalculateAngle::enter -> SKIP)))
							 [] dbisim((true)&(internal__!NID_StopMotors -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; WaitForNextIteration::enter -> SKIP)))
							 [] dbisim((true)&(internal__!NID_SetMotors -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; WaitForNextIteration::enter -> SKIP)))
							 [] dbisim((true)&(internal__!NID_i0 -> SKIP ;  ((SKIP ; Initialisation::enter -> SKIP))))
							 [] dbisim((true)&(internal__!NID_Initialisation -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; WaitForNextIteration::enter -> SKIP)))
							 [] dbisim((true)&(internal__!NID_j1 -> SKIP ;  ((share__choice(share__choice(get_rotationCount?rotationCount -> true & (share__choice(set_rotationCount!Plus(rotationCount, 1, core_nat) -> SKIP)))) ; j3::enter -> SKIP))))
							 [] dbisim(((rotationCount>=const_BalanceSTM_rotationUpdate))&(internal__!NID_j3 -> SKIP ;  ((SKIP ; CalculateRotation::enter -> SKIP))))
							 [] dbisim(((rotationCount<const_BalanceSTM_rotationUpdate))&(internal__!NID_j3 -> SKIP ;  ((SKIP ; j2::enter -> SKIP))))
							 []
							 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
							 []
							 terminate -> SKIP
							 )
						,SKIP);Trans
						)
					within
						Trans [|{terminate}|> SKIP
					)
					)
					
					-- Stateful
					-- RULE: Stateful(stm:StateMachineBody) : CSPProcess
					
					-- Named process definitions
					MachineBody(id__,
							    const_BalanceSTM_maxAngle,
							    const_BalanceSTM_loopTime,
							    const_BalanceSTM_startupDelay,
							    const_BalanceSTM_speedUpdate,
							    const_BalanceSTM_rotationUpdate,
							    const_BalanceSTM_angleBudget,
							    const_BalanceSTM_speedBudget,
							    const_BalanceSTM_rotationBudget,
							    const_BalanceSTM_motorBudget,
							    const_AnglePID_P,
							    const_AnglePID_D,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral,
							    const_RotationPID_D) = 
						dbisim((
						let
							finalNodesEntered = {||}
						within
							(dbisim((dbisim((let
								-- IMPLEMENTATION NOTE:
								-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
								-- modules for defining the semantics of each node.
								enterSS = {|
								i0::enter,
								CalculateAngle::enter,
								CalculateSpeed::enter,
								CalculateRotation::enter,
								SetMotors::enter,
								j0::enter,
								j1::enter,
								j2::enter,
								StopMotors::enter,
								WaitForNextIteration::enter,
								Initialisation::enter,
								j3::enter
								|}
								hideSet = union(enterSS,{|exit,exited,internal__|})
							within 
								((let
									-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
									-- because CSPM modules are used for the semantics of Node.
									flowevts = union(enterSS,{|exit,exited,interrupt|})
									transSync = {|internal__.NID_j0,internal__.NID_CalculateSpeed,internal__.NID_CalculateAngle,internal__.NID_j0,internal__.NID_CalculateRotation,internal__.NID_j2,internal__.NID_j2,internal__.NID_WaitForNextIteration,internal__.NID_StopMotors,internal__.NID_SetMotors,internal__.NID_i0,internal__.NID_Initialisation,internal__.NID_j1,internal__.NID_j3,internal__.NID_j3|}
								within
									((
									 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
									   i0::D__(id__,
									   		    const_BalanceSTM_maxAngle,
									   		    const_BalanceSTM_loopTime,
									   		    const_BalanceSTM_startupDelay,
									   		    const_BalanceSTM_speedUpdate,
									   		    const_BalanceSTM_rotationUpdate,
									   		    const_BalanceSTM_angleBudget,
									   		    const_BalanceSTM_speedBudget,
									   		    const_BalanceSTM_rotationBudget,
									   		    const_BalanceSTM_motorBudget,
									   		    const_AnglePID_P,
									   		    const_AnglePID_D,
									   		    const_SpeedPID_P,
									   		    const_SpeedPID_I,
									   		    const_SpeedPID_maxIntegral,
									   		    const_RotationPID_D)
									   [| { share__, terminate } |] (
									   CalculateAngle::D__(id__,
									   		    const_BalanceSTM_maxAngle,
									   		    const_BalanceSTM_loopTime,
									   		    const_BalanceSTM_startupDelay,
									   		    const_BalanceSTM_speedUpdate,
									   		    const_BalanceSTM_rotationUpdate,
									   		    const_BalanceSTM_angleBudget,
									   		    const_BalanceSTM_speedBudget,
									   		    const_BalanceSTM_rotationBudget,
									   		    const_BalanceSTM_motorBudget,
									   		    const_AnglePID_P,
									   		    const_AnglePID_D,
									   		    const_SpeedPID_P,
									   		    const_SpeedPID_I,
									   		    const_SpeedPID_maxIntegral,
									   		    const_RotationPID_D)
									   [| { share__, terminate } |] (
									   CalculateSpeed::D__(id__,
									   		    const_BalanceSTM_maxAngle,
									   		    const_BalanceSTM_loopTime,
									   		    const_BalanceSTM_startupDelay,
									   		    const_BalanceSTM_speedUpdate,
									   		    const_BalanceSTM_rotationUpdate,
									   		    const_BalanceSTM_angleBudget,
									   		    const_BalanceSTM_speedBudget,
									   		    const_BalanceSTM_rotationBudget,
									   		    const_BalanceSTM_motorBudget,
									   		    const_AnglePID_P,
									   		    const_AnglePID_D,
									   		    const_SpeedPID_P,
									   		    const_SpeedPID_I,
									   		    const_SpeedPID_maxIntegral,
									   		    const_RotationPID_D)
									   [| { share__, terminate } |] (
									   CalculateRotation::D__(id__,
									   		    const_BalanceSTM_maxAngle,
									   		    const_BalanceSTM_loopTime,
									   		    const_BalanceSTM_startupDelay,
									   		    const_BalanceSTM_speedUpdate,
									   		    const_BalanceSTM_rotationUpdate,
									   		    const_BalanceSTM_angleBudget,
									   		    const_BalanceSTM_speedBudget,
									   		    const_BalanceSTM_rotationBudget,
									   		    const_BalanceSTM_motorBudget,
									   		    const_AnglePID_P,
									   		    const_AnglePID_D,
									   		    const_SpeedPID_P,
									   		    const_SpeedPID_I,
									   		    const_SpeedPID_maxIntegral,
									   		    const_RotationPID_D)
									   [| { share__, terminate } |] (
									   SetMotors::D__(id__,
									   		    const_BalanceSTM_maxAngle,
									   		    const_BalanceSTM_loopTime,
									   		    const_BalanceSTM_startupDelay,
									   		    const_BalanceSTM_speedUpdate,
									   		    const_BalanceSTM_rotationUpdate,
									   		    const_BalanceSTM_angleBudget,
									   		    const_BalanceSTM_speedBudget,
									   		    const_BalanceSTM_rotationBudget,
									   		    const_BalanceSTM_motorBudget,
									   		    const_AnglePID_P,
									   		    const_AnglePID_D,
									   		    const_SpeedPID_P,
									   		    const_SpeedPID_I,
									   		    const_SpeedPID_maxIntegral,
									   		    const_RotationPID_D)
									   [| { share__, terminate } |] (
									   j0::D__(id__,
									   		    const_BalanceSTM_maxAngle,
									   		    const_BalanceSTM_loopTime,
									   		    const_BalanceSTM_startupDelay,
									   		    const_BalanceSTM_speedUpdate,
									   		    const_BalanceSTM_rotationUpdate,
									   		    const_BalanceSTM_angleBudget,
									   		    const_BalanceSTM_speedBudget,
									   		    const_BalanceSTM_rotationBudget,
									   		    const_BalanceSTM_motorBudget,
									   		    const_AnglePID_P,
									   		    const_AnglePID_D,
									   		    const_SpeedPID_P,
									   		    const_SpeedPID_I,
									   		    const_SpeedPID_maxIntegral,
									   		    const_RotationPID_D)
									   [| { share__, terminate } |] (
									   j1::D__(id__,
									   		    const_BalanceSTM_maxAngle,
									   		    const_BalanceSTM_loopTime,
									   		    const_BalanceSTM_startupDelay,
									   		    const_BalanceSTM_speedUpdate,
									   		    const_BalanceSTM_rotationUpdate,
									   		    const_BalanceSTM_angleBudget,
									   		    const_BalanceSTM_speedBudget,
									   		    const_BalanceSTM_rotationBudget,
									   		    const_BalanceSTM_motorBudget,
									   		    const_AnglePID_P,
									   		    const_AnglePID_D,
									   		    const_SpeedPID_P,
									   		    const_SpeedPID_I,
									   		    const_SpeedPID_maxIntegral,
									   		    const_RotationPID_D)
									   [| { share__, terminate } |] (
									   j2::D__(id__,
									   		    const_BalanceSTM_maxAngle,
									   		    const_BalanceSTM_loopTime,
									   		    const_BalanceSTM_startupDelay,
									   		    const_BalanceSTM_speedUpdate,
									   		    const_BalanceSTM_rotationUpdate,
									   		    const_BalanceSTM_angleBudget,
									   		    const_BalanceSTM_speedBudget,
									   		    const_BalanceSTM_rotationBudget,
									   		    const_BalanceSTM_motorBudget,
									   		    const_AnglePID_P,
									   		    const_AnglePID_D,
									   		    const_SpeedPID_P,
									   		    const_SpeedPID_I,
									   		    const_SpeedPID_maxIntegral,
									   		    const_RotationPID_D)
									   [| { share__, terminate } |] (
									   StopMotors::D__(id__,
									   		    const_BalanceSTM_maxAngle,
									   		    const_BalanceSTM_loopTime,
									   		    const_BalanceSTM_startupDelay,
									   		    const_BalanceSTM_speedUpdate,
									   		    const_BalanceSTM_rotationUpdate,
									   		    const_BalanceSTM_angleBudget,
									   		    const_BalanceSTM_speedBudget,
									   		    const_BalanceSTM_rotationBudget,
									   		    const_BalanceSTM_motorBudget,
									   		    const_AnglePID_P,
									   		    const_AnglePID_D,
									   		    const_SpeedPID_P,
									   		    const_SpeedPID_I,
									   		    const_SpeedPID_maxIntegral,
									   		    const_RotationPID_D)
									   [| { share__, terminate } |] (
									   WaitForNextIteration::D__(id__,
									   		    const_BalanceSTM_maxAngle,
									   		    const_BalanceSTM_loopTime,
									   		    const_BalanceSTM_startupDelay,
									   		    const_BalanceSTM_speedUpdate,
									   		    const_BalanceSTM_rotationUpdate,
									   		    const_BalanceSTM_angleBudget,
									   		    const_BalanceSTM_speedBudget,
									   		    const_BalanceSTM_rotationBudget,
									   		    const_BalanceSTM_motorBudget,
									   		    const_AnglePID_P,
									   		    const_AnglePID_D,
									   		    const_SpeedPID_P,
									   		    const_SpeedPID_I,
									   		    const_SpeedPID_maxIntegral,
									   		    const_RotationPID_D)
									   [| { share__, terminate } |] (
									   Initialisation::D__(id__,
									   		    const_BalanceSTM_maxAngle,
									   		    const_BalanceSTM_loopTime,
									   		    const_BalanceSTM_startupDelay,
									   		    const_BalanceSTM_speedUpdate,
									   		    const_BalanceSTM_rotationUpdate,
									   		    const_BalanceSTM_angleBudget,
									   		    const_BalanceSTM_speedBudget,
									   		    const_BalanceSTM_rotationBudget,
									   		    const_BalanceSTM_motorBudget,
									   		    const_AnglePID_P,
									   		    const_AnglePID_D,
									   		    const_SpeedPID_P,
									   		    const_SpeedPID_I,
									   		    const_SpeedPID_maxIntegral,
									   		    const_RotationPID_D)
									   [| { share__, terminate } |] (
									   j3::D__(id__,
									   		    const_BalanceSTM_maxAngle,
									   		    const_BalanceSTM_loopTime,
									   		    const_BalanceSTM_startupDelay,
									   		    const_BalanceSTM_speedUpdate,
									   		    const_BalanceSTM_rotationUpdate,
									   		    const_BalanceSTM_angleBudget,
									   		    const_BalanceSTM_speedBudget,
									   		    const_BalanceSTM_rotationBudget,
									   		    const_BalanceSTM_motorBudget,
									   		    const_AnglePID_P,
									   		    const_AnglePID_D,
									   		    const_SpeedPID_P,
									   		    const_SpeedPID_I,
									   		    const_SpeedPID_maxIntegral,
									   		    const_RotationPID_D)
									   )
									   )
									   )
									   )
									   )
									   )
									   )
									   )
									   )
									   )
									   )
									 )
									 [[CalculateAngle::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_CalculateAngle|}]]
									 [[CalculateSpeed::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_CalculateSpeed|}]]
									 [[CalculateRotation::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_CalculateRotation|}]]
									 [[SetMotors::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_SetMotors|}]]
									 [[StopMotors::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_StopMotors|}]]
									 [[WaitForNextIteration::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_WaitForNextIteration|}]]
									 [[Initialisation::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_Initialisation|}]]
									 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
									 [[j0::interrupt <- x__ | x__ <- {|internal__.NID_j0,internal__.NID_j0|}]]
									 [[j1::interrupt <- x__ | x__ <- {|internal__.NID_j1|}]]
									 [[j2::interrupt <- x__ | x__ <- {|internal__.NID_j2,internal__.NID_j2|}]]
									 [[j3::interrupt <- x__ | x__ <- {|internal__.NID_j3,internal__.NID_j3|}]]
									 )
									  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
									  [[set_speedCount <- setL_speedCount,set_rotationCount <- setL_rotationCount,clockReset.CLID_loopTimer <- clockResetL.CLID_loopTimer,set_currAngle <- setL_currAngle]]
									 )
									 [| union(union(union(flowevts,transSync),{terminate}),{|share__
									 			,setL_speedCount
									 			,setL_rotationCount
									 			,clockResetL.CLID_loopTimer
									 			,setL_currAngle
									|}) |]
									 ((i0::enter -> Transitions(id__,
									 		    const_BalanceSTM_maxAngle,
									 		    const_BalanceSTM_loopTime,
									 		    const_BalanceSTM_startupDelay,
									 		    const_BalanceSTM_speedUpdate,
									 		    const_BalanceSTM_rotationUpdate,
									 		    const_BalanceSTM_angleBudget,
									 		    const_BalanceSTM_speedBudget,
									 		    const_BalanceSTM_rotationBudget,
									 		    const_BalanceSTM_motorBudget,
									 		    const_AnglePID_P,
									 		    const_AnglePID_D,
									 		    const_SpeedPID_P,
									 		    const_SpeedPID_I,
									 		    const_SpeedPID_maxIntegral,
									 		    const_RotationPID_D))
									  [[ share__ <- x__ | x__ <- {| share__,setL_speedCount,setL_rotationCount,clockResetL.CLID_loopTimer,setL_currAngle |} ]]
									 )
									)[[setL_speedCount <- set_speedCount,setL_rotationCount <- set_rotationCount,clockResetL.CLID_loopTimer <- clockReset.CLID_loopTimer,setL_currAngle <- set_currAngle]]
									)
								)
								 \ hideSet)
								[[
									leftMotorVelocity__.x____ <- leftMotorVelocity,
									rightMotorVelocity__.x____ <- rightMotorVelocity,
									angle__.x____ <- angle,
									gyroX__.x____ <- gyroX,
									gyroY__.x____ <- gyroY,
									gyroZ__.x____ <- gyroZ
									| x____ <- NIDS
								]]
							)
							)
							 [| union(stateClockSync,{terminate}) |]
							 StateClocks(id__,
							 		          const_BalanceSTM_maxAngle,
							 		          const_BalanceSTM_loopTime,
							 		          const_BalanceSTM_startupDelay,
							 		          const_BalanceSTM_speedUpdate,
							 		          const_BalanceSTM_rotationUpdate,
							 		          const_BalanceSTM_angleBudget,
							 		          const_BalanceSTM_speedBudget,
							 		          const_BalanceSTM_rotationBudget,
							 		          const_BalanceSTM_motorBudget,
							 		          const_AnglePID_P,
							 		          const_AnglePID_D,
							 		          const_SpeedPID_P,
							 		          const_SpeedPID_I,
							 		          const_SpeedPID_maxIntegral,
							 		          const_RotationPID_D)
							)\diff(stateClockSync,enteredSS))
							 [| {| interrupt |} |] SKIP)
						)
						)
					
					Behaviour(id__,
							    const_BalanceSTM_maxAngle,
							    const_BalanceSTM_loopTime,
							    const_BalanceSTM_startupDelay,
							    const_BalanceSTM_speedUpdate,
							    const_BalanceSTM_rotationUpdate,
							    const_BalanceSTM_angleBudget,
							    const_BalanceSTM_speedBudget,
							    const_BalanceSTM_rotationBudget,
							    const_BalanceSTM_motorBudget,
							    const_AnglePID_P,
							    const_AnglePID_D,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral,
							    const_RotationPID_D) = 
						dbisim((let
							stateClockSync = {|get_CLID_CalculateAngle,CalculateAngle::entered,get_CLID_CalculateSpeed,CalculateSpeed::entered,get_CLID_SetMotors,SetMotors::entered,get_CLID_CalculateRotation,CalculateRotation::entered,get_CLID_WaitForNextIteration,WaitForNextIteration::entered,get_CLID_Initialisation,Initialisation::entered,get_CLID_StopMotors,StopMotors::entered|}
						 within
							(MachineBody(id__,
									    const_BalanceSTM_maxAngle,
									    const_BalanceSTM_loopTime,
									    const_BalanceSTM_startupDelay,
									    const_BalanceSTM_speedUpdate,
									    const_BalanceSTM_rotationUpdate,
									    const_BalanceSTM_angleBudget,
									    const_BalanceSTM_speedBudget,
									    const_BalanceSTM_rotationBudget,
									    const_BalanceSTM_motorBudget,
									    const_AnglePID_P,
									    const_AnglePID_D,
									    const_SpeedPID_P,
									    const_SpeedPID_I,
									    const_SpeedPID_maxIntegral,
									    const_RotationPID_D) [| union(stateClockSync,{terminate}) |] StateClocks(id__,
									          const_BalanceSTM_maxAngle,
									          const_BalanceSTM_loopTime,
									          const_BalanceSTM_startupDelay,
									          const_BalanceSTM_speedUpdate,
									          const_BalanceSTM_rotationUpdate,
									          const_BalanceSTM_angleBudget,
									          const_BalanceSTM_speedBudget,
									          const_BalanceSTM_rotationBudget,
									          const_BalanceSTM_motorBudget,
									          const_AnglePID_P,
									          const_AnglePID_D,
									          const_SpeedPID_P,
									          const_SpeedPID_I,
									          const_SpeedPID_maxIntegral,
									          const_RotationPID_D)) \ union(stateClockSync,enteredSS)
						)
						)
					
					IteratedBehaviour(id__,
							    const_BalanceSTM_maxAngle,
							    const_BalanceSTM_loopTime,
							    const_BalanceSTM_startupDelay,
							    const_BalanceSTM_speedUpdate,
							    const_BalanceSTM_rotationUpdate,
							    const_BalanceSTM_angleBudget,
							    const_BalanceSTM_speedBudget,
							    const_BalanceSTM_rotationBudget,
							    const_BalanceSTM_motorBudget,
							    const_AnglePID_P,
							    const_AnglePID_D,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral,
							    const_RotationPID_D) = 
						dbisim((let
							stateClockSync = {|get_CLID_CalculateAngle,CalculateAngle::entered,get_CLID_CalculateSpeed,CalculateSpeed::entered,get_CLID_SetMotors,SetMotors::entered,get_CLID_CalculateRotation,CalculateRotation::entered,get_CLID_WaitForNextIteration,WaitForNextIteration::entered,get_CLID_Initialisation,Initialisation::entered,get_CLID_StopMotors,StopMotors::entered|}
						 within
							(dbisim(
								sbisim(
									dbisim(
										sbisim(
											dbisim(
												sbisim(
													dbisim(
														sbisim(
															dbisim(
																sbisim(
																	dbisim(
																		sbisim(
																			dbisim(
																				sbisim(
																					MachineBody(id__,
																							    const_BalanceSTM_maxAngle,
																							    const_BalanceSTM_loopTime,
																							    const_BalanceSTM_startupDelay,
																							    const_BalanceSTM_speedUpdate,
																							    const_BalanceSTM_rotationUpdate,
																							    const_BalanceSTM_angleBudget,
																							    const_BalanceSTM_speedBudget,
																							    const_BalanceSTM_rotationBudget,
																							    const_BalanceSTM_motorBudget,
																							    const_AnglePID_P,
																							    const_AnglePID_D,
																							    const_SpeedPID_P,
																							    const_SpeedPID_I,
																							    const_SpeedPID_maxIntegral,
																							    const_RotationPID_D)
																					[| {|get_CLID_StopMotors,StopMotors::entered,terminate|} |]
																					dbisim(Clock_CLID_StopMotors(id__,0,
																							          const_BalanceSTM_maxAngle,
																							          const_BalanceSTM_loopTime,
																							          const_BalanceSTM_startupDelay,
																							          const_BalanceSTM_speedUpdate,
																							          const_BalanceSTM_rotationUpdate,
																							          const_BalanceSTM_angleBudget,
																							          const_BalanceSTM_speedBudget,
																							          const_BalanceSTM_rotationBudget,
																							          const_BalanceSTM_motorBudget,
																							          const_AnglePID_P,
																							          const_AnglePID_D,
																							          const_SpeedPID_P,
																							          const_SpeedPID_I,
																							          const_SpeedPID_maxIntegral,
																							          const_RotationPID_D))
																				)\{|get_CLID_StopMotors|}
																			)
																			[| {|get_CLID_Initialisation,Initialisation::entered,terminate|} |]
																			dbisim(Clock_CLID_Initialisation(id__,0,
																					          const_BalanceSTM_maxAngle,
																					          const_BalanceSTM_loopTime,
																					          const_BalanceSTM_startupDelay,
																					          const_BalanceSTM_speedUpdate,
																					          const_BalanceSTM_rotationUpdate,
																					          const_BalanceSTM_angleBudget,
																					          const_BalanceSTM_speedBudget,
																					          const_BalanceSTM_rotationBudget,
																					          const_BalanceSTM_motorBudget,
																					          const_AnglePID_P,
																					          const_AnglePID_D,
																					          const_SpeedPID_P,
																					          const_SpeedPID_I,
																					          const_SpeedPID_maxIntegral,
																					          const_RotationPID_D))
																		)\{|get_CLID_Initialisation|}
																	)
																	[| {|get_CLID_WaitForNextIteration,WaitForNextIteration::entered,terminate|} |]
																	dbisim(Clock_CLID_WaitForNextIteration(id__,0,
																			          const_BalanceSTM_maxAngle,
																			          const_BalanceSTM_loopTime,
																			          const_BalanceSTM_startupDelay,
																			          const_BalanceSTM_speedUpdate,
																			          const_BalanceSTM_rotationUpdate,
																			          const_BalanceSTM_angleBudget,
																			          const_BalanceSTM_speedBudget,
																			          const_BalanceSTM_rotationBudget,
																			          const_BalanceSTM_motorBudget,
																			          const_AnglePID_P,
																			          const_AnglePID_D,
																			          const_SpeedPID_P,
																			          const_SpeedPID_I,
																			          const_SpeedPID_maxIntegral,
																			          const_RotationPID_D))
																)\{|get_CLID_WaitForNextIteration|}
															)
															[| {|get_CLID_CalculateRotation,CalculateRotation::entered,terminate|} |]
															dbisim(Clock_CLID_CalculateRotation(id__,0,
																	          const_BalanceSTM_maxAngle,
																	          const_BalanceSTM_loopTime,
																	          const_BalanceSTM_startupDelay,
																	          const_BalanceSTM_speedUpdate,
																	          const_BalanceSTM_rotationUpdate,
																	          const_BalanceSTM_angleBudget,
																	          const_BalanceSTM_speedBudget,
																	          const_BalanceSTM_rotationBudget,
																	          const_BalanceSTM_motorBudget,
																	          const_AnglePID_P,
																	          const_AnglePID_D,
																	          const_SpeedPID_P,
																	          const_SpeedPID_I,
																	          const_SpeedPID_maxIntegral,
																	          const_RotationPID_D))
														)\{|get_CLID_CalculateRotation|}
													)
													[| {|get_CLID_SetMotors,SetMotors::entered,terminate|} |]
													dbisim(Clock_CLID_SetMotors(id__,0,
															          const_BalanceSTM_maxAngle,
															          const_BalanceSTM_loopTime,
															          const_BalanceSTM_startupDelay,
															          const_BalanceSTM_speedUpdate,
															          const_BalanceSTM_rotationUpdate,
															          const_BalanceSTM_angleBudget,
															          const_BalanceSTM_speedBudget,
															          const_BalanceSTM_rotationBudget,
															          const_BalanceSTM_motorBudget,
															          const_AnglePID_P,
															          const_AnglePID_D,
															          const_SpeedPID_P,
															          const_SpeedPID_I,
															          const_SpeedPID_maxIntegral,
															          const_RotationPID_D))
												)\{|get_CLID_SetMotors|}
											)
											[| {|get_CLID_CalculateSpeed,CalculateSpeed::entered,terminate|} |]
											dbisim(Clock_CLID_CalculateSpeed(id__,0,
													          const_BalanceSTM_maxAngle,
													          const_BalanceSTM_loopTime,
													          const_BalanceSTM_startupDelay,
													          const_BalanceSTM_speedUpdate,
													          const_BalanceSTM_rotationUpdate,
													          const_BalanceSTM_angleBudget,
													          const_BalanceSTM_speedBudget,
													          const_BalanceSTM_rotationBudget,
													          const_BalanceSTM_motorBudget,
													          const_AnglePID_P,
													          const_AnglePID_D,
													          const_SpeedPID_P,
													          const_SpeedPID_I,
													          const_SpeedPID_maxIntegral,
													          const_RotationPID_D))
										)\{|get_CLID_CalculateSpeed|}
									)
									[| {|get_CLID_CalculateAngle,CalculateAngle::entered,terminate|} |]
									dbisim(Clock_CLID_CalculateAngle(id__,0,
											          const_BalanceSTM_maxAngle,
											          const_BalanceSTM_loopTime,
											          const_BalanceSTM_startupDelay,
											          const_BalanceSTM_speedUpdate,
											          const_BalanceSTM_rotationUpdate,
											          const_BalanceSTM_angleBudget,
											          const_BalanceSTM_speedBudget,
											          const_BalanceSTM_rotationBudget,
											          const_BalanceSTM_motorBudget,
											          const_AnglePID_P,
											          const_AnglePID_D,
											          const_SpeedPID_P,
											          const_SpeedPID_I,
											          const_SpeedPID_maxIntegral,
											          const_RotationPID_D))
								)\{|get_CLID_CalculateAngle|}
							)
							) \ union(stateClockSync,enteredSS)
						)
						)
					
					Stateful(id__,
							    const_BalanceSTM_maxAngle,
							    const_BalanceSTM_loopTime,
							    const_BalanceSTM_startupDelay,
							    const_BalanceSTM_speedUpdate,
							    const_BalanceSTM_rotationUpdate,
							    const_BalanceSTM_angleBudget,
							    const_BalanceSTM_speedBudget,
							    const_BalanceSTM_rotationBudget,
							    const_BalanceSTM_motorBudget,
							    const_AnglePID_P,
							    const_AnglePID_D,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral,
							    const_RotationPID_D) = 
						((let
							getsetLocalChannels = {|get_currAngle,set_currAngle,
							get_currGyroX,set_currGyroX,
							get_currGyroY,set_currGyroY,
							get_currGyroZ,set_currGyroZ,
							get_currLeftVel,set_currLeftVel,
							get_currRightVel,set_currRightVel,
							get_speedCount,set_speedCount,
							get_rotationCount,set_rotationCount,
							get_angleOutput,set_angleOutput,
							get_speedIntegral,set_speedIntegral,
							get_speedOutput,set_speedOutput,
							get_rotationOutput,set_rotationOutput|}
							clockSync = {|get_CLID_loopTimer,clockReset.CLID_loopTimer|}
						within
							(Behaviour(id__,
									    const_BalanceSTM_maxAngle,
									    const_BalanceSTM_loopTime,
									    const_BalanceSTM_startupDelay,
									    const_BalanceSTM_speedUpdate,
									    const_BalanceSTM_rotationUpdate,
									    const_BalanceSTM_angleBudget,
									    const_BalanceSTM_speedBudget,
									    const_BalanceSTM_rotationBudget,
									    const_BalanceSTM_motorBudget,
									    const_AnglePID_P,
									    const_AnglePID_D,
									    const_SpeedPID_P,
									    const_SpeedPID_I,
									    const_SpeedPID_maxIntegral,
									    const_RotationPID_D) 
							 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
							 (varMemory(id__,
							 		    const_BalanceSTM_maxAngle,
							 		    const_BalanceSTM_loopTime,
							 		    const_BalanceSTM_startupDelay,
							 		    const_BalanceSTM_speedUpdate,
							 		    const_BalanceSTM_rotationUpdate,
							 		    const_BalanceSTM_angleBudget,
							 		    const_BalanceSTM_speedBudget,
							 		    const_BalanceSTM_rotationBudget,
							 		    const_BalanceSTM_motorBudget,
							 		    const_AnglePID_P,
							 		    const_AnglePID_D,
							 		    const_SpeedPID_P,
							 		    const_SpeedPID_I,
							 		    const_SpeedPID_maxIntegral,
							 		    const_RotationPID_D) [| {terminate} |] Clocks(id__,
							 		          const_BalanceSTM_maxAngle,
							 		          const_BalanceSTM_loopTime,
							 		          const_BalanceSTM_startupDelay,
							 		          const_BalanceSTM_speedUpdate,
							 		          const_BalanceSTM_rotationUpdate,
							 		          const_BalanceSTM_angleBudget,
							 		          const_BalanceSTM_speedBudget,
							 		          const_BalanceSTM_rotationBudget,
							 		          const_BalanceSTM_motorBudget,
							 		          const_AnglePID_P,
							 		          const_AnglePID_D,
							 		          const_SpeedPID_P,
							 		          const_SpeedPID_I,
							 		          const_SpeedPID_maxIntegral,
							 		          const_RotationPID_D))
						 	)\union(getsetLocalChannels,clockSync)
						)
						)
					
					IteratedStateful(id__,
							    const_BalanceSTM_maxAngle,
							    const_BalanceSTM_loopTime,
							    const_BalanceSTM_startupDelay,
							    const_BalanceSTM_speedUpdate,
							    const_BalanceSTM_rotationUpdate,
							    const_BalanceSTM_angleBudget,
							    const_BalanceSTM_speedBudget,
							    const_BalanceSTM_rotationBudget,
							    const_BalanceSTM_motorBudget,
							    const_AnglePID_P,
							    const_AnglePID_D,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral,
							    const_RotationPID_D) =
						(dbisim(
							sbisim(
								dbisim(
									sbisim(
										dbisim(
											sbisim(
												dbisim(
													sbisim(
														dbisim(
															sbisim(
																dbisim(
																	sbisim(
																		dbisim(
																			sbisim(
																				dbisim(
																					sbisim(
																						dbisim(
																							sbisim(
																								dbisim(
																									sbisim(
																										dbisim(
																											sbisim(
																												dbisim(
																													sbisim(
																														dbisim(
																															sbisim(
																																IteratedBehaviour(id__,
																																		    const_BalanceSTM_maxAngle,
																																		    const_BalanceSTM_loopTime,
																																		    const_BalanceSTM_startupDelay,
																																		    const_BalanceSTM_speedUpdate,
																																		    const_BalanceSTM_rotationUpdate,
																																		    const_BalanceSTM_angleBudget,
																																		    const_BalanceSTM_speedBudget,
																																		    const_BalanceSTM_rotationBudget,
																																		    const_BalanceSTM_motorBudget,
																																		    const_AnglePID_P,
																																		    const_AnglePID_D,
																																		    const_SpeedPID_P,
																																		    const_SpeedPID_I,
																																		    const_SpeedPID_maxIntegral,
																																		    const_RotationPID_D)
																																[| {|get_CLID_loopTimer,clockReset.CLID_loopTimer,terminate|} |]
																																dbisim(Clock_CLID_loopTimer(id__,0,
																																		          const_BalanceSTM_maxAngle,
																																		          const_BalanceSTM_loopTime,
																																		          const_BalanceSTM_startupDelay,
																																		          const_BalanceSTM_speedUpdate,
																																		          const_BalanceSTM_rotationUpdate,
																																		          const_BalanceSTM_angleBudget,
																																		          const_BalanceSTM_speedBudget,
																																		          const_BalanceSTM_rotationBudget,
																																		          const_BalanceSTM_motorBudget,
																																		          const_AnglePID_P,
																																		          const_AnglePID_D,
																																		          const_SpeedPID_P,
																																		          const_SpeedPID_I,
																																		          const_SpeedPID_maxIntegral,
																																		          const_RotationPID_D))
																															)\{|get_CLID_loopTimer,clockReset.CLID_loopTimer|}
																														)
																														[| {|get_rotationOutput,set_rotationOutput,terminate|} |]
																														Memory_rotationOutput(0)
																													)\{|get_rotationOutput,set_rotationOutput|}
																												)
																												[| {|get_speedOutput,set_speedOutput,terminate|} |]
																												Memory_speedOutput(0)
																											)\{|get_speedOutput,set_speedOutput|}
																										)
																										[| {|get_speedIntegral,set_speedIntegral,terminate|} |]
																										Memory_speedIntegral(0)
																									)\{|get_speedIntegral,set_speedIntegral|}
																								)
																								[| {|get_angleOutput,set_angleOutput,terminate|} |]
																								Memory_angleOutput(0)
																							)\{|get_angleOutput,set_angleOutput|}
																						)
																						[| {|get_rotationCount,set_rotationCount,terminate|} |]
																						Memory_rotationCount(0)
																					)\{|get_rotationCount,set_rotationCount|}
																				)
																				[| {|get_speedCount,set_speedCount,terminate|} |]
																				Memory_speedCount(0)
																			)\{|get_speedCount,set_speedCount|}
																		)
																		[| {|get_currRightVel,set_currRightVel,terminate|} |]
																		Memory_currRightVel(0)
																	)\{|get_currRightVel,set_currRightVel|}
																)
																[| {|get_currLeftVel,set_currLeftVel,terminate|} |]
																Memory_currLeftVel(0)
															)\{|get_currLeftVel,set_currLeftVel|}
														)
														[| {|get_currGyroZ,set_currGyroZ,terminate|} |]
														Memory_currGyroZ(0)
													)\{|get_currGyroZ,set_currGyroZ|}
												)
												[| {|get_currGyroY,set_currGyroY,terminate|} |]
												Memory_currGyroY(0)
											)\{|get_currGyroY,set_currGyroY|}
										)
										[| {|get_currGyroX,set_currGyroX,terminate|} |]
										Memory_currGyroX(0)
									)\{|get_currGyroX,set_currGyroX|}
								)
								[| {|get_currAngle,set_currAngle,terminate|} |]
								Memory_currAngle(0)
							)\{|get_currAngle,set_currAngle|}
						)
						)
					
					-- Visible counterparts
					MachineBody_VS_O(id__,
							    const_BalanceSTM_maxAngle,
							    const_BalanceSTM_loopTime,
							    const_BalanceSTM_startupDelay,
							    const_BalanceSTM_speedUpdate,
							    const_BalanceSTM_rotationUpdate,
							    const_BalanceSTM_angleBudget,
							    const_BalanceSTM_speedBudget,
							    const_BalanceSTM_rotationBudget,
							    const_BalanceSTM_motorBudget,
							    const_AnglePID_P,
							    const_AnglePID_D,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral,
							    const_RotationPID_D) = 
						dbisim((
						let
							finalNodesEntered = {||}
						within
							(dbisim((dbisim((let
								-- IMPLEMENTATION NOTE:
								-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
								-- modules for defining the semantics of each node.
								enterSS = {|
								i0::enter,
								CalculateAngle::enter,
								CalculateSpeed::enter,
								CalculateRotation::enter,
								SetMotors::enter,
								j0::enter,
								j1::enter,
								j2::enter,
								StopMotors::enter,
								WaitForNextIteration::enter,
								Initialisation::enter,
								j3::enter
								|}
								hideSet = union(enterSS,{|exit,exited,internal__|})
							within 
								((let
									-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
									-- because CSPM modules are used for the semantics of Node.
									flowevts = union(enterSS,{|exit,exited,interrupt|})
									transSync = {|internal__.NID_j0,internal__.NID_CalculateSpeed,internal__.NID_CalculateAngle,internal__.NID_j0,internal__.NID_CalculateRotation,internal__.NID_j2,internal__.NID_j2,internal__.NID_WaitForNextIteration,internal__.NID_StopMotors,internal__.NID_SetMotors,internal__.NID_i0,internal__.NID_Initialisation,internal__.NID_j1,internal__.NID_j3,internal__.NID_j3|}
								within
									((
									 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
									   i0::VS_O__(id__,
									   		    const_BalanceSTM_maxAngle,
									   		    const_BalanceSTM_loopTime,
									   		    const_BalanceSTM_startupDelay,
									   		    const_BalanceSTM_speedUpdate,
									   		    const_BalanceSTM_rotationUpdate,
									   		    const_BalanceSTM_angleBudget,
									   		    const_BalanceSTM_speedBudget,
									   		    const_BalanceSTM_rotationBudget,
									   		    const_BalanceSTM_motorBudget,
									   		    const_AnglePID_P,
									   		    const_AnglePID_D,
									   		    const_SpeedPID_P,
									   		    const_SpeedPID_I,
									   		    const_SpeedPID_maxIntegral,
									   		    const_RotationPID_D)
									   [| { share__, terminate } |] (
									   CalculateAngle::VS_O__(id__,
									   		    const_BalanceSTM_maxAngle,
									   		    const_BalanceSTM_loopTime,
									   		    const_BalanceSTM_startupDelay,
									   		    const_BalanceSTM_speedUpdate,
									   		    const_BalanceSTM_rotationUpdate,
									   		    const_BalanceSTM_angleBudget,
									   		    const_BalanceSTM_speedBudget,
									   		    const_BalanceSTM_rotationBudget,
									   		    const_BalanceSTM_motorBudget,
									   		    const_AnglePID_P,
									   		    const_AnglePID_D,
									   		    const_SpeedPID_P,
									   		    const_SpeedPID_I,
									   		    const_SpeedPID_maxIntegral,
									   		    const_RotationPID_D)
									   [| { share__, terminate } |] (
									   CalculateSpeed::VS_O__(id__,
									   		    const_BalanceSTM_maxAngle,
									   		    const_BalanceSTM_loopTime,
									   		    const_BalanceSTM_startupDelay,
									   		    const_BalanceSTM_speedUpdate,
									   		    const_BalanceSTM_rotationUpdate,
									   		    const_BalanceSTM_angleBudget,
									   		    const_BalanceSTM_speedBudget,
									   		    const_BalanceSTM_rotationBudget,
									   		    const_BalanceSTM_motorBudget,
									   		    const_AnglePID_P,
									   		    const_AnglePID_D,
									   		    const_SpeedPID_P,
									   		    const_SpeedPID_I,
									   		    const_SpeedPID_maxIntegral,
									   		    const_RotationPID_D)
									   [| { share__, terminate } |] (
									   CalculateRotation::VS_O__(id__,
									   		    const_BalanceSTM_maxAngle,
									   		    const_BalanceSTM_loopTime,
									   		    const_BalanceSTM_startupDelay,
									   		    const_BalanceSTM_speedUpdate,
									   		    const_BalanceSTM_rotationUpdate,
									   		    const_BalanceSTM_angleBudget,
									   		    const_BalanceSTM_speedBudget,
									   		    const_BalanceSTM_rotationBudget,
									   		    const_BalanceSTM_motorBudget,
									   		    const_AnglePID_P,
									   		    const_AnglePID_D,
									   		    const_SpeedPID_P,
									   		    const_SpeedPID_I,
									   		    const_SpeedPID_maxIntegral,
									   		    const_RotationPID_D)
									   [| { share__, terminate } |] (
									   SetMotors::VS_O__(id__,
									   		    const_BalanceSTM_maxAngle,
									   		    const_BalanceSTM_loopTime,
									   		    const_BalanceSTM_startupDelay,
									   		    const_BalanceSTM_speedUpdate,
									   		    const_BalanceSTM_rotationUpdate,
									   		    const_BalanceSTM_angleBudget,
									   		    const_BalanceSTM_speedBudget,
									   		    const_BalanceSTM_rotationBudget,
									   		    const_BalanceSTM_motorBudget,
									   		    const_AnglePID_P,
									   		    const_AnglePID_D,
									   		    const_SpeedPID_P,
									   		    const_SpeedPID_I,
									   		    const_SpeedPID_maxIntegral,
									   		    const_RotationPID_D)
									   [| { share__, terminate } |] (
									   j0::VS_O__(id__,
									   		    const_BalanceSTM_maxAngle,
									   		    const_BalanceSTM_loopTime,
									   		    const_BalanceSTM_startupDelay,
									   		    const_BalanceSTM_speedUpdate,
									   		    const_BalanceSTM_rotationUpdate,
									   		    const_BalanceSTM_angleBudget,
									   		    const_BalanceSTM_speedBudget,
									   		    const_BalanceSTM_rotationBudget,
									   		    const_BalanceSTM_motorBudget,
									   		    const_AnglePID_P,
									   		    const_AnglePID_D,
									   		    const_SpeedPID_P,
									   		    const_SpeedPID_I,
									   		    const_SpeedPID_maxIntegral,
									   		    const_RotationPID_D)
									   [| { share__, terminate } |] (
									   j1::VS_O__(id__,
									   		    const_BalanceSTM_maxAngle,
									   		    const_BalanceSTM_loopTime,
									   		    const_BalanceSTM_startupDelay,
									   		    const_BalanceSTM_speedUpdate,
									   		    const_BalanceSTM_rotationUpdate,
									   		    const_BalanceSTM_angleBudget,
									   		    const_BalanceSTM_speedBudget,
									   		    const_BalanceSTM_rotationBudget,
									   		    const_BalanceSTM_motorBudget,
									   		    const_AnglePID_P,
									   		    const_AnglePID_D,
									   		    const_SpeedPID_P,
									   		    const_SpeedPID_I,
									   		    const_SpeedPID_maxIntegral,
									   		    const_RotationPID_D)
									   [| { share__, terminate } |] (
									   j2::VS_O__(id__,
									   		    const_BalanceSTM_maxAngle,
									   		    const_BalanceSTM_loopTime,
									   		    const_BalanceSTM_startupDelay,
									   		    const_BalanceSTM_speedUpdate,
									   		    const_BalanceSTM_rotationUpdate,
									   		    const_BalanceSTM_angleBudget,
									   		    const_BalanceSTM_speedBudget,
									   		    const_BalanceSTM_rotationBudget,
									   		    const_BalanceSTM_motorBudget,
									   		    const_AnglePID_P,
									   		    const_AnglePID_D,
									   		    const_SpeedPID_P,
									   		    const_SpeedPID_I,
									   		    const_SpeedPID_maxIntegral,
									   		    const_RotationPID_D)
									   [| { share__, terminate } |] (
									   StopMotors::VS_O__(id__,
									   		    const_BalanceSTM_maxAngle,
									   		    const_BalanceSTM_loopTime,
									   		    const_BalanceSTM_startupDelay,
									   		    const_BalanceSTM_speedUpdate,
									   		    const_BalanceSTM_rotationUpdate,
									   		    const_BalanceSTM_angleBudget,
									   		    const_BalanceSTM_speedBudget,
									   		    const_BalanceSTM_rotationBudget,
									   		    const_BalanceSTM_motorBudget,
									   		    const_AnglePID_P,
									   		    const_AnglePID_D,
									   		    const_SpeedPID_P,
									   		    const_SpeedPID_I,
									   		    const_SpeedPID_maxIntegral,
									   		    const_RotationPID_D)
									   [| { share__, terminate } |] (
									   WaitForNextIteration::VS_O__(id__,
									   		    const_BalanceSTM_maxAngle,
									   		    const_BalanceSTM_loopTime,
									   		    const_BalanceSTM_startupDelay,
									   		    const_BalanceSTM_speedUpdate,
									   		    const_BalanceSTM_rotationUpdate,
									   		    const_BalanceSTM_angleBudget,
									   		    const_BalanceSTM_speedBudget,
									   		    const_BalanceSTM_rotationBudget,
									   		    const_BalanceSTM_motorBudget,
									   		    const_AnglePID_P,
									   		    const_AnglePID_D,
									   		    const_SpeedPID_P,
									   		    const_SpeedPID_I,
									   		    const_SpeedPID_maxIntegral,
									   		    const_RotationPID_D)
									   [| { share__, terminate } |] (
									   Initialisation::VS_O__(id__,
									   		    const_BalanceSTM_maxAngle,
									   		    const_BalanceSTM_loopTime,
									   		    const_BalanceSTM_startupDelay,
									   		    const_BalanceSTM_speedUpdate,
									   		    const_BalanceSTM_rotationUpdate,
									   		    const_BalanceSTM_angleBudget,
									   		    const_BalanceSTM_speedBudget,
									   		    const_BalanceSTM_rotationBudget,
									   		    const_BalanceSTM_motorBudget,
									   		    const_AnglePID_P,
									   		    const_AnglePID_D,
									   		    const_SpeedPID_P,
									   		    const_SpeedPID_I,
									   		    const_SpeedPID_maxIntegral,
									   		    const_RotationPID_D)
									   [| { share__, terminate } |] (
									   j3::VS_O__(id__,
									   		    const_BalanceSTM_maxAngle,
									   		    const_BalanceSTM_loopTime,
									   		    const_BalanceSTM_startupDelay,
									   		    const_BalanceSTM_speedUpdate,
									   		    const_BalanceSTM_rotationUpdate,
									   		    const_BalanceSTM_angleBudget,
									   		    const_BalanceSTM_speedBudget,
									   		    const_BalanceSTM_rotationBudget,
									   		    const_BalanceSTM_motorBudget,
									   		    const_AnglePID_P,
									   		    const_AnglePID_D,
									   		    const_SpeedPID_P,
									   		    const_SpeedPID_I,
									   		    const_SpeedPID_maxIntegral,
									   		    const_RotationPID_D)
									   )
									   )
									   )
									   )
									   )
									   )
									   )
									   )
									   )
									   )
									   )
									 )
									 [[CalculateAngle::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_CalculateAngle|}]]
									 [[CalculateSpeed::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_CalculateSpeed|}]]
									 [[CalculateRotation::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_CalculateRotation|}]]
									 [[SetMotors::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_SetMotors|}]]
									 [[StopMotors::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_StopMotors|}]]
									 [[WaitForNextIteration::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_WaitForNextIteration|}]]
									 [[Initialisation::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_Initialisation|}]]
									 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
									 [[j0::interrupt <- x__ | x__ <- {|internal__.NID_j0,internal__.NID_j0|}]]
									 [[j1::interrupt <- x__ | x__ <- {|internal__.NID_j1|}]]
									 [[j2::interrupt <- x__ | x__ <- {|internal__.NID_j2,internal__.NID_j2|}]]
									 [[j3::interrupt <- x__ | x__ <- {|internal__.NID_j3,internal__.NID_j3|}]]
									 )
									  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
									  [[set_speedCount <- setL_speedCount,set_rotationCount <- setL_rotationCount,clockReset.CLID_loopTimer <- clockResetL.CLID_loopTimer,set_currAngle <- setL_currAngle]]
									 )
									 [| union(union(union(flowevts,transSync),{terminate}),{|share__
									 			,setL_speedCount
									 			,setL_rotationCount
									 			,clockResetL.CLID_loopTimer
									 			,setL_currAngle
									|}) |]
									 ((i0::enter -> Transitions(id__,
									 		    const_BalanceSTM_maxAngle,
									 		    const_BalanceSTM_loopTime,
									 		    const_BalanceSTM_startupDelay,
									 		    const_BalanceSTM_speedUpdate,
									 		    const_BalanceSTM_rotationUpdate,
									 		    const_BalanceSTM_angleBudget,
									 		    const_BalanceSTM_speedBudget,
									 		    const_BalanceSTM_rotationBudget,
									 		    const_BalanceSTM_motorBudget,
									 		    const_AnglePID_P,
									 		    const_AnglePID_D,
									 		    const_SpeedPID_P,
									 		    const_SpeedPID_I,
									 		    const_SpeedPID_maxIntegral,
									 		    const_RotationPID_D))
									  [[ share__ <- x__ | x__ <- {| share__,setL_speedCount,setL_rotationCount,clockResetL.CLID_loopTimer,setL_currAngle |} ]]
									 )
									)[[setL_speedCount <- set_speedCount,setL_rotationCount <- set_rotationCount,clockResetL.CLID_loopTimer <- clockReset.CLID_loopTimer,setL_currAngle <- set_currAngle]]
									)
								)
								 \ hideSet)
								[[
									leftMotorVelocity__.x____ <- leftMotorVelocity,
									rightMotorVelocity__.x____ <- rightMotorVelocity,
									angle__.x____ <- angle,
									gyroX__.x____ <- gyroX,
									gyroY__.x____ <- gyroY,
									gyroZ__.x____ <- gyroZ
									| x____ <- NIDS
								]]
							)
							)
							 [| union(stateClockSync,{terminate}) |]
							 StateClocks(id__,
							 		          const_BalanceSTM_maxAngle,
							 		          const_BalanceSTM_loopTime,
							 		          const_BalanceSTM_startupDelay,
							 		          const_BalanceSTM_speedUpdate,
							 		          const_BalanceSTM_rotationUpdate,
							 		          const_BalanceSTM_angleBudget,
							 		          const_BalanceSTM_speedBudget,
							 		          const_BalanceSTM_rotationBudget,
							 		          const_BalanceSTM_motorBudget,
							 		          const_AnglePID_P,
							 		          const_AnglePID_D,
							 		          const_SpeedPID_P,
							 		          const_SpeedPID_I,
							 		          const_SpeedPID_maxIntegral,
							 		          const_RotationPID_D)
							)\diff(stateClockSync,enteredSS))
							 [| {| interrupt |} |] SKIP)
						)
						)
					
					Behaviour_VS_O(id__,
							    const_BalanceSTM_maxAngle,
							    const_BalanceSTM_loopTime,
							    const_BalanceSTM_startupDelay,
							    const_BalanceSTM_speedUpdate,
							    const_BalanceSTM_rotationUpdate,
							    const_BalanceSTM_angleBudget,
							    const_BalanceSTM_speedBudget,
							    const_BalanceSTM_rotationBudget,
							    const_BalanceSTM_motorBudget,
							    const_AnglePID_P,
							    const_AnglePID_D,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral,
							    const_RotationPID_D) = 
						dbisim((let
							stateClockSync = {|get_CLID_CalculateAngle,CalculateAngle::entered,get_CLID_CalculateSpeed,CalculateSpeed::entered,get_CLID_SetMotors,SetMotors::entered,get_CLID_CalculateRotation,CalculateRotation::entered,get_CLID_WaitForNextIteration,WaitForNextIteration::entered,get_CLID_Initialisation,Initialisation::entered,get_CLID_StopMotors,StopMotors::entered|}
						 within
							(MachineBody_VS_O(id__,
									    const_BalanceSTM_maxAngle,
									    const_BalanceSTM_loopTime,
									    const_BalanceSTM_startupDelay,
									    const_BalanceSTM_speedUpdate,
									    const_BalanceSTM_rotationUpdate,
									    const_BalanceSTM_angleBudget,
									    const_BalanceSTM_speedBudget,
									    const_BalanceSTM_rotationBudget,
									    const_BalanceSTM_motorBudget,
									    const_AnglePID_P,
									    const_AnglePID_D,
									    const_SpeedPID_P,
									    const_SpeedPID_I,
									    const_SpeedPID_maxIntegral,
									    const_RotationPID_D) [| union(stateClockSync,{terminate}) |] StateClocks(id__,
									          const_BalanceSTM_maxAngle,
									          const_BalanceSTM_loopTime,
									          const_BalanceSTM_startupDelay,
									          const_BalanceSTM_speedUpdate,
									          const_BalanceSTM_rotationUpdate,
									          const_BalanceSTM_angleBudget,
									          const_BalanceSTM_speedBudget,
									          const_BalanceSTM_rotationBudget,
									          const_BalanceSTM_motorBudget,
									          const_AnglePID_P,
									          const_AnglePID_D,
									          const_SpeedPID_P,
									          const_SpeedPID_I,
									          const_SpeedPID_maxIntegral,
									          const_RotationPID_D)) \ diff(union(stateClockSync,enteredSS),enteredSS)
						)
						)
					
					IteratedBehaviour_VS_O(id__,
							    const_BalanceSTM_maxAngle,
							    const_BalanceSTM_loopTime,
							    const_BalanceSTM_startupDelay,
							    const_BalanceSTM_speedUpdate,
							    const_BalanceSTM_rotationUpdate,
							    const_BalanceSTM_angleBudget,
							    const_BalanceSTM_speedBudget,
							    const_BalanceSTM_rotationBudget,
							    const_BalanceSTM_motorBudget,
							    const_AnglePID_P,
							    const_AnglePID_D,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral,
							    const_RotationPID_D) = 
						dbisim((let
							stateClockSync = {|get_CLID_CalculateAngle,CalculateAngle::entered,get_CLID_CalculateSpeed,CalculateSpeed::entered,get_CLID_SetMotors,SetMotors::entered,get_CLID_CalculateRotation,CalculateRotation::entered,get_CLID_WaitForNextIteration,WaitForNextIteration::entered,get_CLID_Initialisation,Initialisation::entered,get_CLID_StopMotors,StopMotors::entered|}
						 within
							(dbisim(
								sbisim(
									dbisim(
										sbisim(
											dbisim(
												sbisim(
													dbisim(
														sbisim(
															dbisim(
																sbisim(
																	dbisim(
																		sbisim(
																			dbisim(
																				sbisim(
																					MachineBody_VS_O(id__,
																							    const_BalanceSTM_maxAngle,
																							    const_BalanceSTM_loopTime,
																							    const_BalanceSTM_startupDelay,
																							    const_BalanceSTM_speedUpdate,
																							    const_BalanceSTM_rotationUpdate,
																							    const_BalanceSTM_angleBudget,
																							    const_BalanceSTM_speedBudget,
																							    const_BalanceSTM_rotationBudget,
																							    const_BalanceSTM_motorBudget,
																							    const_AnglePID_P,
																							    const_AnglePID_D,
																							    const_SpeedPID_P,
																							    const_SpeedPID_I,
																							    const_SpeedPID_maxIntegral,
																							    const_RotationPID_D)
																					[| {|get_CLID_StopMotors,StopMotors::entered,terminate|} |]
																					dbisim(Clock_CLID_StopMotors(id__,0,
																							          const_BalanceSTM_maxAngle,
																							          const_BalanceSTM_loopTime,
																							          const_BalanceSTM_startupDelay,
																							          const_BalanceSTM_speedUpdate,
																							          const_BalanceSTM_rotationUpdate,
																							          const_BalanceSTM_angleBudget,
																							          const_BalanceSTM_speedBudget,
																							          const_BalanceSTM_rotationBudget,
																							          const_BalanceSTM_motorBudget,
																							          const_AnglePID_P,
																							          const_AnglePID_D,
																							          const_SpeedPID_P,
																							          const_SpeedPID_I,
																							          const_SpeedPID_maxIntegral,
																							          const_RotationPID_D))
																				)\{|get_CLID_StopMotors|}
																			)
																			[| {|get_CLID_Initialisation,Initialisation::entered,terminate|} |]
																			dbisim(Clock_CLID_Initialisation(id__,0,
																					          const_BalanceSTM_maxAngle,
																					          const_BalanceSTM_loopTime,
																					          const_BalanceSTM_startupDelay,
																					          const_BalanceSTM_speedUpdate,
																					          const_BalanceSTM_rotationUpdate,
																					          const_BalanceSTM_angleBudget,
																					          const_BalanceSTM_speedBudget,
																					          const_BalanceSTM_rotationBudget,
																					          const_BalanceSTM_motorBudget,
																					          const_AnglePID_P,
																					          const_AnglePID_D,
																					          const_SpeedPID_P,
																					          const_SpeedPID_I,
																					          const_SpeedPID_maxIntegral,
																					          const_RotationPID_D))
																		)\{|get_CLID_Initialisation|}
																	)
																	[| {|get_CLID_WaitForNextIteration,WaitForNextIteration::entered,terminate|} |]
																	dbisim(Clock_CLID_WaitForNextIteration(id__,0,
																			          const_BalanceSTM_maxAngle,
																			          const_BalanceSTM_loopTime,
																			          const_BalanceSTM_startupDelay,
																			          const_BalanceSTM_speedUpdate,
																			          const_BalanceSTM_rotationUpdate,
																			          const_BalanceSTM_angleBudget,
																			          const_BalanceSTM_speedBudget,
																			          const_BalanceSTM_rotationBudget,
																			          const_BalanceSTM_motorBudget,
																			          const_AnglePID_P,
																			          const_AnglePID_D,
																			          const_SpeedPID_P,
																			          const_SpeedPID_I,
																			          const_SpeedPID_maxIntegral,
																			          const_RotationPID_D))
																)\{|get_CLID_WaitForNextIteration|}
															)
															[| {|get_CLID_CalculateRotation,CalculateRotation::entered,terminate|} |]
															dbisim(Clock_CLID_CalculateRotation(id__,0,
																	          const_BalanceSTM_maxAngle,
																	          const_BalanceSTM_loopTime,
																	          const_BalanceSTM_startupDelay,
																	          const_BalanceSTM_speedUpdate,
																	          const_BalanceSTM_rotationUpdate,
																	          const_BalanceSTM_angleBudget,
																	          const_BalanceSTM_speedBudget,
																	          const_BalanceSTM_rotationBudget,
																	          const_BalanceSTM_motorBudget,
																	          const_AnglePID_P,
																	          const_AnglePID_D,
																	          const_SpeedPID_P,
																	          const_SpeedPID_I,
																	          const_SpeedPID_maxIntegral,
																	          const_RotationPID_D))
														)\{|get_CLID_CalculateRotation|}
													)
													[| {|get_CLID_SetMotors,SetMotors::entered,terminate|} |]
													dbisim(Clock_CLID_SetMotors(id__,0,
															          const_BalanceSTM_maxAngle,
															          const_BalanceSTM_loopTime,
															          const_BalanceSTM_startupDelay,
															          const_BalanceSTM_speedUpdate,
															          const_BalanceSTM_rotationUpdate,
															          const_BalanceSTM_angleBudget,
															          const_BalanceSTM_speedBudget,
															          const_BalanceSTM_rotationBudget,
															          const_BalanceSTM_motorBudget,
															          const_AnglePID_P,
															          const_AnglePID_D,
															          const_SpeedPID_P,
															          const_SpeedPID_I,
															          const_SpeedPID_maxIntegral,
															          const_RotationPID_D))
												)\{|get_CLID_SetMotors|}
											)
											[| {|get_CLID_CalculateSpeed,CalculateSpeed::entered,terminate|} |]
											dbisim(Clock_CLID_CalculateSpeed(id__,0,
													          const_BalanceSTM_maxAngle,
													          const_BalanceSTM_loopTime,
													          const_BalanceSTM_startupDelay,
													          const_BalanceSTM_speedUpdate,
													          const_BalanceSTM_rotationUpdate,
													          const_BalanceSTM_angleBudget,
													          const_BalanceSTM_speedBudget,
													          const_BalanceSTM_rotationBudget,
													          const_BalanceSTM_motorBudget,
													          const_AnglePID_P,
													          const_AnglePID_D,
													          const_SpeedPID_P,
													          const_SpeedPID_I,
													          const_SpeedPID_maxIntegral,
													          const_RotationPID_D))
										)\{|get_CLID_CalculateSpeed|}
									)
									[| {|get_CLID_CalculateAngle,CalculateAngle::entered,terminate|} |]
									dbisim(Clock_CLID_CalculateAngle(id__,0,
											          const_BalanceSTM_maxAngle,
											          const_BalanceSTM_loopTime,
											          const_BalanceSTM_startupDelay,
											          const_BalanceSTM_speedUpdate,
											          const_BalanceSTM_rotationUpdate,
											          const_BalanceSTM_angleBudget,
											          const_BalanceSTM_speedBudget,
											          const_BalanceSTM_rotationBudget,
											          const_BalanceSTM_motorBudget,
											          const_AnglePID_P,
											          const_AnglePID_D,
											          const_SpeedPID_P,
											          const_SpeedPID_I,
											          const_SpeedPID_maxIntegral,
											          const_RotationPID_D))
								)\{|get_CLID_CalculateAngle|}
							)
							) \ diff(union(stateClockSync,enteredSS),enteredSS)
						)
						)
					
					Stateful_VS_O(id__,
							    const_BalanceSTM_maxAngle,
							    const_BalanceSTM_loopTime,
							    const_BalanceSTM_startupDelay,
							    const_BalanceSTM_speedUpdate,
							    const_BalanceSTM_rotationUpdate,
							    const_BalanceSTM_angleBudget,
							    const_BalanceSTM_speedBudget,
							    const_BalanceSTM_rotationBudget,
							    const_BalanceSTM_motorBudget,
							    const_AnglePID_P,
							    const_AnglePID_D,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral,
							    const_RotationPID_D) = 
						dbisim((let
							getsetLocalChannels = {|get_currAngle,set_currAngle,
							get_currGyroX,set_currGyroX,
							get_currGyroY,set_currGyroY,
							get_currGyroZ,set_currGyroZ,
							get_currLeftVel,set_currLeftVel,
							get_currRightVel,set_currRightVel,
							get_speedCount,set_speedCount,
							get_rotationCount,set_rotationCount,
							get_angleOutput,set_angleOutput,
							get_speedIntegral,set_speedIntegral,
							get_speedOutput,set_speedOutput,
							get_rotationOutput,set_rotationOutput|}
							clockSync = {|get_CLID_loopTimer,clockReset.CLID_loopTimer|}
						within
							(Behaviour_VS_O(id__,
									    const_BalanceSTM_maxAngle,
									    const_BalanceSTM_loopTime,
									    const_BalanceSTM_startupDelay,
									    const_BalanceSTM_speedUpdate,
									    const_BalanceSTM_rotationUpdate,
									    const_BalanceSTM_angleBudget,
									    const_BalanceSTM_speedBudget,
									    const_BalanceSTM_rotationBudget,
									    const_BalanceSTM_motorBudget,
									    const_AnglePID_P,
									    const_AnglePID_D,
									    const_SpeedPID_P,
									    const_SpeedPID_I,
									    const_SpeedPID_maxIntegral,
									    const_RotationPID_D) 
							 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
							 (varMemory(id__,
							 		    const_BalanceSTM_maxAngle,
							 		    const_BalanceSTM_loopTime,
							 		    const_BalanceSTM_startupDelay,
							 		    const_BalanceSTM_speedUpdate,
							 		    const_BalanceSTM_rotationUpdate,
							 		    const_BalanceSTM_angleBudget,
							 		    const_BalanceSTM_speedBudget,
							 		    const_BalanceSTM_rotationBudget,
							 		    const_BalanceSTM_motorBudget,
							 		    const_AnglePID_P,
							 		    const_AnglePID_D,
							 		    const_SpeedPID_P,
							 		    const_SpeedPID_I,
							 		    const_SpeedPID_maxIntegral,
							 		    const_RotationPID_D) [| {terminate} |] Clocks(id__,
							 		          const_BalanceSTM_maxAngle,
							 		          const_BalanceSTM_loopTime,
							 		          const_BalanceSTM_startupDelay,
							 		          const_BalanceSTM_speedUpdate,
							 		          const_BalanceSTM_rotationUpdate,
							 		          const_BalanceSTM_angleBudget,
							 		          const_BalanceSTM_speedBudget,
							 		          const_BalanceSTM_rotationBudget,
							 		          const_BalanceSTM_motorBudget,
							 		          const_AnglePID_P,
							 		          const_AnglePID_D,
							 		          const_SpeedPID_P,
							 		          const_SpeedPID_I,
							 		          const_SpeedPID_maxIntegral,
							 		          const_RotationPID_D))
						 	)\union(getsetLocalChannels,clockSync)
						)
						)
					
					IteratedStateful_VS_O(id__,
							    const_BalanceSTM_maxAngle,
							    const_BalanceSTM_loopTime,
							    const_BalanceSTM_startupDelay,
							    const_BalanceSTM_speedUpdate,
							    const_BalanceSTM_rotationUpdate,
							    const_BalanceSTM_angleBudget,
							    const_BalanceSTM_speedBudget,
							    const_BalanceSTM_rotationBudget,
							    const_BalanceSTM_motorBudget,
							    const_AnglePID_P,
							    const_AnglePID_D,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral,
							    const_RotationPID_D) =
						(dbisim(
							sbisim(
								dbisim(
									sbisim(
										dbisim(
											sbisim(
												dbisim(
													sbisim(
														dbisim(
															sbisim(
																dbisim(
																	sbisim(
																		dbisim(
																			sbisim(
																				dbisim(
																					sbisim(
																						dbisim(
																							sbisim(
																								dbisim(
																									sbisim(
																										dbisim(
																											sbisim(
																												dbisim(
																													sbisim(
																														dbisim(
																															sbisim(
																																IteratedBehaviour_VS_O(id__,
																																		    const_BalanceSTM_maxAngle,
																																		    const_BalanceSTM_loopTime,
																																		    const_BalanceSTM_startupDelay,
																																		    const_BalanceSTM_speedUpdate,
																																		    const_BalanceSTM_rotationUpdate,
																																		    const_BalanceSTM_angleBudget,
																																		    const_BalanceSTM_speedBudget,
																																		    const_BalanceSTM_rotationBudget,
																																		    const_BalanceSTM_motorBudget,
																																		    const_AnglePID_P,
																																		    const_AnglePID_D,
																																		    const_SpeedPID_P,
																																		    const_SpeedPID_I,
																																		    const_SpeedPID_maxIntegral,
																																		    const_RotationPID_D)
																																[| {|get_CLID_loopTimer,clockReset.CLID_loopTimer,terminate|} |]
																																dbisim(Clock_CLID_loopTimer(id__,0,
																																		          const_BalanceSTM_maxAngle,
																																		          const_BalanceSTM_loopTime,
																																		          const_BalanceSTM_startupDelay,
																																		          const_BalanceSTM_speedUpdate,
																																		          const_BalanceSTM_rotationUpdate,
																																		          const_BalanceSTM_angleBudget,
																																		          const_BalanceSTM_speedBudget,
																																		          const_BalanceSTM_rotationBudget,
																																		          const_BalanceSTM_motorBudget,
																																		          const_AnglePID_P,
																																		          const_AnglePID_D,
																																		          const_SpeedPID_P,
																																		          const_SpeedPID_I,
																																		          const_SpeedPID_maxIntegral,
																																		          const_RotationPID_D))
																															)\{|get_CLID_loopTimer,clockReset.CLID_loopTimer|}
																														)
																														[| {|get_rotationOutput,set_rotationOutput,terminate|} |]
																														Memory_rotationOutput(0)
																													)\{|get_rotationOutput,set_rotationOutput|}
																												)
																												[| {|get_speedOutput,set_speedOutput,terminate|} |]
																												Memory_speedOutput(0)
																											)\{|get_speedOutput,set_speedOutput|}
																										)
																										[| {|get_speedIntegral,set_speedIntegral,terminate|} |]
																										Memory_speedIntegral(0)
																									)\{|get_speedIntegral,set_speedIntegral|}
																								)
																								[| {|get_angleOutput,set_angleOutput,terminate|} |]
																								Memory_angleOutput(0)
																							)\{|get_angleOutput,set_angleOutput|}
																						)
																						[| {|get_rotationCount,set_rotationCount,terminate|} |]
																						Memory_rotationCount(0)
																					)\{|get_rotationCount,set_rotationCount|}
																				)
																				[| {|get_speedCount,set_speedCount,terminate|} |]
																				Memory_speedCount(0)
																			)\{|get_speedCount,set_speedCount|}
																		)
																		[| {|get_currRightVel,set_currRightVel,terminate|} |]
																		Memory_currRightVel(0)
																	)\{|get_currRightVel,set_currRightVel|}
																)
																[| {|get_currLeftVel,set_currLeftVel,terminate|} |]
																Memory_currLeftVel(0)
															)\{|get_currLeftVel,set_currLeftVel|}
														)
														[| {|get_currGyroZ,set_currGyroZ,terminate|} |]
														Memory_currGyroZ(0)
													)\{|get_currGyroZ,set_currGyroZ|}
												)
												[| {|get_currGyroY,set_currGyroY,terminate|} |]
												Memory_currGyroY(0)
											)\{|get_currGyroY,set_currGyroY|}
										)
										[| {|get_currGyroX,set_currGyroX,terminate|} |]
										Memory_currGyroX(0)
									)\{|get_currGyroX,set_currGyroX|}
								)
								[| {|get_currAngle,set_currAngle,terminate|} |]
								Memory_currAngle(0)
							)\{|get_currAngle,set_currAngle|}
						)
						)
					
					-- END
					
					-- Memory
					-- Memory variables
					Memory_currAngle(currAngle) =
						get_currAngle!currAngle -> Memory_currAngle(currAngle)
						[]
						set_currAngle?x__ -> Memory_currAngle(x__)
						[]
						terminate -> SKIP
					Memory_currGyroX(currGyroX) =
						get_currGyroX!currGyroX -> Memory_currGyroX(currGyroX)
						[]
						set_currGyroX?x__ -> Memory_currGyroX(x__)
						[]
						terminate -> SKIP
					Memory_currGyroY(currGyroY) =
						get_currGyroY!currGyroY -> Memory_currGyroY(currGyroY)
						[]
						set_currGyroY?x__ -> Memory_currGyroY(x__)
						[]
						terminate -> SKIP
					Memory_currGyroZ(currGyroZ) =
						get_currGyroZ!currGyroZ -> Memory_currGyroZ(currGyroZ)
						[]
						set_currGyroZ?x__ -> Memory_currGyroZ(x__)
						[]
						terminate -> SKIP
					Memory_currLeftVel(currLeftVel) =
						get_currLeftVel!currLeftVel -> Memory_currLeftVel(currLeftVel)
						[]
						set_currLeftVel?x__ -> Memory_currLeftVel(x__)
						[]
						terminate -> SKIP
					Memory_currRightVel(currRightVel) =
						get_currRightVel!currRightVel -> Memory_currRightVel(currRightVel)
						[]
						set_currRightVel?x__ -> Memory_currRightVel(x__)
						[]
						terminate -> SKIP
					Memory_speedCount(speedCount) =
						get_speedCount!speedCount -> Memory_speedCount(speedCount)
						[]
						set_speedCount?x__ -> Memory_speedCount(x__)
						[]
						terminate -> SKIP
					Memory_rotationCount(rotationCount) =
						get_rotationCount!rotationCount -> Memory_rotationCount(rotationCount)
						[]
						set_rotationCount?x__ -> Memory_rotationCount(x__)
						[]
						terminate -> SKIP
					Memory_angleOutput(angleOutput) =
						get_angleOutput!angleOutput -> Memory_angleOutput(angleOutput)
						[]
						set_angleOutput?x__ -> Memory_angleOutput(x__)
						[]
						terminate -> SKIP
					Memory_speedIntegral(speedIntegral) =
						get_speedIntegral!speedIntegral -> Memory_speedIntegral(speedIntegral)
						[]
						set_speedIntegral?x__ -> Memory_speedIntegral(x__)
						[]
						terminate -> SKIP
					Memory_speedOutput(speedOutput) =
						get_speedOutput!speedOutput -> Memory_speedOutput(speedOutput)
						[]
						set_speedOutput?x__ -> Memory_speedOutput(x__)
						[]
						terminate -> SKIP
					Memory_rotationOutput(rotationOutput) =
						get_rotationOutput!rotationOutput -> Memory_rotationOutput(rotationOutput)
						[]
						set_rotationOutput?x__ -> Memory_rotationOutput(x__)
						[]
						terminate -> SKIP
					
					-- varMemory process
					varMemory(id__,
							    const_BalanceSTM_maxAngle,
							    const_BalanceSTM_loopTime,
							    const_BalanceSTM_startupDelay,
							    const_BalanceSTM_speedUpdate,
							    const_BalanceSTM_rotationUpdate,
							    const_BalanceSTM_angleBudget,
							    const_BalanceSTM_speedBudget,
							    const_BalanceSTM_rotationBudget,
							    const_BalanceSTM_motorBudget,
							    const_AnglePID_P,
							    const_AnglePID_D,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral,
							    const_RotationPID_D) = Memory_currAngle(0)
					[| { terminate } |] (
					Memory_currGyroX(0)
					[| { terminate } |] (
					Memory_currGyroY(0)
					[| { terminate } |] (
					Memory_currGyroZ(0)
					[| { terminate } |] (
					Memory_currLeftVel(0)
					[| { terminate } |] (
					Memory_currRightVel(0)
					[| { terminate } |] (
					Memory_speedCount(0)
					[| { terminate } |] (
					Memory_rotationCount(0)
					[| { terminate } |] (
					Memory_angleOutput(0)
					[| { terminate } |] (
					Memory_speedIntegral(0)
					[| { terminate } |] (
					Memory_speedOutput(0)
					[| { terminate } |] (
					Memory_rotationOutput(0)
					)
					)
					)
					)
					)
					)
					)
					)
					)
					)
					)
					
					getsetLocalChannels = {|get_currAngle,set_currAngle,get_currGyroX,set_currGyroX,get_currGyroY,set_currGyroY,get_currGyroZ,set_currGyroZ,get_currLeftVel,set_currLeftVel,get_currRightVel,set_currRightVel,get_speedCount,set_speedCount,get_rotationCount,set_rotationCount,get_angleOutput,set_angleOutput,get_speedIntegral,set_speedIntegral,get_speedOutput,set_speedOutput,get_rotationOutput,set_rotationOutput|}
					
					-- Definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
					FVS__(id__,
							    const_BalanceSTM_maxAngle,
							    const_BalanceSTM_loopTime,
							    const_BalanceSTM_startupDelay,
							    const_BalanceSTM_speedUpdate,
							    const_BalanceSTM_rotationUpdate,
							    const_BalanceSTM_angleBudget,
							    const_BalanceSTM_speedBudget,
							    const_BalanceSTM_rotationBudget,
							    const_BalanceSTM_motorBudget,
							    const_AnglePID_P,
							    const_AnglePID_D,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral,
							    const_RotationPID_D) = STM_VS_O(id__,
							    const_BalanceSTM_maxAngle,
							    const_BalanceSTM_loopTime,
							    const_BalanceSTM_startupDelay,
							    const_BalanceSTM_speedUpdate,
							    const_BalanceSTM_rotationUpdate,
							    const_BalanceSTM_angleBudget,
							    const_BalanceSTM_speedBudget,
							    const_BalanceSTM_rotationBudget,
							    const_BalanceSTM_motorBudget,
							    const_AnglePID_P,
							    const_AnglePID_D,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral,
							    const_RotationPID_D) \ localClockResets
					D__(id__,
							    const_BalanceSTM_maxAngle,
							    const_BalanceSTM_loopTime,
							    const_BalanceSTM_startupDelay,
							    const_BalanceSTM_speedUpdate,
							    const_BalanceSTM_rotationUpdate,
							    const_BalanceSTM_angleBudget,
							    const_BalanceSTM_speedBudget,
							    const_BalanceSTM_rotationBudget,
							    const_BalanceSTM_motorBudget,
							    const_AnglePID_P,
							    const_AnglePID_D,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral,
							    const_RotationPID_D) = timed_priority(STM(id__,
							    const_BalanceSTM_maxAngle,
							    const_BalanceSTM_loopTime,
							    const_BalanceSTM_startupDelay,
							    const_BalanceSTM_speedUpdate,
							    const_BalanceSTM_rotationUpdate,
							    const_BalanceSTM_angleBudget,
							    const_BalanceSTM_speedBudget,
							    const_BalanceSTM_rotationBudget,
							    const_BalanceSTM_motorBudget,
							    const_AnglePID_P,
							    const_AnglePID_D,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral,
							    const_RotationPID_D) \ union(internal_events,localClockResets))
					O__(id__,
							    const_BalanceSTM_maxAngle,
							    const_BalanceSTM_loopTime,
							    const_BalanceSTM_startupDelay,
							    const_BalanceSTM_speedUpdate,
							    const_BalanceSTM_rotationUpdate,
							    const_BalanceSTM_angleBudget,
							    const_BalanceSTM_speedBudget,
							    const_BalanceSTM_rotationBudget,
							    const_BalanceSTM_motorBudget,
							    const_AnglePID_P,
							    const_AnglePID_D,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral,
							    const_RotationPID_D) = dbisim(D__(id__,
							    const_BalanceSTM_maxAngle,
							    const_BalanceSTM_loopTime,
							    const_BalanceSTM_startupDelay,
							    const_BalanceSTM_speedUpdate,
							    const_BalanceSTM_rotationUpdate,
							    const_BalanceSTM_angleBudget,
							    const_BalanceSTM_speedBudget,
							    const_BalanceSTM_rotationBudget,
							    const_BalanceSTM_motorBudget,
							    const_AnglePID_P,
							    const_AnglePID_D,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral,
							    const_RotationPID_D))
					VS__(id__,
							    const_BalanceSTM_maxAngle,
							    const_BalanceSTM_loopTime,
							    const_BalanceSTM_startupDelay,
							    const_BalanceSTM_speedUpdate,
							    const_BalanceSTM_rotationUpdate,
							    const_BalanceSTM_angleBudget,
							    const_BalanceSTM_speedBudget,
							    const_BalanceSTM_rotationBudget,
							    const_BalanceSTM_motorBudget,
							    const_AnglePID_P,
							    const_AnglePID_D,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral,
							    const_RotationPID_D) = FVS__(id__,
							    const_BalanceSTM_maxAngle,
							    const_BalanceSTM_loopTime,
							    const_BalanceSTM_startupDelay,
							    const_BalanceSTM_speedUpdate,
							    const_BalanceSTM_rotationUpdate,
							    const_BalanceSTM_angleBudget,
							    const_BalanceSTM_speedBudget,
							    const_BalanceSTM_rotationBudget,
							    const_BalanceSTM_motorBudget,
							    const_AnglePID_P,
							    const_AnglePID_D,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral,
							    const_RotationPID_D)
					VS_O__(id__,
							    const_BalanceSTM_maxAngle,
							    const_BalanceSTM_loopTime,
							    const_BalanceSTM_startupDelay,
							    const_BalanceSTM_speedUpdate,
							    const_BalanceSTM_rotationUpdate,
							    const_BalanceSTM_angleBudget,
							    const_BalanceSTM_speedBudget,
							    const_BalanceSTM_rotationBudget,
							    const_BalanceSTM_motorBudget,
							    const_AnglePID_P,
							    const_AnglePID_D,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral,
							    const_RotationPID_D) = dbisim(FVS__(id__,
							    const_BalanceSTM_maxAngle,
							    const_BalanceSTM_loopTime,
							    const_BalanceSTM_startupDelay,
							    const_BalanceSTM_speedUpdate,
							    const_BalanceSTM_rotationUpdate,
							    const_BalanceSTM_angleBudget,
							    const_BalanceSTM_speedBudget,
							    const_BalanceSTM_rotationBudget,
							    const_BalanceSTM_motorBudget,
							    const_AnglePID_P,
							    const_AnglePID_D,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral,
							    const_RotationPID_D))
					HEXT__(id__,
							    const_BalanceSTM_maxAngle,
							    const_BalanceSTM_loopTime,
							    const_BalanceSTM_startupDelay,
							    const_BalanceSTM_speedUpdate,
							    const_BalanceSTM_rotationUpdate,
							    const_BalanceSTM_angleBudget,
							    const_BalanceSTM_speedBudget,
							    const_BalanceSTM_rotationBudget,
							    const_BalanceSTM_motorBudget,
							    const_AnglePID_P,
							    const_AnglePID_D,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral,
							    const_RotationPID_D) = O__(id__,
							    const_BalanceSTM_maxAngle,
							    const_BalanceSTM_loopTime,
							    const_BalanceSTM_startupDelay,
							    const_BalanceSTM_speedUpdate,
							    const_BalanceSTM_rotationUpdate,
							    const_BalanceSTM_angleBudget,
							    const_BalanceSTM_speedBudget,
							    const_BalanceSTM_rotationBudget,
							    const_BalanceSTM_motorBudget,
							    const_AnglePID_P,
							    const_AnglePID_D,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral,
							    const_RotationPID_D) [|shared_variable_events|] SKIP
					FVS_C__(id__,
							    const_BalanceSTM_maxAngle,
							    const_BalanceSTM_loopTime,
							    const_BalanceSTM_startupDelay,
							    const_BalanceSTM_speedUpdate,
							    const_BalanceSTM_rotationUpdate,
							    const_BalanceSTM_angleBudget,
							    const_BalanceSTM_speedBudget,
							    const_BalanceSTM_rotationBudget,
							    const_BalanceSTM_motorBudget,
							    const_AnglePID_P,
							    const_AnglePID_D,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral,
							    const_RotationPID_D) = dbisim(timed_priority(STM(id__,
							    const_BalanceSTM_maxAngle,
							    const_BalanceSTM_loopTime,
							    const_BalanceSTM_startupDelay,
							    const_BalanceSTM_speedUpdate,
							    const_BalanceSTM_rotationUpdate,
							    const_BalanceSTM_angleBudget,
							    const_BalanceSTM_speedBudget,
							    const_BalanceSTM_rotationBudget,
							    const_BalanceSTM_motorBudget,
							    const_AnglePID_P,
							    const_AnglePID_D,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral,
							    const_RotationPID_D) \ internal_events))
					HUP__(id__,
							    const_BalanceSTM_maxAngle,
							    const_BalanceSTM_loopTime,
							    const_BalanceSTM_startupDelay,
							    const_BalanceSTM_speedUpdate,
							    const_BalanceSTM_rotationUpdate,
							    const_BalanceSTM_angleBudget,
							    const_BalanceSTM_speedBudget,
							    const_BalanceSTM_rotationBudget,
							    const_BalanceSTM_motorBudget,
							    const_AnglePID_P,
							    const_AnglePID_D,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral,
							    const_RotationPID_D) = timed_priority(O__(id__,
							    const_BalanceSTM_maxAngle,
							    const_BalanceSTM_loopTime,
							    const_BalanceSTM_startupDelay,
							    const_BalanceSTM_speedUpdate,
							    const_BalanceSTM_rotationUpdate,
							    const_BalanceSTM_angleBudget,
							    const_BalanceSTM_speedBudget,
							    const_BalanceSTM_rotationBudget,
							    const_BalanceSTM_motorBudget,
							    const_AnglePID_P,
							    const_AnglePID_D,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral,
							    const_RotationPID_D) [|{share__}|] SKIP)
					
					-- Clocks
					Clock_CLID_loopTimer(id__,x__,
							          const_BalanceSTM_maxAngle,
							          const_BalanceSTM_loopTime,
							          const_BalanceSTM_startupDelay,
							          const_BalanceSTM_speedUpdate,
							          const_BalanceSTM_rotationUpdate,
							          const_BalanceSTM_angleBudget,
							          const_BalanceSTM_speedBudget,
							          const_BalanceSTM_rotationBudget,
							          const_BalanceSTM_motorBudget,
							          const_AnglePID_P,
							          const_AnglePID_D,
							          const_SpeedPID_P,
							          const_SpeedPID_I,
							          const_SpeedPID_maxIntegral,
							          const_RotationPID_D) = 
						TimeOut_1(
							clockReset.CLID_loopTimer -> Clock_CLID_loopTimer(id__,0,
									          const_BalanceSTM_maxAngle,
									          const_BalanceSTM_loopTime,
									          const_BalanceSTM_startupDelay,
									          const_BalanceSTM_speedUpdate,
									          const_BalanceSTM_rotationUpdate,
									          const_BalanceSTM_angleBudget,
									          const_BalanceSTM_speedBudget,
									          const_BalanceSTM_rotationBudget,
									          const_BalanceSTM_motorBudget,
									          const_AnglePID_P,
									          const_AnglePID_D,
									          const_SpeedPID_P,
									          const_SpeedPID_I,
									          const_SpeedPID_maxIntegral,
									          const_RotationPID_D)
							[]
							get_CLID_loopTimer!x__ -> Clock_CLID_loopTimer(id__,x__,
									          const_BalanceSTM_maxAngle,
									          const_BalanceSTM_loopTime,
									          const_BalanceSTM_startupDelay,
									          const_BalanceSTM_speedUpdate,
									          const_BalanceSTM_rotationUpdate,
									          const_BalanceSTM_angleBudget,
									          const_BalanceSTM_speedBudget,
									          const_BalanceSTM_rotationBudget,
									          const_BalanceSTM_motorBudget,
									          const_AnglePID_P,
									          const_AnglePID_D,
									          const_SpeedPID_P,
									          const_SpeedPID_I,
									          const_SpeedPID_maxIntegral,
									          const_RotationPID_D)
							[]
							terminate -> SKIP,Clock_CLID_loopTimer(id__,clock_type_plus(x__,1,CLID_loopTimer_clock_type(id__,
									          const_BalanceSTM_maxAngle,
									          const_BalanceSTM_loopTime,
									          const_BalanceSTM_startupDelay,
									          const_BalanceSTM_speedUpdate,
									          const_BalanceSTM_rotationUpdate,
									          const_BalanceSTM_angleBudget,
									          const_BalanceSTM_speedBudget,
									          const_BalanceSTM_rotationBudget,
									          const_BalanceSTM_motorBudget,
									          const_AnglePID_P,
									          const_AnglePID_D,
									          const_SpeedPID_P,
									          const_SpeedPID_I,
									          const_SpeedPID_maxIntegral,
									          const_RotationPID_D)),
									          const_BalanceSTM_maxAngle,
									          const_BalanceSTM_loopTime,
									          const_BalanceSTM_startupDelay,
									          const_BalanceSTM_speedUpdate,
									          const_BalanceSTM_rotationUpdate,
									          const_BalanceSTM_angleBudget,
									          const_BalanceSTM_speedBudget,
									          const_BalanceSTM_rotationBudget,
									          const_BalanceSTM_motorBudget,
									          const_AnglePID_P,
									          const_AnglePID_D,
									          const_SpeedPID_P,
									          const_SpeedPID_I,
									          const_SpeedPID_maxIntegral,
									          const_RotationPID_D))
					
					Clocks(id__,
							          const_BalanceSTM_maxAngle,
							          const_BalanceSTM_loopTime,
							          const_BalanceSTM_startupDelay,
							          const_BalanceSTM_speedUpdate,
							          const_BalanceSTM_rotationUpdate,
							          const_BalanceSTM_angleBudget,
							          const_BalanceSTM_speedBudget,
							          const_BalanceSTM_rotationBudget,
							          const_BalanceSTM_motorBudget,
							          const_AnglePID_P,
							          const_AnglePID_D,
							          const_SpeedPID_P,
							          const_SpeedPID_I,
							          const_SpeedPID_maxIntegral,
							          const_RotationPID_D) = dbisim(Clock_CLID_loopTimer(id__,0,
							          const_BalanceSTM_maxAngle,
							          const_BalanceSTM_loopTime,
							          const_BalanceSTM_startupDelay,
							          const_BalanceSTM_speedUpdate,
							          const_BalanceSTM_rotationUpdate,
							          const_BalanceSTM_angleBudget,
							          const_BalanceSTM_speedBudget,
							          const_BalanceSTM_rotationBudget,
							          const_BalanceSTM_motorBudget,
							          const_AnglePID_P,
							          const_AnglePID_D,
							          const_SpeedPID_P,
							          const_SpeedPID_I,
							          const_SpeedPID_maxIntegral,
							          const_RotationPID_D))
					
					clockSync = {|get_CLID_loopTimer,clockReset.CLID_loopTimer|}
					
					Clock_CLID_CalculateAngle(id__,x__,
							          const_BalanceSTM_maxAngle,
							          const_BalanceSTM_loopTime,
							          const_BalanceSTM_startupDelay,
							          const_BalanceSTM_speedUpdate,
							          const_BalanceSTM_rotationUpdate,
							          const_BalanceSTM_angleBudget,
							          const_BalanceSTM_speedBudget,
							          const_BalanceSTM_rotationBudget,
							          const_BalanceSTM_motorBudget,
							          const_AnglePID_P,
							          const_AnglePID_D,
							          const_SpeedPID_P,
							          const_SpeedPID_I,
							          const_SpeedPID_maxIntegral,
							          const_RotationPID_D) = 
						TimeOut_1(
							CalculateAngle::entered -> Clock_CLID_CalculateAngle(id__,0,
									          const_BalanceSTM_maxAngle,
									          const_BalanceSTM_loopTime,
									          const_BalanceSTM_startupDelay,
									          const_BalanceSTM_speedUpdate,
									          const_BalanceSTM_rotationUpdate,
									          const_BalanceSTM_angleBudget,
									          const_BalanceSTM_speedBudget,
									          const_BalanceSTM_rotationBudget,
									          const_BalanceSTM_motorBudget,
									          const_AnglePID_P,
									          const_AnglePID_D,
									          const_SpeedPID_P,
									          const_SpeedPID_I,
									          const_SpeedPID_maxIntegral,
									          const_RotationPID_D)
							[]
							get_CLID_CalculateAngle!x__ -> Clock_CLID_CalculateAngle(id__,x__,
									          const_BalanceSTM_maxAngle,
									          const_BalanceSTM_loopTime,
									          const_BalanceSTM_startupDelay,
									          const_BalanceSTM_speedUpdate,
									          const_BalanceSTM_rotationUpdate,
									          const_BalanceSTM_angleBudget,
									          const_BalanceSTM_speedBudget,
									          const_BalanceSTM_rotationBudget,
									          const_BalanceSTM_motorBudget,
									          const_AnglePID_P,
									          const_AnglePID_D,
									          const_SpeedPID_P,
									          const_SpeedPID_I,
									          const_SpeedPID_maxIntegral,
									          const_RotationPID_D)
							[]
							terminate -> SKIP,Clock_CLID_CalculateAngle(id__,clock_type_plus(x__,1,CLID_CalculateAngle_clock_type(id__,
									          const_BalanceSTM_maxAngle,
									          const_BalanceSTM_loopTime,
									          const_BalanceSTM_startupDelay,
									          const_BalanceSTM_speedUpdate,
									          const_BalanceSTM_rotationUpdate,
									          const_BalanceSTM_angleBudget,
									          const_BalanceSTM_speedBudget,
									          const_BalanceSTM_rotationBudget,
									          const_BalanceSTM_motorBudget,
									          const_AnglePID_P,
									          const_AnglePID_D,
									          const_SpeedPID_P,
									          const_SpeedPID_I,
									          const_SpeedPID_maxIntegral,
									          const_RotationPID_D)),
									          const_BalanceSTM_maxAngle,
									          const_BalanceSTM_loopTime,
									          const_BalanceSTM_startupDelay,
									          const_BalanceSTM_speedUpdate,
									          const_BalanceSTM_rotationUpdate,
									          const_BalanceSTM_angleBudget,
									          const_BalanceSTM_speedBudget,
									          const_BalanceSTM_rotationBudget,
									          const_BalanceSTM_motorBudget,
									          const_AnglePID_P,
									          const_AnglePID_D,
									          const_SpeedPID_P,
									          const_SpeedPID_I,
									          const_SpeedPID_maxIntegral,
									          const_RotationPID_D))
					Clock_CLID_CalculateSpeed(id__,x__,
							          const_BalanceSTM_maxAngle,
							          const_BalanceSTM_loopTime,
							          const_BalanceSTM_startupDelay,
							          const_BalanceSTM_speedUpdate,
							          const_BalanceSTM_rotationUpdate,
							          const_BalanceSTM_angleBudget,
							          const_BalanceSTM_speedBudget,
							          const_BalanceSTM_rotationBudget,
							          const_BalanceSTM_motorBudget,
							          const_AnglePID_P,
							          const_AnglePID_D,
							          const_SpeedPID_P,
							          const_SpeedPID_I,
							          const_SpeedPID_maxIntegral,
							          const_RotationPID_D) = 
						TimeOut_1(
							CalculateSpeed::entered -> Clock_CLID_CalculateSpeed(id__,0,
									          const_BalanceSTM_maxAngle,
									          const_BalanceSTM_loopTime,
									          const_BalanceSTM_startupDelay,
									          const_BalanceSTM_speedUpdate,
									          const_BalanceSTM_rotationUpdate,
									          const_BalanceSTM_angleBudget,
									          const_BalanceSTM_speedBudget,
									          const_BalanceSTM_rotationBudget,
									          const_BalanceSTM_motorBudget,
									          const_AnglePID_P,
									          const_AnglePID_D,
									          const_SpeedPID_P,
									          const_SpeedPID_I,
									          const_SpeedPID_maxIntegral,
									          const_RotationPID_D)
							[]
							get_CLID_CalculateSpeed!x__ -> Clock_CLID_CalculateSpeed(id__,x__,
									          const_BalanceSTM_maxAngle,
									          const_BalanceSTM_loopTime,
									          const_BalanceSTM_startupDelay,
									          const_BalanceSTM_speedUpdate,
									          const_BalanceSTM_rotationUpdate,
									          const_BalanceSTM_angleBudget,
									          const_BalanceSTM_speedBudget,
									          const_BalanceSTM_rotationBudget,
									          const_BalanceSTM_motorBudget,
									          const_AnglePID_P,
									          const_AnglePID_D,
									          const_SpeedPID_P,
									          const_SpeedPID_I,
									          const_SpeedPID_maxIntegral,
									          const_RotationPID_D)
							[]
							terminate -> SKIP,Clock_CLID_CalculateSpeed(id__,clock_type_plus(x__,1,CLID_CalculateSpeed_clock_type(id__,
									          const_BalanceSTM_maxAngle,
									          const_BalanceSTM_loopTime,
									          const_BalanceSTM_startupDelay,
									          const_BalanceSTM_speedUpdate,
									          const_BalanceSTM_rotationUpdate,
									          const_BalanceSTM_angleBudget,
									          const_BalanceSTM_speedBudget,
									          const_BalanceSTM_rotationBudget,
									          const_BalanceSTM_motorBudget,
									          const_AnglePID_P,
									          const_AnglePID_D,
									          const_SpeedPID_P,
									          const_SpeedPID_I,
									          const_SpeedPID_maxIntegral,
									          const_RotationPID_D)),
									          const_BalanceSTM_maxAngle,
									          const_BalanceSTM_loopTime,
									          const_BalanceSTM_startupDelay,
									          const_BalanceSTM_speedUpdate,
									          const_BalanceSTM_rotationUpdate,
									          const_BalanceSTM_angleBudget,
									          const_BalanceSTM_speedBudget,
									          const_BalanceSTM_rotationBudget,
									          const_BalanceSTM_motorBudget,
									          const_AnglePID_P,
									          const_AnglePID_D,
									          const_SpeedPID_P,
									          const_SpeedPID_I,
									          const_SpeedPID_maxIntegral,
									          const_RotationPID_D))
					Clock_CLID_SetMotors(id__,x__,
							          const_BalanceSTM_maxAngle,
							          const_BalanceSTM_loopTime,
							          const_BalanceSTM_startupDelay,
							          const_BalanceSTM_speedUpdate,
							          const_BalanceSTM_rotationUpdate,
							          const_BalanceSTM_angleBudget,
							          const_BalanceSTM_speedBudget,
							          const_BalanceSTM_rotationBudget,
							          const_BalanceSTM_motorBudget,
							          const_AnglePID_P,
							          const_AnglePID_D,
							          const_SpeedPID_P,
							          const_SpeedPID_I,
							          const_SpeedPID_maxIntegral,
							          const_RotationPID_D) = 
						TimeOut_1(
							SetMotors::entered -> Clock_CLID_SetMotors(id__,0,
									          const_BalanceSTM_maxAngle,
									          const_BalanceSTM_loopTime,
									          const_BalanceSTM_startupDelay,
									          const_BalanceSTM_speedUpdate,
									          const_BalanceSTM_rotationUpdate,
									          const_BalanceSTM_angleBudget,
									          const_BalanceSTM_speedBudget,
									          const_BalanceSTM_rotationBudget,
									          const_BalanceSTM_motorBudget,
									          const_AnglePID_P,
									          const_AnglePID_D,
									          const_SpeedPID_P,
									          const_SpeedPID_I,
									          const_SpeedPID_maxIntegral,
									          const_RotationPID_D)
							[]
							get_CLID_SetMotors!x__ -> Clock_CLID_SetMotors(id__,x__,
									          const_BalanceSTM_maxAngle,
									          const_BalanceSTM_loopTime,
									          const_BalanceSTM_startupDelay,
									          const_BalanceSTM_speedUpdate,
									          const_BalanceSTM_rotationUpdate,
									          const_BalanceSTM_angleBudget,
									          const_BalanceSTM_speedBudget,
									          const_BalanceSTM_rotationBudget,
									          const_BalanceSTM_motorBudget,
									          const_AnglePID_P,
									          const_AnglePID_D,
									          const_SpeedPID_P,
									          const_SpeedPID_I,
									          const_SpeedPID_maxIntegral,
									          const_RotationPID_D)
							[]
							terminate -> SKIP,Clock_CLID_SetMotors(id__,clock_type_plus(x__,1,CLID_SetMotors_clock_type(id__,
									          const_BalanceSTM_maxAngle,
									          const_BalanceSTM_loopTime,
									          const_BalanceSTM_startupDelay,
									          const_BalanceSTM_speedUpdate,
									          const_BalanceSTM_rotationUpdate,
									          const_BalanceSTM_angleBudget,
									          const_BalanceSTM_speedBudget,
									          const_BalanceSTM_rotationBudget,
									          const_BalanceSTM_motorBudget,
									          const_AnglePID_P,
									          const_AnglePID_D,
									          const_SpeedPID_P,
									          const_SpeedPID_I,
									          const_SpeedPID_maxIntegral,
									          const_RotationPID_D)),
									          const_BalanceSTM_maxAngle,
									          const_BalanceSTM_loopTime,
									          const_BalanceSTM_startupDelay,
									          const_BalanceSTM_speedUpdate,
									          const_BalanceSTM_rotationUpdate,
									          const_BalanceSTM_angleBudget,
									          const_BalanceSTM_speedBudget,
									          const_BalanceSTM_rotationBudget,
									          const_BalanceSTM_motorBudget,
									          const_AnglePID_P,
									          const_AnglePID_D,
									          const_SpeedPID_P,
									          const_SpeedPID_I,
									          const_SpeedPID_maxIntegral,
									          const_RotationPID_D))
					Clock_CLID_CalculateRotation(id__,x__,
							          const_BalanceSTM_maxAngle,
							          const_BalanceSTM_loopTime,
							          const_BalanceSTM_startupDelay,
							          const_BalanceSTM_speedUpdate,
							          const_BalanceSTM_rotationUpdate,
							          const_BalanceSTM_angleBudget,
							          const_BalanceSTM_speedBudget,
							          const_BalanceSTM_rotationBudget,
							          const_BalanceSTM_motorBudget,
							          const_AnglePID_P,
							          const_AnglePID_D,
							          const_SpeedPID_P,
							          const_SpeedPID_I,
							          const_SpeedPID_maxIntegral,
							          const_RotationPID_D) = 
						TimeOut_1(
							CalculateRotation::entered -> Clock_CLID_CalculateRotation(id__,0,
									          const_BalanceSTM_maxAngle,
									          const_BalanceSTM_loopTime,
									          const_BalanceSTM_startupDelay,
									          const_BalanceSTM_speedUpdate,
									          const_BalanceSTM_rotationUpdate,
									          const_BalanceSTM_angleBudget,
									          const_BalanceSTM_speedBudget,
									          const_BalanceSTM_rotationBudget,
									          const_BalanceSTM_motorBudget,
									          const_AnglePID_P,
									          const_AnglePID_D,
									          const_SpeedPID_P,
									          const_SpeedPID_I,
									          const_SpeedPID_maxIntegral,
									          const_RotationPID_D)
							[]
							get_CLID_CalculateRotation!x__ -> Clock_CLID_CalculateRotation(id__,x__,
									          const_BalanceSTM_maxAngle,
									          const_BalanceSTM_loopTime,
									          const_BalanceSTM_startupDelay,
									          const_BalanceSTM_speedUpdate,
									          const_BalanceSTM_rotationUpdate,
									          const_BalanceSTM_angleBudget,
									          const_BalanceSTM_speedBudget,
									          const_BalanceSTM_rotationBudget,
									          const_BalanceSTM_motorBudget,
									          const_AnglePID_P,
									          const_AnglePID_D,
									          const_SpeedPID_P,
									          const_SpeedPID_I,
									          const_SpeedPID_maxIntegral,
									          const_RotationPID_D)
							[]
							terminate -> SKIP,Clock_CLID_CalculateRotation(id__,clock_type_plus(x__,1,CLID_CalculateRotation_clock_type(id__,
									          const_BalanceSTM_maxAngle,
									          const_BalanceSTM_loopTime,
									          const_BalanceSTM_startupDelay,
									          const_BalanceSTM_speedUpdate,
									          const_BalanceSTM_rotationUpdate,
									          const_BalanceSTM_angleBudget,
									          const_BalanceSTM_speedBudget,
									          const_BalanceSTM_rotationBudget,
									          const_BalanceSTM_motorBudget,
									          const_AnglePID_P,
									          const_AnglePID_D,
									          const_SpeedPID_P,
									          const_SpeedPID_I,
									          const_SpeedPID_maxIntegral,
									          const_RotationPID_D)),
									          const_BalanceSTM_maxAngle,
									          const_BalanceSTM_loopTime,
									          const_BalanceSTM_startupDelay,
									          const_BalanceSTM_speedUpdate,
									          const_BalanceSTM_rotationUpdate,
									          const_BalanceSTM_angleBudget,
									          const_BalanceSTM_speedBudget,
									          const_BalanceSTM_rotationBudget,
									          const_BalanceSTM_motorBudget,
									          const_AnglePID_P,
									          const_AnglePID_D,
									          const_SpeedPID_P,
									          const_SpeedPID_I,
									          const_SpeedPID_maxIntegral,
									          const_RotationPID_D))
					Clock_CLID_WaitForNextIteration(id__,x__,
							          const_BalanceSTM_maxAngle,
							          const_BalanceSTM_loopTime,
							          const_BalanceSTM_startupDelay,
							          const_BalanceSTM_speedUpdate,
							          const_BalanceSTM_rotationUpdate,
							          const_BalanceSTM_angleBudget,
							          const_BalanceSTM_speedBudget,
							          const_BalanceSTM_rotationBudget,
							          const_BalanceSTM_motorBudget,
							          const_AnglePID_P,
							          const_AnglePID_D,
							          const_SpeedPID_P,
							          const_SpeedPID_I,
							          const_SpeedPID_maxIntegral,
							          const_RotationPID_D) = 
						TimeOut_1(
							WaitForNextIteration::entered -> Clock_CLID_WaitForNextIteration(id__,0,
									          const_BalanceSTM_maxAngle,
									          const_BalanceSTM_loopTime,
									          const_BalanceSTM_startupDelay,
									          const_BalanceSTM_speedUpdate,
									          const_BalanceSTM_rotationUpdate,
									          const_BalanceSTM_angleBudget,
									          const_BalanceSTM_speedBudget,
									          const_BalanceSTM_rotationBudget,
									          const_BalanceSTM_motorBudget,
									          const_AnglePID_P,
									          const_AnglePID_D,
									          const_SpeedPID_P,
									          const_SpeedPID_I,
									          const_SpeedPID_maxIntegral,
									          const_RotationPID_D)
							[]
							get_CLID_WaitForNextIteration!x__ -> Clock_CLID_WaitForNextIteration(id__,x__,
									          const_BalanceSTM_maxAngle,
									          const_BalanceSTM_loopTime,
									          const_BalanceSTM_startupDelay,
									          const_BalanceSTM_speedUpdate,
									          const_BalanceSTM_rotationUpdate,
									          const_BalanceSTM_angleBudget,
									          const_BalanceSTM_speedBudget,
									          const_BalanceSTM_rotationBudget,
									          const_BalanceSTM_motorBudget,
									          const_AnglePID_P,
									          const_AnglePID_D,
									          const_SpeedPID_P,
									          const_SpeedPID_I,
									          const_SpeedPID_maxIntegral,
									          const_RotationPID_D)
							[]
							terminate -> SKIP,Clock_CLID_WaitForNextIteration(id__,clock_type_plus(x__,1,CLID_WaitForNextIteration_clock_type(id__,
									          const_BalanceSTM_maxAngle,
									          const_BalanceSTM_loopTime,
									          const_BalanceSTM_startupDelay,
									          const_BalanceSTM_speedUpdate,
									          const_BalanceSTM_rotationUpdate,
									          const_BalanceSTM_angleBudget,
									          const_BalanceSTM_speedBudget,
									          const_BalanceSTM_rotationBudget,
									          const_BalanceSTM_motorBudget,
									          const_AnglePID_P,
									          const_AnglePID_D,
									          const_SpeedPID_P,
									          const_SpeedPID_I,
									          const_SpeedPID_maxIntegral,
									          const_RotationPID_D)),
									          const_BalanceSTM_maxAngle,
									          const_BalanceSTM_loopTime,
									          const_BalanceSTM_startupDelay,
									          const_BalanceSTM_speedUpdate,
									          const_BalanceSTM_rotationUpdate,
									          const_BalanceSTM_angleBudget,
									          const_BalanceSTM_speedBudget,
									          const_BalanceSTM_rotationBudget,
									          const_BalanceSTM_motorBudget,
									          const_AnglePID_P,
									          const_AnglePID_D,
									          const_SpeedPID_P,
									          const_SpeedPID_I,
									          const_SpeedPID_maxIntegral,
									          const_RotationPID_D))
					Clock_CLID_Initialisation(id__,x__,
							          const_BalanceSTM_maxAngle,
							          const_BalanceSTM_loopTime,
							          const_BalanceSTM_startupDelay,
							          const_BalanceSTM_speedUpdate,
							          const_BalanceSTM_rotationUpdate,
							          const_BalanceSTM_angleBudget,
							          const_BalanceSTM_speedBudget,
							          const_BalanceSTM_rotationBudget,
							          const_BalanceSTM_motorBudget,
							          const_AnglePID_P,
							          const_AnglePID_D,
							          const_SpeedPID_P,
							          const_SpeedPID_I,
							          const_SpeedPID_maxIntegral,
							          const_RotationPID_D) = 
						TimeOut_1(
							Initialisation::entered -> Clock_CLID_Initialisation(id__,0,
									          const_BalanceSTM_maxAngle,
									          const_BalanceSTM_loopTime,
									          const_BalanceSTM_startupDelay,
									          const_BalanceSTM_speedUpdate,
									          const_BalanceSTM_rotationUpdate,
									          const_BalanceSTM_angleBudget,
									          const_BalanceSTM_speedBudget,
									          const_BalanceSTM_rotationBudget,
									          const_BalanceSTM_motorBudget,
									          const_AnglePID_P,
									          const_AnglePID_D,
									          const_SpeedPID_P,
									          const_SpeedPID_I,
									          const_SpeedPID_maxIntegral,
									          const_RotationPID_D)
							[]
							get_CLID_Initialisation!x__ -> Clock_CLID_Initialisation(id__,x__,
									          const_BalanceSTM_maxAngle,
									          const_BalanceSTM_loopTime,
									          const_BalanceSTM_startupDelay,
									          const_BalanceSTM_speedUpdate,
									          const_BalanceSTM_rotationUpdate,
									          const_BalanceSTM_angleBudget,
									          const_BalanceSTM_speedBudget,
									          const_BalanceSTM_rotationBudget,
									          const_BalanceSTM_motorBudget,
									          const_AnglePID_P,
									          const_AnglePID_D,
									          const_SpeedPID_P,
									          const_SpeedPID_I,
									          const_SpeedPID_maxIntegral,
									          const_RotationPID_D)
							[]
							terminate -> SKIP,Clock_CLID_Initialisation(id__,clock_type_plus(x__,1,CLID_Initialisation_clock_type(id__,
									          const_BalanceSTM_maxAngle,
									          const_BalanceSTM_loopTime,
									          const_BalanceSTM_startupDelay,
									          const_BalanceSTM_speedUpdate,
									          const_BalanceSTM_rotationUpdate,
									          const_BalanceSTM_angleBudget,
									          const_BalanceSTM_speedBudget,
									          const_BalanceSTM_rotationBudget,
									          const_BalanceSTM_motorBudget,
									          const_AnglePID_P,
									          const_AnglePID_D,
									          const_SpeedPID_P,
									          const_SpeedPID_I,
									          const_SpeedPID_maxIntegral,
									          const_RotationPID_D)),
									          const_BalanceSTM_maxAngle,
									          const_BalanceSTM_loopTime,
									          const_BalanceSTM_startupDelay,
									          const_BalanceSTM_speedUpdate,
									          const_BalanceSTM_rotationUpdate,
									          const_BalanceSTM_angleBudget,
									          const_BalanceSTM_speedBudget,
									          const_BalanceSTM_rotationBudget,
									          const_BalanceSTM_motorBudget,
									          const_AnglePID_P,
									          const_AnglePID_D,
									          const_SpeedPID_P,
									          const_SpeedPID_I,
									          const_SpeedPID_maxIntegral,
									          const_RotationPID_D))
					Clock_CLID_StopMotors(id__,x__,
							          const_BalanceSTM_maxAngle,
							          const_BalanceSTM_loopTime,
							          const_BalanceSTM_startupDelay,
							          const_BalanceSTM_speedUpdate,
							          const_BalanceSTM_rotationUpdate,
							          const_BalanceSTM_angleBudget,
							          const_BalanceSTM_speedBudget,
							          const_BalanceSTM_rotationBudget,
							          const_BalanceSTM_motorBudget,
							          const_AnglePID_P,
							          const_AnglePID_D,
							          const_SpeedPID_P,
							          const_SpeedPID_I,
							          const_SpeedPID_maxIntegral,
							          const_RotationPID_D) = 
						TimeOut_1(
							StopMotors::entered -> Clock_CLID_StopMotors(id__,0,
									          const_BalanceSTM_maxAngle,
									          const_BalanceSTM_loopTime,
									          const_BalanceSTM_startupDelay,
									          const_BalanceSTM_speedUpdate,
									          const_BalanceSTM_rotationUpdate,
									          const_BalanceSTM_angleBudget,
									          const_BalanceSTM_speedBudget,
									          const_BalanceSTM_rotationBudget,
									          const_BalanceSTM_motorBudget,
									          const_AnglePID_P,
									          const_AnglePID_D,
									          const_SpeedPID_P,
									          const_SpeedPID_I,
									          const_SpeedPID_maxIntegral,
									          const_RotationPID_D)
							[]
							get_CLID_StopMotors!x__ -> Clock_CLID_StopMotors(id__,x__,
									          const_BalanceSTM_maxAngle,
									          const_BalanceSTM_loopTime,
									          const_BalanceSTM_startupDelay,
									          const_BalanceSTM_speedUpdate,
									          const_BalanceSTM_rotationUpdate,
									          const_BalanceSTM_angleBudget,
									          const_BalanceSTM_speedBudget,
									          const_BalanceSTM_rotationBudget,
									          const_BalanceSTM_motorBudget,
									          const_AnglePID_P,
									          const_AnglePID_D,
									          const_SpeedPID_P,
									          const_SpeedPID_I,
									          const_SpeedPID_maxIntegral,
									          const_RotationPID_D)
							[]
							terminate -> SKIP,Clock_CLID_StopMotors(id__,clock_type_plus(x__,1,CLID_StopMotors_clock_type(id__,
									          const_BalanceSTM_maxAngle,
									          const_BalanceSTM_loopTime,
									          const_BalanceSTM_startupDelay,
									          const_BalanceSTM_speedUpdate,
									          const_BalanceSTM_rotationUpdate,
									          const_BalanceSTM_angleBudget,
									          const_BalanceSTM_speedBudget,
									          const_BalanceSTM_rotationBudget,
									          const_BalanceSTM_motorBudget,
									          const_AnglePID_P,
									          const_AnglePID_D,
									          const_SpeedPID_P,
									          const_SpeedPID_I,
									          const_SpeedPID_maxIntegral,
									          const_RotationPID_D)),
									          const_BalanceSTM_maxAngle,
									          const_BalanceSTM_loopTime,
									          const_BalanceSTM_startupDelay,
									          const_BalanceSTM_speedUpdate,
									          const_BalanceSTM_rotationUpdate,
									          const_BalanceSTM_angleBudget,
									          const_BalanceSTM_speedBudget,
									          const_BalanceSTM_rotationBudget,
									          const_BalanceSTM_motorBudget,
									          const_AnglePID_P,
									          const_AnglePID_D,
									          const_SpeedPID_P,
									          const_SpeedPID_I,
									          const_SpeedPID_maxIntegral,
									          const_RotationPID_D))
					
					StateClocks(id__,
							          const_BalanceSTM_maxAngle,
							          const_BalanceSTM_loopTime,
							          const_BalanceSTM_startupDelay,
							          const_BalanceSTM_speedUpdate,
							          const_BalanceSTM_rotationUpdate,
							          const_BalanceSTM_angleBudget,
							          const_BalanceSTM_speedBudget,
							          const_BalanceSTM_rotationBudget,
							          const_BalanceSTM_motorBudget,
							          const_AnglePID_P,
							          const_AnglePID_D,
							          const_SpeedPID_P,
							          const_SpeedPID_I,
							          const_SpeedPID_maxIntegral,
							          const_RotationPID_D) = dbisim(Clock_CLID_CalculateAngle(id__,0,
							          const_BalanceSTM_maxAngle,
							          const_BalanceSTM_loopTime,
							          const_BalanceSTM_startupDelay,
							          const_BalanceSTM_speedUpdate,
							          const_BalanceSTM_rotationUpdate,
							          const_BalanceSTM_angleBudget,
							          const_BalanceSTM_speedBudget,
							          const_BalanceSTM_rotationBudget,
							          const_BalanceSTM_motorBudget,
							          const_AnglePID_P,
							          const_AnglePID_D,
							          const_SpeedPID_P,
							          const_SpeedPID_I,
							          const_SpeedPID_maxIntegral,
							          const_RotationPID_D))
					[| { terminate } |] (
					dbisim(Clock_CLID_CalculateSpeed(id__,0,
							          const_BalanceSTM_maxAngle,
							          const_BalanceSTM_loopTime,
							          const_BalanceSTM_startupDelay,
							          const_BalanceSTM_speedUpdate,
							          const_BalanceSTM_rotationUpdate,
							          const_BalanceSTM_angleBudget,
							          const_BalanceSTM_speedBudget,
							          const_BalanceSTM_rotationBudget,
							          const_BalanceSTM_motorBudget,
							          const_AnglePID_P,
							          const_AnglePID_D,
							          const_SpeedPID_P,
							          const_SpeedPID_I,
							          const_SpeedPID_maxIntegral,
							          const_RotationPID_D))
					[| { terminate } |] (
					dbisim(Clock_CLID_SetMotors(id__,0,
							          const_BalanceSTM_maxAngle,
							          const_BalanceSTM_loopTime,
							          const_BalanceSTM_startupDelay,
							          const_BalanceSTM_speedUpdate,
							          const_BalanceSTM_rotationUpdate,
							          const_BalanceSTM_angleBudget,
							          const_BalanceSTM_speedBudget,
							          const_BalanceSTM_rotationBudget,
							          const_BalanceSTM_motorBudget,
							          const_AnglePID_P,
							          const_AnglePID_D,
							          const_SpeedPID_P,
							          const_SpeedPID_I,
							          const_SpeedPID_maxIntegral,
							          const_RotationPID_D))
					[| { terminate } |] (
					dbisim(Clock_CLID_CalculateRotation(id__,0,
							          const_BalanceSTM_maxAngle,
							          const_BalanceSTM_loopTime,
							          const_BalanceSTM_startupDelay,
							          const_BalanceSTM_speedUpdate,
							          const_BalanceSTM_rotationUpdate,
							          const_BalanceSTM_angleBudget,
							          const_BalanceSTM_speedBudget,
							          const_BalanceSTM_rotationBudget,
							          const_BalanceSTM_motorBudget,
							          const_AnglePID_P,
							          const_AnglePID_D,
							          const_SpeedPID_P,
							          const_SpeedPID_I,
							          const_SpeedPID_maxIntegral,
							          const_RotationPID_D))
					[| { terminate } |] (
					dbisim(Clock_CLID_WaitForNextIteration(id__,0,
							          const_BalanceSTM_maxAngle,
							          const_BalanceSTM_loopTime,
							          const_BalanceSTM_startupDelay,
							          const_BalanceSTM_speedUpdate,
							          const_BalanceSTM_rotationUpdate,
							          const_BalanceSTM_angleBudget,
							          const_BalanceSTM_speedBudget,
							          const_BalanceSTM_rotationBudget,
							          const_BalanceSTM_motorBudget,
							          const_AnglePID_P,
							          const_AnglePID_D,
							          const_SpeedPID_P,
							          const_SpeedPID_I,
							          const_SpeedPID_maxIntegral,
							          const_RotationPID_D))
					[| { terminate } |] (
					dbisim(Clock_CLID_Initialisation(id__,0,
							          const_BalanceSTM_maxAngle,
							          const_BalanceSTM_loopTime,
							          const_BalanceSTM_startupDelay,
							          const_BalanceSTM_speedUpdate,
							          const_BalanceSTM_rotationUpdate,
							          const_BalanceSTM_angleBudget,
							          const_BalanceSTM_speedBudget,
							          const_BalanceSTM_rotationBudget,
							          const_BalanceSTM_motorBudget,
							          const_AnglePID_P,
							          const_AnglePID_D,
							          const_SpeedPID_P,
							          const_SpeedPID_I,
							          const_SpeedPID_maxIntegral,
							          const_RotationPID_D))
					[| { terminate } |] (
					dbisim(Clock_CLID_StopMotors(id__,0,
							          const_BalanceSTM_maxAngle,
							          const_BalanceSTM_loopTime,
							          const_BalanceSTM_startupDelay,
							          const_BalanceSTM_speedUpdate,
							          const_BalanceSTM_rotationUpdate,
							          const_BalanceSTM_angleBudget,
							          const_BalanceSTM_speedBudget,
							          const_BalanceSTM_rotationBudget,
							          const_BalanceSTM_motorBudget,
							          const_AnglePID_P,
							          const_AnglePID_D,
							          const_SpeedPID_P,
							          const_SpeedPID_I,
							          const_SpeedPID_maxIntegral,
							          const_RotationPID_D))
					)
					)
					)
					)
					)
					)
					
					stateClockSync = {|get_CLID_CalculateAngle,CalculateAngle::entered,get_CLID_CalculateSpeed,CalculateSpeed::entered,get_CLID_SetMotors,SetMotors::entered,get_CLID_CalculateRotation,CalculateRotation::entered,get_CLID_WaitForNextIteration,WaitForNextIteration::entered,get_CLID_Initialisation,Initialisation::entered,get_CLID_StopMotors,StopMotors::entered|}
					
					-- Shared memory
					-- Shared memory variables
					
					-- sharedVarMemory process
					sharedVarMemory(id__,
							    const_BalanceSTM_maxAngle,
							    const_BalanceSTM_loopTime,
							    const_BalanceSTM_startupDelay,
							    const_BalanceSTM_speedUpdate,
							    const_BalanceSTM_rotationUpdate,
							    const_BalanceSTM_angleBudget,
							    const_BalanceSTM_speedBudget,
							    const_BalanceSTM_rotationBudget,
							    const_BalanceSTM_motorBudget,
							    const_AnglePID_P,
							    const_AnglePID_D,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral,
							    const_RotationPID_D) = terminate -> SKIP
					
					sharedVarSync = {||}
					
					sharedVarHide = {||}
					}
			endmodule
			
			Timed(OneStep) {
					-- undefined operations
					CALL__setLeftMotorSpeed(id__,
							    param_speed) 	= setLeftMotorSpeedCall.param_speed -> SKIP
					CALL__enableInterrupts(id__) 	= enableInterruptsCall -> SKIP
					CALL__setRightMotorSpeed(id__,
							    param_speed) 	= setRightMotorSpeedCall.param_speed -> SKIP
					CALL__disableInterrupts(id__) 	= disableInterruptsCall -> SKIP
					
					-- declaring controller memory
					Memory(id__) = SKIP
					
					D__(id__,
							    const_Segway_SegwayController_stm_ref0_maxAngle,
							    const_Segway_SegwayController_stm_ref0_loopTime,
							    const_Segway_SegwayController_stm_ref0_startupDelay,
							    const_Segway_SegwayController_stm_ref0_speedUpdate,
							    const_Segway_SegwayController_stm_ref0_rotationUpdate,
							    const_Segway_SegwayController_stm_ref0_angleBudget,
							    const_Segway_SegwayController_stm_ref0_speedBudget,
							    const_Segway_SegwayController_stm_ref0_rotationBudget,
							    const_Segway_SegwayController_stm_ref0_motorBudget,
							   	const_Segway_SegwayController_op_ref0_P,
							   	const_Segway_SegwayController_op_ref0_D,
							   	const_Segway_SegwayController_op_ref1_P,
							   	const_Segway_SegwayController_op_ref1_I,
							   	const_Segway_SegwayController_op_ref1_maxIntegral,
							   	const_Segway_SegwayController_op_ref2_D) = prioritise(	((
							let
								const_BalanceSTM_maxAngle = const_Segway_SegwayController_stm_ref0_maxAngle
								const_BalanceSTM_loopTime = const_Segway_SegwayController_stm_ref0_loopTime
								const_BalanceSTM_startupDelay = const_Segway_SegwayController_stm_ref0_startupDelay
								const_BalanceSTM_speedUpdate = const_Segway_SegwayController_stm_ref0_speedUpdate
								const_BalanceSTM_rotationUpdate = const_Segway_SegwayController_stm_ref0_rotationUpdate
								const_BalanceSTM_angleBudget = const_Segway_SegwayController_stm_ref0_angleBudget
								const_BalanceSTM_speedBudget = const_Segway_SegwayController_stm_ref0_speedBudget
								const_BalanceSTM_rotationBudget = const_Segway_SegwayController_stm_ref0_rotationBudget
								const_BalanceSTM_motorBudget = const_Segway_SegwayController_stm_ref0_motorBudget
								const_AnglePID_P = const_Segway_SegwayController_op_ref0_P
								const_AnglePID_D = const_Segway_SegwayController_op_ref0_D
								const_SpeedPID_P = const_Segway_SegwayController_op_ref1_P
								const_SpeedPID_I = const_Segway_SegwayController_op_ref1_I
								const_SpeedPID_maxIntegral = const_Segway_SegwayController_op_ref1_maxIntegral
								const_RotationPID_D = const_Segway_SegwayController_op_ref2_D
							within 
							stm_ref0::D__(id__,
									    const_BalanceSTM_maxAngle,
									    const_BalanceSTM_loopTime,
									    const_BalanceSTM_startupDelay,
									    const_BalanceSTM_speedUpdate,
									    const_BalanceSTM_rotationUpdate,
									    const_BalanceSTM_angleBudget,
									    const_BalanceSTM_speedBudget,
									    const_BalanceSTM_rotationBudget,
									    const_BalanceSTM_motorBudget,
									    const_AnglePID_P,
									    const_AnglePID_D,
									    const_SpeedPID_P,
									    const_SpeedPID_I,
									    const_SpeedPID_maxIntegral,
									    const_RotationPID_D)[[
								stm_ref0::terminate <- terminate,
								stm_ref0::leftMotorVelocity <- leftMotorVelocity,
								stm_ref0::rightMotorVelocity <- rightMotorVelocity,
								stm_ref0::angle <- angle,
								stm_ref0::gyroX <- gyroX,
								stm_ref0::gyroY <- gyroY,
								stm_ref0::gyroZ <- gyroZ,
								stm_ref0::setLeftMotorSpeedCall <- setLeftMotorSpeedCall,
								stm_ref0::enableInterruptsCall <- enableInterruptsCall,
								stm_ref0::setRightMotorSpeedCall <- setRightMotorSpeedCall,
								stm_ref0::disableInterruptsCall <- disableInterruptsCall
							]]
						)
							[|
								union(
									{|
									|},
									{|
									|}
								)
							|]
						Memory(id__)
					)
					\ union(
						{|
						|},
						{|
						|}
					)
					[|{|terminate|}|>SKIP
					,<union(visibleMemoryEvents,{terminate}),{tock}>)
					
					-- VS version
					VS__(id__,
							    const_Segway_SegwayController_stm_ref0_maxAngle,
							    const_Segway_SegwayController_stm_ref0_loopTime,
							    const_Segway_SegwayController_stm_ref0_startupDelay,
							    const_Segway_SegwayController_stm_ref0_speedUpdate,
							    const_Segway_SegwayController_stm_ref0_rotationUpdate,
							    const_Segway_SegwayController_stm_ref0_angleBudget,
							    const_Segway_SegwayController_stm_ref0_speedBudget,
							    const_Segway_SegwayController_stm_ref0_rotationBudget,
							    const_Segway_SegwayController_stm_ref0_motorBudget,
							   	const_Segway_SegwayController_op_ref0_P,
							   	const_Segway_SegwayController_op_ref0_D,
							   	const_Segway_SegwayController_op_ref1_P,
							   	const_Segway_SegwayController_op_ref1_I,
							   	const_Segway_SegwayController_op_ref1_maxIntegral,
							   	const_Segway_SegwayController_op_ref2_D) = prioritise(	((
							let
								const_BalanceSTM_maxAngle = const_Segway_SegwayController_stm_ref0_maxAngle
								const_BalanceSTM_loopTime = const_Segway_SegwayController_stm_ref0_loopTime
								const_BalanceSTM_startupDelay = const_Segway_SegwayController_stm_ref0_startupDelay
								const_BalanceSTM_speedUpdate = const_Segway_SegwayController_stm_ref0_speedUpdate
								const_BalanceSTM_rotationUpdate = const_Segway_SegwayController_stm_ref0_rotationUpdate
								const_BalanceSTM_angleBudget = const_Segway_SegwayController_stm_ref0_angleBudget
								const_BalanceSTM_speedBudget = const_Segway_SegwayController_stm_ref0_speedBudget
								const_BalanceSTM_rotationBudget = const_Segway_SegwayController_stm_ref0_rotationBudget
								const_BalanceSTM_motorBudget = const_Segway_SegwayController_stm_ref0_motorBudget
								const_AnglePID_P = const_Segway_SegwayController_op_ref0_P
								const_AnglePID_D = const_Segway_SegwayController_op_ref0_D
								const_SpeedPID_P = const_Segway_SegwayController_op_ref1_P
								const_SpeedPID_I = const_Segway_SegwayController_op_ref1_I
								const_SpeedPID_maxIntegral = const_Segway_SegwayController_op_ref1_maxIntegral
								const_RotationPID_D = const_Segway_SegwayController_op_ref2_D
							within 
							stm_ref0::VS__(id__,
									    const_BalanceSTM_maxAngle,
									    const_BalanceSTM_loopTime,
									    const_BalanceSTM_startupDelay,
									    const_BalanceSTM_speedUpdate,
									    const_BalanceSTM_rotationUpdate,
									    const_BalanceSTM_angleBudget,
									    const_BalanceSTM_speedBudget,
									    const_BalanceSTM_rotationBudget,
									    const_BalanceSTM_motorBudget,
									    const_AnglePID_P,
									    const_AnglePID_D,
									    const_SpeedPID_P,
									    const_SpeedPID_I,
									    const_SpeedPID_maxIntegral,
									    const_RotationPID_D)[[
								stm_ref0::terminate <- terminate,
								stm_ref0::leftMotorVelocity <- leftMotorVelocity,
								stm_ref0::rightMotorVelocity <- rightMotorVelocity,
								stm_ref0::angle <- angle,
								stm_ref0::gyroX <- gyroX,
								stm_ref0::gyroY <- gyroY,
								stm_ref0::gyroZ <- gyroZ,
								stm_ref0::setLeftMotorSpeedCall <- setLeftMotorSpeedCall,
								stm_ref0::enableInterruptsCall <- enableInterruptsCall,
								stm_ref0::setRightMotorSpeedCall <- setRightMotorSpeedCall,
								stm_ref0::disableInterruptsCall <- disableInterruptsCall
							]]
						)
							[|
								union(
									{|
									|},
									{|
									|}
								)
							|]
						Memory(id__)
					)
					\ union(
						{|
						|},
						{|
						|}
					)
					[|{|terminate|}|>SKIP
					,<union(visibleMemoryEvents,{terminate}),{tock}>)
				
					-- O version (optimised) THESE TWO PROCESSES SHOULD BE KEPT IN SYNC WITH THE ABOVE TWO
					O__(id__,
							    const_Segway_SegwayController_stm_ref0_maxAngle,
							    const_Segway_SegwayController_stm_ref0_loopTime,
							    const_Segway_SegwayController_stm_ref0_startupDelay,
							    const_Segway_SegwayController_stm_ref0_speedUpdate,
							    const_Segway_SegwayController_stm_ref0_rotationUpdate,
							    const_Segway_SegwayController_stm_ref0_angleBudget,
							    const_Segway_SegwayController_stm_ref0_speedBudget,
							    const_Segway_SegwayController_stm_ref0_rotationBudget,
							    const_Segway_SegwayController_stm_ref0_motorBudget,
							   	const_Segway_SegwayController_op_ref0_P,
							   	const_Segway_SegwayController_op_ref0_D,
							   	const_Segway_SegwayController_op_ref1_P,
							   	const_Segway_SegwayController_op_ref1_I,
							   	const_Segway_SegwayController_op_ref1_maxIntegral,
							   	const_Segway_SegwayController_op_ref2_D) = dbisim(prioritise(	((
							let
								const_BalanceSTM_maxAngle = const_Segway_SegwayController_stm_ref0_maxAngle
								const_BalanceSTM_loopTime = const_Segway_SegwayController_stm_ref0_loopTime
								const_BalanceSTM_startupDelay = const_Segway_SegwayController_stm_ref0_startupDelay
								const_BalanceSTM_speedUpdate = const_Segway_SegwayController_stm_ref0_speedUpdate
								const_BalanceSTM_rotationUpdate = const_Segway_SegwayController_stm_ref0_rotationUpdate
								const_BalanceSTM_angleBudget = const_Segway_SegwayController_stm_ref0_angleBudget
								const_BalanceSTM_speedBudget = const_Segway_SegwayController_stm_ref0_speedBudget
								const_BalanceSTM_rotationBudget = const_Segway_SegwayController_stm_ref0_rotationBudget
								const_BalanceSTM_motorBudget = const_Segway_SegwayController_stm_ref0_motorBudget
								const_AnglePID_P = const_Segway_SegwayController_op_ref0_P
								const_AnglePID_D = const_Segway_SegwayController_op_ref0_D
								const_SpeedPID_P = const_Segway_SegwayController_op_ref1_P
								const_SpeedPID_I = const_Segway_SegwayController_op_ref1_I
								const_SpeedPID_maxIntegral = const_Segway_SegwayController_op_ref1_maxIntegral
								const_RotationPID_D = const_Segway_SegwayController_op_ref2_D
							within 
							stm_ref0::O__(id__,
									    const_BalanceSTM_maxAngle,
									    const_BalanceSTM_loopTime,
									    const_BalanceSTM_startupDelay,
									    const_BalanceSTM_speedUpdate,
									    const_BalanceSTM_rotationUpdate,
									    const_BalanceSTM_angleBudget,
									    const_BalanceSTM_speedBudget,
									    const_BalanceSTM_rotationBudget,
									    const_BalanceSTM_motorBudget,
									    const_AnglePID_P,
									    const_AnglePID_D,
									    const_SpeedPID_P,
									    const_SpeedPID_I,
									    const_SpeedPID_maxIntegral,
									    const_RotationPID_D)[[
								stm_ref0::terminate <- terminate,
								stm_ref0::leftMotorVelocity <- leftMotorVelocity,
								stm_ref0::rightMotorVelocity <- rightMotorVelocity,
								stm_ref0::angle <- angle,
								stm_ref0::gyroX <- gyroX,
								stm_ref0::gyroY <- gyroY,
								stm_ref0::gyroZ <- gyroZ,
								stm_ref0::setLeftMotorSpeedCall <- setLeftMotorSpeedCall,
								stm_ref0::enableInterruptsCall <- enableInterruptsCall,
								stm_ref0::setRightMotorSpeedCall <- setRightMotorSpeedCall,
								stm_ref0::disableInterruptsCall <- disableInterruptsCall
							]]
						)
							[|
								union(
									{|
									|},
									{|
									|}
								)
							|]
						dbisim(Memory(id__))
					)
					\ union(
						{|
						|},
						{|
						|}
					)
					[|{|terminate|}|>SKIP
					,<union(visibleMemoryEvents,{terminate}),{tock}>))
									
					-- VS_O version
					VS_O__(id__,
							    const_Segway_SegwayController_stm_ref0_maxAngle,
							    const_Segway_SegwayController_stm_ref0_loopTime,
							    const_Segway_SegwayController_stm_ref0_startupDelay,
							    const_Segway_SegwayController_stm_ref0_speedUpdate,
							    const_Segway_SegwayController_stm_ref0_rotationUpdate,
							    const_Segway_SegwayController_stm_ref0_angleBudget,
							    const_Segway_SegwayController_stm_ref0_speedBudget,
							    const_Segway_SegwayController_stm_ref0_rotationBudget,
							    const_Segway_SegwayController_stm_ref0_motorBudget,
							   	const_Segway_SegwayController_op_ref0_P,
							   	const_Segway_SegwayController_op_ref0_D,
							   	const_Segway_SegwayController_op_ref1_P,
							   	const_Segway_SegwayController_op_ref1_I,
							   	const_Segway_SegwayController_op_ref1_maxIntegral,
							   	const_Segway_SegwayController_op_ref2_D) = dbisim(prioritise(	((
							let
								const_BalanceSTM_maxAngle = const_Segway_SegwayController_stm_ref0_maxAngle
								const_BalanceSTM_loopTime = const_Segway_SegwayController_stm_ref0_loopTime
								const_BalanceSTM_startupDelay = const_Segway_SegwayController_stm_ref0_startupDelay
								const_BalanceSTM_speedUpdate = const_Segway_SegwayController_stm_ref0_speedUpdate
								const_BalanceSTM_rotationUpdate = const_Segway_SegwayController_stm_ref0_rotationUpdate
								const_BalanceSTM_angleBudget = const_Segway_SegwayController_stm_ref0_angleBudget
								const_BalanceSTM_speedBudget = const_Segway_SegwayController_stm_ref0_speedBudget
								const_BalanceSTM_rotationBudget = const_Segway_SegwayController_stm_ref0_rotationBudget
								const_BalanceSTM_motorBudget = const_Segway_SegwayController_stm_ref0_motorBudget
								const_AnglePID_P = const_Segway_SegwayController_op_ref0_P
								const_AnglePID_D = const_Segway_SegwayController_op_ref0_D
								const_SpeedPID_P = const_Segway_SegwayController_op_ref1_P
								const_SpeedPID_I = const_Segway_SegwayController_op_ref1_I
								const_SpeedPID_maxIntegral = const_Segway_SegwayController_op_ref1_maxIntegral
								const_RotationPID_D = const_Segway_SegwayController_op_ref2_D
							within 
							stm_ref0::VS_O__(id__,
									    const_BalanceSTM_maxAngle,
									    const_BalanceSTM_loopTime,
									    const_BalanceSTM_startupDelay,
									    const_BalanceSTM_speedUpdate,
									    const_BalanceSTM_rotationUpdate,
									    const_BalanceSTM_angleBudget,
									    const_BalanceSTM_speedBudget,
									    const_BalanceSTM_rotationBudget,
									    const_BalanceSTM_motorBudget,
									    const_AnglePID_P,
									    const_AnglePID_D,
									    const_SpeedPID_P,
									    const_SpeedPID_I,
									    const_SpeedPID_maxIntegral,
									    const_RotationPID_D)[[
								stm_ref0::terminate <- terminate,
								stm_ref0::leftMotorVelocity <- leftMotorVelocity,
								stm_ref0::rightMotorVelocity <- rightMotorVelocity,
								stm_ref0::angle <- angle,
								stm_ref0::gyroX <- gyroX,
								stm_ref0::gyroY <- gyroY,
								stm_ref0::gyroZ <- gyroZ,
								stm_ref0::setLeftMotorSpeedCall <- setLeftMotorSpeedCall,
								stm_ref0::enableInterruptsCall <- enableInterruptsCall,
								stm_ref0::setRightMotorSpeedCall <- setRightMotorSpeedCall,
								stm_ref0::disableInterruptsCall <- disableInterruptsCall
							]]
						)
							[|
								union(
									{|
									|},
									{|
									|}
								)
							|]
						dbisim(Memory(id__))
					)
					\ union(
						{|
						|},
						{|
						|}
					)
					[|{|terminate|}|>SKIP
					,<union(visibleMemoryEvents,{terminate}),{tock}>))
				
					HEXT(id__,
							    const_Segway_SegwayController_stm_ref0_maxAngle,
							    const_Segway_SegwayController_stm_ref0_loopTime,
							    const_Segway_SegwayController_stm_ref0_startupDelay,
							    const_Segway_SegwayController_stm_ref0_speedUpdate,
							    const_Segway_SegwayController_stm_ref0_rotationUpdate,
							    const_Segway_SegwayController_stm_ref0_angleBudget,
							    const_Segway_SegwayController_stm_ref0_speedBudget,
							    const_Segway_SegwayController_stm_ref0_rotationBudget,
							    const_Segway_SegwayController_stm_ref0_motorBudget,
							   	const_Segway_SegwayController_op_ref0_P,
							   	const_Segway_SegwayController_op_ref0_D,
							   	const_Segway_SegwayController_op_ref1_P,
							   	const_Segway_SegwayController_op_ref1_I,
							   	const_Segway_SegwayController_op_ref1_maxIntegral,
							   	const_Segway_SegwayController_op_ref2_D) = O__(id__,
							    const_Segway_SegwayController_stm_ref0_maxAngle,
							    const_Segway_SegwayController_stm_ref0_loopTime,
							    const_Segway_SegwayController_stm_ref0_startupDelay,
							    const_Segway_SegwayController_stm_ref0_speedUpdate,
							    const_Segway_SegwayController_stm_ref0_rotationUpdate,
							    const_Segway_SegwayController_stm_ref0_angleBudget,
							    const_Segway_SegwayController_stm_ref0_speedBudget,
							    const_Segway_SegwayController_stm_ref0_rotationBudget,
							    const_Segway_SegwayController_stm_ref0_motorBudget,
							   	const_Segway_SegwayController_op_ref0_P,
							   	const_Segway_SegwayController_op_ref0_D,
							   	const_Segway_SegwayController_op_ref1_P,
							   	const_Segway_SegwayController_op_ref1_I,
							   	const_Segway_SegwayController_op_ref1_maxIntegral,
							   	const_Segway_SegwayController_op_ref2_D) [|shared_variable_events|] SKIP			
			}
	
		endmodule
	
	Timed(OneStep) {
		visibleMemoryEvents = {||}
		
		-- declaring module memory
		Memory(id__) = SKIP
		
		D__(id__,
				    const_Segway_SegwayController_stm_ref0_maxAngle,
				    const_Segway_SegwayController_stm_ref0_loopTime,
				    const_Segway_SegwayController_stm_ref0_startupDelay,
				    const_Segway_SegwayController_stm_ref0_speedUpdate,
				    const_Segway_SegwayController_stm_ref0_rotationUpdate,
				    const_Segway_SegwayController_stm_ref0_angleBudget,
				    const_Segway_SegwayController_stm_ref0_speedBudget,
				    const_Segway_SegwayController_stm_ref0_rotationBudget,
				    const_Segway_SegwayController_stm_ref0_motorBudget,
				   	const_Segway_SegwayController_op_ref0_P,
				   	const_Segway_SegwayController_op_ref0_D,
				   	const_Segway_SegwayController_op_ref1_P,
				   	const_Segway_SegwayController_op_ref1_I,
				   	const_Segway_SegwayController_op_ref1_maxIntegral,
				   	const_Segway_SegwayController_op_ref2_D) = prioritise(	(
				(
					(SKIP)
						[|{||}|]
					(
						(
							SegwayController::D__(id__,
									    const_Segway_SegwayController_stm_ref0_maxAngle,
									    const_Segway_SegwayController_stm_ref0_loopTime,
									    const_Segway_SegwayController_stm_ref0_startupDelay,
									    const_Segway_SegwayController_stm_ref0_speedUpdate,
									    const_Segway_SegwayController_stm_ref0_rotationUpdate,
									    const_Segway_SegwayController_stm_ref0_angleBudget,
									    const_Segway_SegwayController_stm_ref0_speedBudget,
									    const_Segway_SegwayController_stm_ref0_rotationBudget,
									    const_Segway_SegwayController_stm_ref0_motorBudget,
									   	const_Segway_SegwayController_op_ref0_P,
									   	const_Segway_SegwayController_op_ref0_D,
									   	const_Segway_SegwayController_op_ref1_P,
									   	const_Segway_SegwayController_op_ref1_I,
									   	const_Segway_SegwayController_op_ref1_maxIntegral,
									   	const_Segway_SegwayController_op_ref2_D)[[
								SegwayController::terminate <- terminate,
								SegwayController::angle <- angle,
								SegwayController::gyroX <- gyroX,
								SegwayController::gyroY <- gyroY,
								SegwayController::gyroZ <- gyroZ,
								SegwayController::leftMotorVelocity <- leftMotorVelocity,
								SegwayController::rightMotorVelocity <- rightMotorVelocity,
								SegwayController::setLeftMotorSpeedCall <- setLeftMotorSpeedCall,
								SegwayController::enableInterruptsCall <- enableInterruptsCall,
								SegwayController::setRightMotorSpeedCall <- setRightMotorSpeedCall,
								SegwayController::disableInterruptsCall <- disableInterruptsCall
							]]
						)
							[|
								union(
									{|
									|},
									{|
									|}
								)
							|]
						Memory(id__)
					)
				)
				\ Union({
					{|
					|},
					{|
					|},
					{|
					|}
				})
				[|{|terminate|}|>SKIP
			)
			\{|terminate|}
		,<visibleMemoryEvents,{tock}>)
		
		-- visible state equivalent
		
		VS__(id__,
				    const_Segway_SegwayController_stm_ref0_maxAngle,
				    const_Segway_SegwayController_stm_ref0_loopTime,
				    const_Segway_SegwayController_stm_ref0_startupDelay,
				    const_Segway_SegwayController_stm_ref0_speedUpdate,
				    const_Segway_SegwayController_stm_ref0_rotationUpdate,
				    const_Segway_SegwayController_stm_ref0_angleBudget,
				    const_Segway_SegwayController_stm_ref0_speedBudget,
				    const_Segway_SegwayController_stm_ref0_rotationBudget,
				    const_Segway_SegwayController_stm_ref0_motorBudget,
				   	const_Segway_SegwayController_op_ref0_P,
				   	const_Segway_SegwayController_op_ref0_D,
				   	const_Segway_SegwayController_op_ref1_P,
				   	const_Segway_SegwayController_op_ref1_I,
				   	const_Segway_SegwayController_op_ref1_maxIntegral,
				   	const_Segway_SegwayController_op_ref2_D) = prioritise(	(
				(
					(SKIP)
						[|{||}|]
					(
						(
							SegwayController::VS__(id__,
									    const_Segway_SegwayController_stm_ref0_maxAngle,
									    const_Segway_SegwayController_stm_ref0_loopTime,
									    const_Segway_SegwayController_stm_ref0_startupDelay,
									    const_Segway_SegwayController_stm_ref0_speedUpdate,
									    const_Segway_SegwayController_stm_ref0_rotationUpdate,
									    const_Segway_SegwayController_stm_ref0_angleBudget,
									    const_Segway_SegwayController_stm_ref0_speedBudget,
									    const_Segway_SegwayController_stm_ref0_rotationBudget,
									    const_Segway_SegwayController_stm_ref0_motorBudget,
									   	const_Segway_SegwayController_op_ref0_P,
									   	const_Segway_SegwayController_op_ref0_D,
									   	const_Segway_SegwayController_op_ref1_P,
									   	const_Segway_SegwayController_op_ref1_I,
									   	const_Segway_SegwayController_op_ref1_maxIntegral,
									   	const_Segway_SegwayController_op_ref2_D)[[
								SegwayController::terminate <- terminate,
								SegwayController::angle <- angle,
								SegwayController::gyroX <- gyroX,
								SegwayController::gyroY <- gyroY,
								SegwayController::gyroZ <- gyroZ,
								SegwayController::leftMotorVelocity <- leftMotorVelocity,
								SegwayController::rightMotorVelocity <- rightMotorVelocity,
								SegwayController::setLeftMotorSpeedCall <- setLeftMotorSpeedCall,
								SegwayController::enableInterruptsCall <- enableInterruptsCall,
								SegwayController::setRightMotorSpeedCall <- setRightMotorSpeedCall,
								SegwayController::disableInterruptsCall <- disableInterruptsCall
							]]
						)
							[|
								union(
									{|
									|},
									{|
									|}
								)
							|]
						Memory(id__)
					)
				)
				\ Union({
					{|
					|},
					{|
					|},
					{|
					|}
				})
				[|{|terminate|}|>SKIP
			)
			\{|terminate|}
		,<visibleMemoryEvents,{tock}>)
		
		-- O version (optimised)
		
		O__(id__,
				    const_Segway_SegwayController_stm_ref0_maxAngle,
				    const_Segway_SegwayController_stm_ref0_loopTime,
				    const_Segway_SegwayController_stm_ref0_startupDelay,
				    const_Segway_SegwayController_stm_ref0_speedUpdate,
				    const_Segway_SegwayController_stm_ref0_rotationUpdate,
				    const_Segway_SegwayController_stm_ref0_angleBudget,
				    const_Segway_SegwayController_stm_ref0_speedBudget,
				    const_Segway_SegwayController_stm_ref0_rotationBudget,
				    const_Segway_SegwayController_stm_ref0_motorBudget,
				   	const_Segway_SegwayController_op_ref0_P,
				   	const_Segway_SegwayController_op_ref0_D,
				   	const_Segway_SegwayController_op_ref1_P,
				   	const_Segway_SegwayController_op_ref1_I,
				   	const_Segway_SegwayController_op_ref1_maxIntegral,
				   	const_Segway_SegwayController_op_ref2_D) = dbisim(prioritise(	(
				(
					(SKIP)
						[|{||}|]
					(
						(
							SegwayController::O__(id__,
									    const_Segway_SegwayController_stm_ref0_maxAngle,
									    const_Segway_SegwayController_stm_ref0_loopTime,
									    const_Segway_SegwayController_stm_ref0_startupDelay,
									    const_Segway_SegwayController_stm_ref0_speedUpdate,
									    const_Segway_SegwayController_stm_ref0_rotationUpdate,
									    const_Segway_SegwayController_stm_ref0_angleBudget,
									    const_Segway_SegwayController_stm_ref0_speedBudget,
									    const_Segway_SegwayController_stm_ref0_rotationBudget,
									    const_Segway_SegwayController_stm_ref0_motorBudget,
									   	const_Segway_SegwayController_op_ref0_P,
									   	const_Segway_SegwayController_op_ref0_D,
									   	const_Segway_SegwayController_op_ref1_P,
									   	const_Segway_SegwayController_op_ref1_I,
									   	const_Segway_SegwayController_op_ref1_maxIntegral,
									   	const_Segway_SegwayController_op_ref2_D)[[
								SegwayController::terminate <- terminate,
								SegwayController::angle <- angle,
								SegwayController::gyroX <- gyroX,
								SegwayController::gyroY <- gyroY,
								SegwayController::gyroZ <- gyroZ,
								SegwayController::leftMotorVelocity <- leftMotorVelocity,
								SegwayController::rightMotorVelocity <- rightMotorVelocity,
								SegwayController::setLeftMotorSpeedCall <- setLeftMotorSpeedCall,
								SegwayController::enableInterruptsCall <- enableInterruptsCall,
								SegwayController::setRightMotorSpeedCall <- setRightMotorSpeedCall,
								SegwayController::disableInterruptsCall <- disableInterruptsCall
							]]
						)
							[|
								union(
									{|
									|},
									{|
									|}
								)
							|]
						dbisim(Memory(id__))
					)
				)
				\ Union({
					{|
					|},
					{|
					|},
					{|
					|}
				})
				[|{|terminate|}|>SKIP
			)
			\{|terminate|}
		,<visibleMemoryEvents,{tock}>))
		
		-- visible state optimised equivalent
		
		VS_O__(id__,
				    const_Segway_SegwayController_stm_ref0_maxAngle,
				    const_Segway_SegwayController_stm_ref0_loopTime,
				    const_Segway_SegwayController_stm_ref0_startupDelay,
				    const_Segway_SegwayController_stm_ref0_speedUpdate,
				    const_Segway_SegwayController_stm_ref0_rotationUpdate,
				    const_Segway_SegwayController_stm_ref0_angleBudget,
				    const_Segway_SegwayController_stm_ref0_speedBudget,
				    const_Segway_SegwayController_stm_ref0_rotationBudget,
				    const_Segway_SegwayController_stm_ref0_motorBudget,
				   	const_Segway_SegwayController_op_ref0_P,
				   	const_Segway_SegwayController_op_ref0_D,
				   	const_Segway_SegwayController_op_ref1_P,
				   	const_Segway_SegwayController_op_ref1_I,
				   	const_Segway_SegwayController_op_ref1_maxIntegral,
				   	const_Segway_SegwayController_op_ref2_D) = dbisim(prioritise(	(
				(
					(SKIP)
						[|{||}|]
					(
						(
							SegwayController::VS_O__(id__,
									    const_Segway_SegwayController_stm_ref0_maxAngle,
									    const_Segway_SegwayController_stm_ref0_loopTime,
									    const_Segway_SegwayController_stm_ref0_startupDelay,
									    const_Segway_SegwayController_stm_ref0_speedUpdate,
									    const_Segway_SegwayController_stm_ref0_rotationUpdate,
									    const_Segway_SegwayController_stm_ref0_angleBudget,
									    const_Segway_SegwayController_stm_ref0_speedBudget,
									    const_Segway_SegwayController_stm_ref0_rotationBudget,
									    const_Segway_SegwayController_stm_ref0_motorBudget,
									   	const_Segway_SegwayController_op_ref0_P,
									   	const_Segway_SegwayController_op_ref0_D,
									   	const_Segway_SegwayController_op_ref1_P,
									   	const_Segway_SegwayController_op_ref1_I,
									   	const_Segway_SegwayController_op_ref1_maxIntegral,
									   	const_Segway_SegwayController_op_ref2_D)[[
								SegwayController::terminate <- terminate,
								SegwayController::angle <- angle,
								SegwayController::gyroX <- gyroX,
								SegwayController::gyroY <- gyroY,
								SegwayController::gyroZ <- gyroZ,
								SegwayController::leftMotorVelocity <- leftMotorVelocity,
								SegwayController::rightMotorVelocity <- rightMotorVelocity,
								SegwayController::setLeftMotorSpeedCall <- setLeftMotorSpeedCall,
								SegwayController::enableInterruptsCall <- enableInterruptsCall,
								SegwayController::setRightMotorSpeedCall <- setRightMotorSpeedCall,
								SegwayController::disableInterruptsCall <- disableInterruptsCall
							]]
						)
							[|
								union(
									{|
									|},
									{|
									|}
								)
							|]
						dbisim(Memory(id__))
					)
				)
				\ Union({
					{|
					|},
					{|
					|},
					{|
					|}
				})
				[|{|terminate|}|>SKIP
			)
			\{|terminate|}
		,<visibleMemoryEvents,{tock}>))
		
		-- O version (optimised) with visible assignments
		
		AS_O__(id__,
				    const_Segway_SegwayController_stm_ref0_maxAngle,
				    const_Segway_SegwayController_stm_ref0_loopTime,
				    const_Segway_SegwayController_stm_ref0_startupDelay,
				    const_Segway_SegwayController_stm_ref0_speedUpdate,
				    const_Segway_SegwayController_stm_ref0_rotationUpdate,
				    const_Segway_SegwayController_stm_ref0_angleBudget,
				    const_Segway_SegwayController_stm_ref0_speedBudget,
				    const_Segway_SegwayController_stm_ref0_rotationBudget,
				    const_Segway_SegwayController_stm_ref0_motorBudget,
				   	const_Segway_SegwayController_op_ref0_P,
				   	const_Segway_SegwayController_op_ref0_D,
				   	const_Segway_SegwayController_op_ref1_P,
				   	const_Segway_SegwayController_op_ref1_I,
				   	const_Segway_SegwayController_op_ref1_maxIntegral,
				   	const_Segway_SegwayController_op_ref2_D) = dbisim(	(
				(
					(SKIP)
						[|{||}|]
					(
						(
							SegwayController::O__(id__,
									    const_Segway_SegwayController_stm_ref0_maxAngle,
									    const_Segway_SegwayController_stm_ref0_loopTime,
									    const_Segway_SegwayController_stm_ref0_startupDelay,
									    const_Segway_SegwayController_stm_ref0_speedUpdate,
									    const_Segway_SegwayController_stm_ref0_rotationUpdate,
									    const_Segway_SegwayController_stm_ref0_angleBudget,
									    const_Segway_SegwayController_stm_ref0_speedBudget,
									    const_Segway_SegwayController_stm_ref0_rotationBudget,
									    const_Segway_SegwayController_stm_ref0_motorBudget,
									   	const_Segway_SegwayController_op_ref0_P,
									   	const_Segway_SegwayController_op_ref0_D,
									   	const_Segway_SegwayController_op_ref1_P,
									   	const_Segway_SegwayController_op_ref1_I,
									   	const_Segway_SegwayController_op_ref1_maxIntegral,
									   	const_Segway_SegwayController_op_ref2_D)[[
								SegwayController::terminate <- terminate,
								SegwayController::angle <- angle,
								SegwayController::gyroX <- gyroX,
								SegwayController::gyroY <- gyroY,
								SegwayController::gyroZ <- gyroZ,
								SegwayController::leftMotorVelocity <- leftMotorVelocity,
								SegwayController::rightMotorVelocity <- rightMotorVelocity,
								SegwayController::setLeftMotorSpeedCall <- setLeftMotorSpeedCall,
								SegwayController::enableInterruptsCall <- enableInterruptsCall,
								SegwayController::setRightMotorSpeedCall <- setRightMotorSpeedCall,
								SegwayController::disableInterruptsCall <- disableInterruptsCall
							]]
						)
							[|
								union(
									{|
									|},
									{|
									|}
								)
							|]
						dbisim(Memory(id__))
					)
				)
				\ Union({
					{|
					|},
					{|
					|},
					{|
					|}
				})
				[|{|terminate|}|>SKIP
			)
			\{|terminate|}
		)
	}
	
endmodule
