
--
-- RoboChart generator version 3.0.0.202306261132
-- Automatically generated on 22-08-2023 01:53:02
--
-- Iterated compression status: true
-- Assertions compression status: false
--

module Segway_P2
	exports
	
	transparent diamond
	transparent sbisim
	transparent dbisim
	transparent chase
	
	-- declaring channels
	-- declaring robotic platform events
	channel leftMotorVelocity: InOut.core_real
	channel rightMotorVelocity: InOut.core_real
	channel angle: InOut.core_real
	channel gyroX: InOut.core_real
	channel gyroY: InOut.core_real
	channel gyroZ: InOut.core_real
	
	channel setLeftMotorSpeedCall: core_real
	channel setRightMotorSpeedCall: core_real
	channel enableInterruptsCall
	channel disableInterruptsCall
	
	-- declaring module termination channel
	channel terminate
	
	-- declaring robotic platform variables
	
	-- channel set with all visible events
	sem__events = {|
		leftMotorVelocity,
		rightMotorVelocity,
		angle,
		gyroX,
		gyroY,
		gyroZ
	,	setLeftMotorSpeedCall,
		setRightMotorSpeedCall,
		enableInterruptsCall,
		disableInterruptsCall
	|}
	
	-- declaring controller
		module SegwayController
			shared_variable_events = {|
			|}
			
		exports
			transparent diamond
			transparent sbisim
			transparent dbisim
			transparent chase
	
			-- declaring controller events
			channel leftMotorVelocity: InOut.core_real
			channel rightMotorVelocity: InOut.core_real
			channel angle: InOut.core_real
			channel gyroX: InOut.core_real
			channel gyroY: InOut.core_real
			channel gyroZ: InOut.core_real
			
			
			
			-- declaring call and ret events for undefined operations
			channel setLeftMotorSpeedCall: core_real
			channel enableInterruptsCall
			channel setRightMotorSpeedCall: core_real
			channel disableInterruptsCall
			
			-- declaring controller termination channel
			channel terminate
			
			-- channel set with all visible events
			sem__events = {|
				terminate
			,	leftMotorVelocity,
				rightMotorVelocity,
				angle,
				gyroX,
				gyroY,
				gyroZ
			,	setLeftMotorSpeedCall,
				enableInterruptsCall,
				setRightMotorSpeedCall,
				disableInterruptsCall
			|}
			
			-- set of visible memory events
			visibleMemoryEvents = {||}
	
			-- defined operations
		
			-- declaring machines
			module stm_ref0
			exports
				transparent diamond
				transparent sbisim
				transparent dbisim
				transparent chase
			
				-- Transition identifiers
				-- declaring identifiers of transitions
				datatype NIDS = 
				              NID_i0|
				              NID_Initialisation|
				              NID_WaitForNextIteration|
				              NID_Setup|
				              NID_ReceiveInput|
				              NID_SendSpeed|
				              NID_SendAngle|
				              NID_SendRotation|
				              NID_SetMotors|
				              NID_StopMotors|
				              NID_j2
				
				channel internal__ : NIDS
				
				-- Flow channels		
				channel interrupt
				channel exited
				channel exit
				channel terminate
				
				-- Variable channels
				channel get_currAngle, set_currAngle, setL_currAngle, setR_currAngle: core_real
				channel get_currGyroX, set_currGyroX, setL_currGyroX, setR_currGyroX: core_real
				channel get_currGyroY, set_currGyroY, setL_currGyroY, setR_currGyroY: core_real
				channel get_currGyroZ, set_currGyroZ, setL_currGyroZ, setR_currGyroZ: core_real
				channel get_currLeftVel, set_currLeftVel, setL_currLeftVel, setR_currLeftVel: core_real
				channel get_currRightVel, set_currRightVel, setL_currRightVel, setR_currRightVel: core_real
				channel get_speedCount, set_speedCount, setL_speedCount, setR_speedCount: core_nat
				channel get_rotationCount, set_rotationCount, setL_rotationCount, setR_rotationCount: core_nat
				channel get_angleOutput, set_angleOutput, setL_angleOutput, setR_angleOutput: core_real
				channel get_speedOutput, set_speedOutput, setL_speedOutput, setR_speedOutput: core_real
				channel get_rotationOutput, set_rotationOutput, setL_rotationOutput, setR_rotationOutput: core_real
				channel get_speedSent, set_speedSent, setL_speedSent, setR_speedSent: core_boolean
				channel get_angleSent, set_angleSent, setL_angleSent, setR_angleSent: core_boolean
				channel get_rotationSent, set_rotationSent, setL_rotationSent, setR_rotationSent: core_boolean
				channel get_angleReceived, set_angleReceived, setL_angleReceived, setR_angleReceived: core_boolean
				channel get_speedIntegral, set_speedIntegral, setL_speedIntegral, setR_speedIntegral: core_real
				
				-- Shared variable channels
				
				-- Local variable channels for defined operations that are required by the state machine
				
				-- Declaring state machine events
				channel leftMotorVelocity__: NIDS.InOut.core_real
				channel leftMotorVelocity: InOut.core_real
				channel rightMotorVelocity__: NIDS.InOut.core_real
				channel rightMotorVelocity: InOut.core_real
				channel angle__: NIDS.InOut.core_real
				channel angle: InOut.core_real
				channel gyroX__: NIDS.InOut.core_real
				channel gyroX: InOut.core_real
				channel gyroY__: NIDS.InOut.core_real
				channel gyroY: InOut.core_real
				channel gyroZ__: NIDS.InOut.core_real
				channel gyroZ: InOut.core_real
				channel angleOutputE__: NIDS.InOut.core_real
				channel angleOutputE: InOut.core_real
				channel anewError__: NIDS.InOut.core_real
				channel anewError: InOut.core_real
				channel adiff__: NIDS.InOut.core_real
				channel adiff: InOut.core_real
				channel snewError__: NIDS.InOut.core_real
				channel snewError: InOut.core_real
				channel speedOutputE__: NIDS.InOut.core_real
				channel speedOutputE: InOut.core_real
				channel rdiff__: NIDS.InOut.core_real
				channel rdiff: InOut.core_real
				channel rotationOutputE__: NIDS.InOut.core_real
				channel rotationOutputE: InOut.core_real
				
				-- Declaring call and ret events for undefined operations
				channel setLeftMotorSpeedCall: core_real
				channel enableInterruptsCall
				channel setRightMotorSpeedCall: core_real
				channel disableInterruptsCall
				
				enterSS = {|
				i0::enter,
				Initialisation::enter,
				WaitForNextIteration::enter,
				Setup::enter,
				ReceiveInput::enter,
				SendSpeed::enter,
				SendAngle::enter,
				SendRotation::enter,
				SetMotors::enter,
				StopMotors::enter,
				j2::enter
				|}
				
				enteredSS = 	{|
				Initialisation::entered,
				WaitForNextIteration::entered,
				Setup::entered,
				ReceiveInput::entered,
				SendSpeed::entered,
				SendAngle::entered,
				SendRotation::entered,
				SetMotors::entered,
				StopMotors::entered
				|}
				
				internal_events = union(enteredSS,union(enterSS,{|interrupt,exited|}))
				
				shared_variable_events = {|
				|}
				
				-- channel set with all visible events
				sem__events = {|
					terminate
				,	leftMotorVelocity,
					rightMotorVelocity,
					angle,
					gyroX,
					gyroY,
					gyroZ,
					angleOutputE,
					anewError,
					adiff,
					snewError,
					speedOutputE,
					rdiff,
					rotationOutputE
				,	setLeftMotorSpeedCall,
					enableInterruptsCall,
					setRightMotorSpeedCall,
					disableInterruptsCall
					|}
				datatype ClockSet = 
					CLID_loopTimer
				
				channel clockReset, clockResetL, clockResetR : ClockSet
				
				localClockResets = {|clockReset.CLID_loopTimer|}
				
				
				channel get_CLID_StopMotors : core_clock_type 
				channel get_CLID_SendRotation : core_clock_type 
				channel get_CLID_loopTimer : core_clock_type 
				channel get_CLID_SendSpeed : core_clock_type 
				channel get_CLID_ReceiveInput : core_clock_type 
				channel get_CLID_Initialisation : core_clock_type 
				channel get_CLID_WaitForNextIteration : core_clock_type 
				channel get_CLID_SetMotors : core_clock_type 
				channel get_CLID_Setup : core_clock_type 
				channel get_CLID_SendAngle : core_clock_type 
				--channel increment__
				
				CLID_StopMotors_clock_type(id__,
						          const_BalanceSTM_P2_maxAngle,
						          const_BalanceSTM_P2_loopTime,
						          const_BalanceSTM_P2_startupDelay,
						          const_BalanceSTM_P2_speedUpdate,
						          const_BalanceSTM_P2_rotationUpdate,
						          const_BalanceSTM_P2_motorBudget,
						          const_BalanceSTM_P2_angleBudget,
						          const_BalanceSTM_P2_speedBudget,
						          const_BalanceSTM_P2_rotationBudget) = 
					let
						max = (clock_type_max(Union({
				{}
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_SendRotation_clock_type(id__,
						          const_BalanceSTM_P2_maxAngle,
						          const_BalanceSTM_P2_loopTime,
						          const_BalanceSTM_P2_startupDelay,
						          const_BalanceSTM_P2_speedUpdate,
						          const_BalanceSTM_P2_rotationUpdate,
						          const_BalanceSTM_P2_motorBudget,
						          const_BalanceSTM_P2_angleBudget,
						          const_BalanceSTM_P2_speedBudget,
						          const_BalanceSTM_P2_rotationBudget) = 
					let
						max = (clock_type_max(Union({
				{}
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_loopTimer_clock_type(id__,
						          const_BalanceSTM_P2_maxAngle,
						          const_BalanceSTM_P2_loopTime,
						          const_BalanceSTM_P2_startupDelay,
						          const_BalanceSTM_P2_speedUpdate,
						          const_BalanceSTM_P2_rotationUpdate,
						          const_BalanceSTM_P2_motorBudget,
						          const_BalanceSTM_P2_angleBudget,
						          const_BalanceSTM_P2_speedBudget,
						          const_BalanceSTM_P2_rotationBudget) = 
					let
						max = (clock_type_max(Union({
				{},
				({const_BalanceSTM_P2_loopTime|loopTime <- core_real})
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_SendSpeed_clock_type(id__,
						          const_BalanceSTM_P2_maxAngle,
						          const_BalanceSTM_P2_loopTime,
						          const_BalanceSTM_P2_startupDelay,
						          const_BalanceSTM_P2_speedUpdate,
						          const_BalanceSTM_P2_rotationUpdate,
						          const_BalanceSTM_P2_motorBudget,
						          const_BalanceSTM_P2_angleBudget,
						          const_BalanceSTM_P2_speedBudget,
						          const_BalanceSTM_P2_rotationBudget) = 
					let
						max = (clock_type_max(Union({
				{}
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_ReceiveInput_clock_type(id__,
						          const_BalanceSTM_P2_maxAngle,
						          const_BalanceSTM_P2_loopTime,
						          const_BalanceSTM_P2_startupDelay,
						          const_BalanceSTM_P2_speedUpdate,
						          const_BalanceSTM_P2_rotationUpdate,
						          const_BalanceSTM_P2_motorBudget,
						          const_BalanceSTM_P2_angleBudget,
						          const_BalanceSTM_P2_speedBudget,
						          const_BalanceSTM_P2_rotationBudget) = 
					let
						max = (clock_type_max(Union({
				{}
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_Initialisation_clock_type(id__,
						          const_BalanceSTM_P2_maxAngle,
						          const_BalanceSTM_P2_loopTime,
						          const_BalanceSTM_P2_startupDelay,
						          const_BalanceSTM_P2_speedUpdate,
						          const_BalanceSTM_P2_rotationUpdate,
						          const_BalanceSTM_P2_motorBudget,
						          const_BalanceSTM_P2_angleBudget,
						          const_BalanceSTM_P2_speedBudget,
						          const_BalanceSTM_P2_rotationBudget) = 
					let
						max = (clock_type_max(Union({
				{}
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_WaitForNextIteration_clock_type(id__,
						          const_BalanceSTM_P2_maxAngle,
						          const_BalanceSTM_P2_loopTime,
						          const_BalanceSTM_P2_startupDelay,
						          const_BalanceSTM_P2_speedUpdate,
						          const_BalanceSTM_P2_rotationUpdate,
						          const_BalanceSTM_P2_motorBudget,
						          const_BalanceSTM_P2_angleBudget,
						          const_BalanceSTM_P2_speedBudget,
						          const_BalanceSTM_P2_rotationBudget) = 
					let
						max = (clock_type_max(Union({
				{}
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_SetMotors_clock_type(id__,
						          const_BalanceSTM_P2_maxAngle,
						          const_BalanceSTM_P2_loopTime,
						          const_BalanceSTM_P2_startupDelay,
						          const_BalanceSTM_P2_speedUpdate,
						          const_BalanceSTM_P2_rotationUpdate,
						          const_BalanceSTM_P2_motorBudget,
						          const_BalanceSTM_P2_angleBudget,
						          const_BalanceSTM_P2_speedBudget,
						          const_BalanceSTM_P2_rotationBudget) = 
					let
						max = (clock_type_max(Union({
				{}
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_Setup_clock_type(id__,
						          const_BalanceSTM_P2_maxAngle,
						          const_BalanceSTM_P2_loopTime,
						          const_BalanceSTM_P2_startupDelay,
						          const_BalanceSTM_P2_speedUpdate,
						          const_BalanceSTM_P2_rotationUpdate,
						          const_BalanceSTM_P2_motorBudget,
						          const_BalanceSTM_P2_angleBudget,
						          const_BalanceSTM_P2_speedBudget,
						          const_BalanceSTM_P2_rotationBudget) = 
					let
						max = (clock_type_max(Union({
				{}
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_SendAngle_clock_type(id__,
						          const_BalanceSTM_P2_maxAngle,
						          const_BalanceSTM_P2_loopTime,
						          const_BalanceSTM_P2_startupDelay,
						          const_BalanceSTM_P2_speedUpdate,
						          const_BalanceSTM_P2_rotationUpdate,
						          const_BalanceSTM_P2_motorBudget,
						          const_BalanceSTM_P2_angleBudget,
						          const_BalanceSTM_P2_speedBudget,
						          const_BalanceSTM_P2_rotationBudget) = 
					let
						max = (clock_type_max(Union({
				{}
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				
			
					-- Nodes --
					-- declaring all nodes
					
					----------------------------------------------------------------------
					-- Initial: i0
					module i0
					exports
					
						channel enter, interrupt
						
						Timed(OneStep) {
							D__(id__,
									    const_BalanceSTM_P2_maxAngle,
									    const_BalanceSTM_P2_loopTime,
									    const_BalanceSTM_P2_startupDelay,
									    const_BalanceSTM_P2_speedUpdate,
									    const_BalanceSTM_P2_rotationUpdate,
									    const_BalanceSTM_P2_motorBudget,
									    const_BalanceSTM_P2_angleBudget,
									    const_BalanceSTM_P2_speedBudget,
									    const_BalanceSTM_P2_rotationBudget) = 
								dbisim(let
									Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
									
									Termination = terminate -> SKIP
									
									Active 		= share__choice(interrupt -> SKIP) ; Inactive
								within
									Inactive [| {terminate} |> SKIP)
							
							VS_O__(id__,
									    const_BalanceSTM_P2_maxAngle,
									    const_BalanceSTM_P2_loopTime,
									    const_BalanceSTM_P2_startupDelay,
									    const_BalanceSTM_P2_speedUpdate,
									    const_BalanceSTM_P2_rotationUpdate,
									    const_BalanceSTM_P2_motorBudget,
									    const_BalanceSTM_P2_angleBudget,
									    const_BalanceSTM_P2_speedBudget,
									    const_BalanceSTM_P2_rotationBudget) = D__(id__,
									    const_BalanceSTM_P2_maxAngle,
									    const_BalanceSTM_P2_loopTime,
									    const_BalanceSTM_P2_startupDelay,
									    const_BalanceSTM_P2_speedUpdate,
									    const_BalanceSTM_P2_rotationUpdate,
									    const_BalanceSTM_P2_motorBudget,
									    const_BalanceSTM_P2_angleBudget,
									    const_BalanceSTM_P2_speedBudget,
									    const_BalanceSTM_P2_rotationBudget)
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: Initialisation
					module Initialisation
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_BalanceSTM_P2_maxAngle,
									    const_BalanceSTM_P2_loopTime,
									    const_BalanceSTM_P2_startupDelay,
									    const_BalanceSTM_P2_speedUpdate,
									    const_BalanceSTM_P2_rotationUpdate,
									    const_BalanceSTM_P2_motorBudget,
									    const_BalanceSTM_P2_angleBudget,
									    const_BalanceSTM_P2_speedBudget,
									    const_BalanceSTM_P2_rotationBudget) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(true & (share__choice(set_speedCount!0 -> SKIP)));share__choice(true & (share__choice(set_rotationCount!0 -> SKIP)));SHARE_WAIT(const_BalanceSTM_P2_startupDelay);share__choice(clockReset.CLID_loopTimer -> SKIP);share__choice(true & (share__choice(set_speedSent!false -> SKIP)));share__choice(true & (share__choice(set_angleSent!false -> SKIP)));share__choice(true & (share__choice(set_rotationSent!false -> SKIP))) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_BalanceSTM_P2_maxAngle,
									    const_BalanceSTM_P2_loopTime,
									    const_BalanceSTM_P2_startupDelay,
									    const_BalanceSTM_P2_speedUpdate,
									    const_BalanceSTM_P2_rotationUpdate,
									    const_BalanceSTM_P2_motorBudget,
									    const_BalanceSTM_P2_angleBudget,
									    const_BalanceSTM_P2_speedBudget,
									    const_BalanceSTM_P2_rotationBudget) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(true & (share__choice(set_speedCount!0 -> SKIP)));share__choice(true & (share__choice(set_rotationCount!0 -> SKIP)));SHARE_WAIT(const_BalanceSTM_P2_startupDelay);share__choice(clockReset.CLID_loopTimer -> SKIP);share__choice(true & (share__choice(set_speedSent!false -> SKIP)));share__choice(true & (share__choice(set_angleSent!false -> SKIP)));share__choice(true & (share__choice(set_rotationSent!false -> SKIP))) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_BalanceSTM_P2_maxAngle,
									          const_BalanceSTM_P2_loopTime,
									          const_BalanceSTM_P2_startupDelay,
									          const_BalanceSTM_P2_speedUpdate,
									          const_BalanceSTM_P2_rotationUpdate,
									          const_BalanceSTM_P2_motorBudget,
									          const_BalanceSTM_P2_angleBudget,
									          const_BalanceSTM_P2_speedBudget,
									          const_BalanceSTM_P2_rotationBudget) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: WaitForNextIteration
					module WaitForNextIteration
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_BalanceSTM_P2_maxAngle,
									    const_BalanceSTM_P2_loopTime,
									    const_BalanceSTM_P2_startupDelay,
									    const_BalanceSTM_P2_speedUpdate,
									    const_BalanceSTM_P2_rotationUpdate,
									    const_BalanceSTM_P2_motorBudget,
									    const_BalanceSTM_P2_angleBudget,
									    const_BalanceSTM_P2_speedBudget,
									    const_BalanceSTM_P2_rotationBudget) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_BalanceSTM_P2_maxAngle,
									    const_BalanceSTM_P2_loopTime,
									    const_BalanceSTM_P2_startupDelay,
									    const_BalanceSTM_P2_speedUpdate,
									    const_BalanceSTM_P2_rotationUpdate,
									    const_BalanceSTM_P2_motorBudget,
									    const_BalanceSTM_P2_angleBudget,
									    const_BalanceSTM_P2_speedBudget,
									    const_BalanceSTM_P2_rotationBudget) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_BalanceSTM_P2_maxAngle,
									          const_BalanceSTM_P2_loopTime,
									          const_BalanceSTM_P2_startupDelay,
									          const_BalanceSTM_P2_speedUpdate,
									          const_BalanceSTM_P2_rotationUpdate,
									          const_BalanceSTM_P2_motorBudget,
									          const_BalanceSTM_P2_angleBudget,
									          const_BalanceSTM_P2_speedBudget,
									          const_BalanceSTM_P2_rotationBudget) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: Setup
					module Setup
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_BalanceSTM_P2_maxAngle,
									    const_BalanceSTM_P2_loopTime,
									    const_BalanceSTM_P2_startupDelay,
									    const_BalanceSTM_P2_speedUpdate,
									    const_BalanceSTM_P2_rotationUpdate,
									    const_BalanceSTM_P2_motorBudget,
									    const_BalanceSTM_P2_angleBudget,
									    const_BalanceSTM_P2_speedBudget,
									    const_BalanceSTM_P2_rotationBudget) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= true&CALL__enableInterrupts(
											id__,
										    const_BalanceSTM_P2_maxAngle,
										    const_BalanceSTM_P2_loopTime,
										    const_BalanceSTM_P2_startupDelay,
										    const_BalanceSTM_P2_speedUpdate,
										    const_BalanceSTM_P2_rotationUpdate,
										    const_BalanceSTM_P2_motorBudget,
										    const_BalanceSTM_P2_angleBudget,
										    const_BalanceSTM_P2_speedBudget,
										    const_BalanceSTM_P2_rotationBudget
										);share__choice(share__choice(get_rotationCount?rotationCount -> true & (share__choice(set_rotationCount!Plus(rotationCount, 1, core_nat) -> SKIP))));share__choice(share__choice(get_speedCount?speedCount -> true & (share__choice(set_speedCount!Plus(speedCount, 1, core_nat) -> SKIP))));share__choice(true & (share__choice(set_angleReceived!false -> SKIP))) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_BalanceSTM_P2_maxAngle,
									    const_BalanceSTM_P2_loopTime,
									    const_BalanceSTM_P2_startupDelay,
									    const_BalanceSTM_P2_speedUpdate,
									    const_BalanceSTM_P2_rotationUpdate,
									    const_BalanceSTM_P2_motorBudget,
									    const_BalanceSTM_P2_angleBudget,
									    const_BalanceSTM_P2_speedBudget,
									    const_BalanceSTM_P2_rotationBudget) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= true&CALL__enableInterrupts(
											id__,
										    const_BalanceSTM_P2_maxAngle,
										    const_BalanceSTM_P2_loopTime,
										    const_BalanceSTM_P2_startupDelay,
										    const_BalanceSTM_P2_speedUpdate,
										    const_BalanceSTM_P2_rotationUpdate,
										    const_BalanceSTM_P2_motorBudget,
										    const_BalanceSTM_P2_angleBudget,
										    const_BalanceSTM_P2_speedBudget,
										    const_BalanceSTM_P2_rotationBudget
										);share__choice(share__choice(get_rotationCount?rotationCount -> true & (share__choice(set_rotationCount!Plus(rotationCount, 1, core_nat) -> SKIP))));share__choice(share__choice(get_speedCount?speedCount -> true & (share__choice(set_speedCount!Plus(speedCount, 1, core_nat) -> SKIP))));share__choice(true & (share__choice(set_angleReceived!false -> SKIP))) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_BalanceSTM_P2_maxAngle,
									          const_BalanceSTM_P2_loopTime,
									          const_BalanceSTM_P2_startupDelay,
									          const_BalanceSTM_P2_speedUpdate,
									          const_BalanceSTM_P2_rotationUpdate,
									          const_BalanceSTM_P2_motorBudget,
									          const_BalanceSTM_P2_angleBudget,
									          const_BalanceSTM_P2_speedBudget,
									          const_BalanceSTM_P2_rotationBudget) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: ReceiveInput
					module ReceiveInput
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_BalanceSTM_P2_maxAngle,
									    const_BalanceSTM_P2_loopTime,
									    const_BalanceSTM_P2_startupDelay,
									    const_BalanceSTM_P2_speedUpdate,
									    const_BalanceSTM_P2_rotationUpdate,
									    const_BalanceSTM_P2_motorBudget,
									    const_BalanceSTM_P2_angleBudget,
									    const_BalanceSTM_P2_speedBudget,
									    const_BalanceSTM_P2_rotationBudget) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_BalanceSTM_P2_maxAngle,
									    const_BalanceSTM_P2_loopTime,
									    const_BalanceSTM_P2_startupDelay,
									    const_BalanceSTM_P2_speedUpdate,
									    const_BalanceSTM_P2_rotationUpdate,
									    const_BalanceSTM_P2_motorBudget,
									    const_BalanceSTM_P2_angleBudget,
									    const_BalanceSTM_P2_speedBudget,
									    const_BalanceSTM_P2_rotationBudget) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_BalanceSTM_P2_maxAngle,
									          const_BalanceSTM_P2_loopTime,
									          const_BalanceSTM_P2_startupDelay,
									          const_BalanceSTM_P2_speedUpdate,
									          const_BalanceSTM_P2_rotationUpdate,
									          const_BalanceSTM_P2_motorBudget,
									          const_BalanceSTM_P2_angleBudget,
									          const_BalanceSTM_P2_speedBudget,
									          const_BalanceSTM_P2_rotationBudget) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: SendSpeed
					module SendSpeed
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_BalanceSTM_P2_maxAngle,
									    const_BalanceSTM_P2_loopTime,
									    const_BalanceSTM_P2_startupDelay,
									    const_BalanceSTM_P2_speedUpdate,
									    const_BalanceSTM_P2_rotationUpdate,
									    const_BalanceSTM_P2_motorBudget,
									    const_BalanceSTM_P2_angleBudget,
									    const_BalanceSTM_P2_speedBudget,
									    const_BalanceSTM_P2_rotationBudget) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= Deadline(true&(share__choice(leftMotorVelocity.in?currLeftVel -> (SStop /\ set_currLeftVel!currLeftVel -> SKIP))),0);Deadline(true&(share__choice(rightMotorVelocity.in?currRightVel -> (SStop /\ set_currRightVel!currRightVel -> SKIP))),0);share__choice(get_currRightVel?currRightVel -> share__choice(get_currLeftVel?currLeftVel -> true&(share__choice(snewError.out!(Plus(currLeftVel, currRightVel, core_real)) -> SKIP))));share__choice(true & (share__choice(set_speedCount!0 -> SKIP)));SHARE_WAIT_INTERVAL({ x | x <- { 0..const_BalanceSTM_P2_speedBudget}, 0<= x, x <=const_BalanceSTM_P2_speedBudget}) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_BalanceSTM_P2_maxAngle,
									    const_BalanceSTM_P2_loopTime,
									    const_BalanceSTM_P2_startupDelay,
									    const_BalanceSTM_P2_speedUpdate,
									    const_BalanceSTM_P2_rotationUpdate,
									    const_BalanceSTM_P2_motorBudget,
									    const_BalanceSTM_P2_angleBudget,
									    const_BalanceSTM_P2_speedBudget,
									    const_BalanceSTM_P2_rotationBudget) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= Deadline(true&(share__choice(leftMotorVelocity.in?currLeftVel -> (SStop /\ set_currLeftVel!currLeftVel -> SKIP))),0);Deadline(true&(share__choice(rightMotorVelocity.in?currRightVel -> (SStop /\ set_currRightVel!currRightVel -> SKIP))),0);share__choice(get_currRightVel?currRightVel -> share__choice(get_currLeftVel?currLeftVel -> true&(share__choice(snewError.out!(Plus(currLeftVel, currRightVel, core_real)) -> SKIP))));share__choice(true & (share__choice(set_speedCount!0 -> SKIP)));SHARE_WAIT_INTERVAL({ x | x <- { 0..const_BalanceSTM_P2_speedBudget}, 0<= x, x <=const_BalanceSTM_P2_speedBudget}) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_BalanceSTM_P2_maxAngle,
									          const_BalanceSTM_P2_loopTime,
									          const_BalanceSTM_P2_startupDelay,
									          const_BalanceSTM_P2_speedUpdate,
									          const_BalanceSTM_P2_rotationUpdate,
									          const_BalanceSTM_P2_motorBudget,
									          const_BalanceSTM_P2_angleBudget,
									          const_BalanceSTM_P2_speedBudget,
									          const_BalanceSTM_P2_rotationBudget) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: SendAngle
					module SendAngle
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_BalanceSTM_P2_maxAngle,
									    const_BalanceSTM_P2_loopTime,
									    const_BalanceSTM_P2_startupDelay,
									    const_BalanceSTM_P2_speedUpdate,
									    const_BalanceSTM_P2_rotationUpdate,
									    const_BalanceSTM_P2_motorBudget,
									    const_BalanceSTM_P2_angleBudget,
									    const_BalanceSTM_P2_speedBudget,
									    const_BalanceSTM_P2_rotationBudget) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= Deadline(true&(share__choice(angle.in?currAngle -> (SStop /\ set_currAngle!currAngle -> SKIP))),0);Deadline(true&(share__choice(gyroX.in?currGyroX -> (SStop /\ set_currGyroX!currGyroX -> SKIP))),0);Deadline(share__choice(get_currAngle?currAngle -> true&(share__choice(anewError.out!currAngle -> SKIP))),0);Deadline(share__choice(get_currGyroX?currGyroX -> true&(share__choice(adiff.out!currGyroX -> SKIP))),0);SHARE_WAIT_INTERVAL({ x | x <- { 0..const_BalanceSTM_P2_angleBudget}, 0<= x, x <=const_BalanceSTM_P2_angleBudget}) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_BalanceSTM_P2_maxAngle,
									    const_BalanceSTM_P2_loopTime,
									    const_BalanceSTM_P2_startupDelay,
									    const_BalanceSTM_P2_speedUpdate,
									    const_BalanceSTM_P2_rotationUpdate,
									    const_BalanceSTM_P2_motorBudget,
									    const_BalanceSTM_P2_angleBudget,
									    const_BalanceSTM_P2_speedBudget,
									    const_BalanceSTM_P2_rotationBudget) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= Deadline(true&(share__choice(angle.in?currAngle -> (SStop /\ set_currAngle!currAngle -> SKIP))),0);Deadline(true&(share__choice(gyroX.in?currGyroX -> (SStop /\ set_currGyroX!currGyroX -> SKIP))),0);Deadline(share__choice(get_currAngle?currAngle -> true&(share__choice(anewError.out!currAngle -> SKIP))),0);Deadline(share__choice(get_currGyroX?currGyroX -> true&(share__choice(adiff.out!currGyroX -> SKIP))),0);SHARE_WAIT_INTERVAL({ x | x <- { 0..const_BalanceSTM_P2_angleBudget}, 0<= x, x <=const_BalanceSTM_P2_angleBudget}) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_BalanceSTM_P2_maxAngle,
									          const_BalanceSTM_P2_loopTime,
									          const_BalanceSTM_P2_startupDelay,
									          const_BalanceSTM_P2_speedUpdate,
									          const_BalanceSTM_P2_rotationUpdate,
									          const_BalanceSTM_P2_motorBudget,
									          const_BalanceSTM_P2_angleBudget,
									          const_BalanceSTM_P2_speedBudget,
									          const_BalanceSTM_P2_rotationBudget) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: SendRotation
					module SendRotation
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_BalanceSTM_P2_maxAngle,
									    const_BalanceSTM_P2_loopTime,
									    const_BalanceSTM_P2_startupDelay,
									    const_BalanceSTM_P2_speedUpdate,
									    const_BalanceSTM_P2_rotationUpdate,
									    const_BalanceSTM_P2_motorBudget,
									    const_BalanceSTM_P2_angleBudget,
									    const_BalanceSTM_P2_speedBudget,
									    const_BalanceSTM_P2_rotationBudget) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= Deadline(true&(share__choice(gyroZ.in?currGyroZ -> (SStop /\ set_currGyroZ!currGyroZ -> SKIP))),0);share__choice(get_currGyroZ?currGyroZ -> true&(share__choice(rdiff.out!currGyroZ -> SKIP)));share__choice(true & (share__choice(set_rotationCount!0 -> SKIP)));SHARE_WAIT_INTERVAL({ x | x <- { 0..const_BalanceSTM_P2_rotationBudget}, 0<= x, x <=const_BalanceSTM_P2_rotationBudget}) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_BalanceSTM_P2_maxAngle,
									    const_BalanceSTM_P2_loopTime,
									    const_BalanceSTM_P2_startupDelay,
									    const_BalanceSTM_P2_speedUpdate,
									    const_BalanceSTM_P2_rotationUpdate,
									    const_BalanceSTM_P2_motorBudget,
									    const_BalanceSTM_P2_angleBudget,
									    const_BalanceSTM_P2_speedBudget,
									    const_BalanceSTM_P2_rotationBudget) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= Deadline(true&(share__choice(gyroZ.in?currGyroZ -> (SStop /\ set_currGyroZ!currGyroZ -> SKIP))),0);share__choice(get_currGyroZ?currGyroZ -> true&(share__choice(rdiff.out!currGyroZ -> SKIP)));share__choice(true & (share__choice(set_rotationCount!0 -> SKIP)));SHARE_WAIT_INTERVAL({ x | x <- { 0..const_BalanceSTM_P2_rotationBudget}, 0<= x, x <=const_BalanceSTM_P2_rotationBudget}) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_BalanceSTM_P2_maxAngle,
									          const_BalanceSTM_P2_loopTime,
									          const_BalanceSTM_P2_startupDelay,
									          const_BalanceSTM_P2_speedUpdate,
									          const_BalanceSTM_P2_rotationUpdate,
									          const_BalanceSTM_P2_motorBudget,
									          const_BalanceSTM_P2_angleBudget,
									          const_BalanceSTM_P2_speedBudget,
									          const_BalanceSTM_P2_rotationBudget) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: SetMotors
					module SetMotors
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_BalanceSTM_P2_maxAngle,
									    const_BalanceSTM_P2_loopTime,
									    const_BalanceSTM_P2_startupDelay,
									    const_BalanceSTM_P2_speedUpdate,
									    const_BalanceSTM_P2_rotationUpdate,
									    const_BalanceSTM_P2_motorBudget,
									    const_BalanceSTM_P2_angleBudget,
									    const_BalanceSTM_P2_speedBudget,
									    const_BalanceSTM_P2_rotationBudget) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(get_rotationOutput?rotationOutput -> share__choice(get_speedOutput?speedOutput -> share__choice(get_angleOutput?angleOutput -> true&CALL__setLeftMotorSpeed(
											id__,
										    const_BalanceSTM_P2_maxAngle,
										    const_BalanceSTM_P2_loopTime,
										    const_BalanceSTM_P2_startupDelay,
										    const_BalanceSTM_P2_speedUpdate,
										    const_BalanceSTM_P2_rotationUpdate,
										    const_BalanceSTM_P2_motorBudget,
										    const_BalanceSTM_P2_angleBudget,
										    const_BalanceSTM_P2_speedBudget,
										    const_BalanceSTM_P2_rotationBudget,
											Minus(Plus(angleOutput, speedOutput, core_real), rotationOutput, core_real)
										))));share__choice(get_rotationOutput?rotationOutput -> share__choice(get_speedOutput?speedOutput -> share__choice(get_angleOutput?angleOutput -> true&CALL__setRightMotorSpeed(
											id__,
										    const_BalanceSTM_P2_maxAngle,
										    const_BalanceSTM_P2_loopTime,
										    const_BalanceSTM_P2_startupDelay,
										    const_BalanceSTM_P2_speedUpdate,
										    const_BalanceSTM_P2_rotationUpdate,
										    const_BalanceSTM_P2_motorBudget,
										    const_BalanceSTM_P2_angleBudget,
										    const_BalanceSTM_P2_speedBudget,
										    const_BalanceSTM_P2_rotationBudget,
											Plus(Plus(angleOutput, speedOutput, core_real), rotationOutput, core_real)
										))));SHARE_WAIT_INTERVAL({ x | x <- { 0..const_BalanceSTM_P2_motorBudget}, 0<= x, x <=const_BalanceSTM_P2_motorBudget}) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_BalanceSTM_P2_maxAngle,
									    const_BalanceSTM_P2_loopTime,
									    const_BalanceSTM_P2_startupDelay,
									    const_BalanceSTM_P2_speedUpdate,
									    const_BalanceSTM_P2_rotationUpdate,
									    const_BalanceSTM_P2_motorBudget,
									    const_BalanceSTM_P2_angleBudget,
									    const_BalanceSTM_P2_speedBudget,
									    const_BalanceSTM_P2_rotationBudget) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(get_rotationOutput?rotationOutput -> share__choice(get_speedOutput?speedOutput -> share__choice(get_angleOutput?angleOutput -> true&CALL__setLeftMotorSpeed(
											id__,
										    const_BalanceSTM_P2_maxAngle,
										    const_BalanceSTM_P2_loopTime,
										    const_BalanceSTM_P2_startupDelay,
										    const_BalanceSTM_P2_speedUpdate,
										    const_BalanceSTM_P2_rotationUpdate,
										    const_BalanceSTM_P2_motorBudget,
										    const_BalanceSTM_P2_angleBudget,
										    const_BalanceSTM_P2_speedBudget,
										    const_BalanceSTM_P2_rotationBudget,
											Minus(Plus(angleOutput, speedOutput, core_real), rotationOutput, core_real)
										))));share__choice(get_rotationOutput?rotationOutput -> share__choice(get_speedOutput?speedOutput -> share__choice(get_angleOutput?angleOutput -> true&CALL__setRightMotorSpeed(
											id__,
										    const_BalanceSTM_P2_maxAngle,
										    const_BalanceSTM_P2_loopTime,
										    const_BalanceSTM_P2_startupDelay,
										    const_BalanceSTM_P2_speedUpdate,
										    const_BalanceSTM_P2_rotationUpdate,
										    const_BalanceSTM_P2_motorBudget,
										    const_BalanceSTM_P2_angleBudget,
										    const_BalanceSTM_P2_speedBudget,
										    const_BalanceSTM_P2_rotationBudget,
											Plus(Plus(angleOutput, speedOutput, core_real), rotationOutput, core_real)
										))));SHARE_WAIT_INTERVAL({ x | x <- { 0..const_BalanceSTM_P2_motorBudget}, 0<= x, x <=const_BalanceSTM_P2_motorBudget}) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_BalanceSTM_P2_maxAngle,
									          const_BalanceSTM_P2_loopTime,
									          const_BalanceSTM_P2_startupDelay,
									          const_BalanceSTM_P2_speedUpdate,
									          const_BalanceSTM_P2_rotationUpdate,
									          const_BalanceSTM_P2_motorBudget,
									          const_BalanceSTM_P2_angleBudget,
									          const_BalanceSTM_P2_speedBudget,
									          const_BalanceSTM_P2_rotationBudget) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: StopMotors
					module StopMotors
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_BalanceSTM_P2_maxAngle,
									    const_BalanceSTM_P2_loopTime,
									    const_BalanceSTM_P2_startupDelay,
									    const_BalanceSTM_P2_speedUpdate,
									    const_BalanceSTM_P2_rotationUpdate,
									    const_BalanceSTM_P2_motorBudget,
									    const_BalanceSTM_P2_angleBudget,
									    const_BalanceSTM_P2_speedBudget,
									    const_BalanceSTM_P2_rotationBudget) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= true&CALL__setLeftMotorSpeed(
											id__,
										    const_BalanceSTM_P2_maxAngle,
										    const_BalanceSTM_P2_loopTime,
										    const_BalanceSTM_P2_startupDelay,
										    const_BalanceSTM_P2_speedUpdate,
										    const_BalanceSTM_P2_rotationUpdate,
										    const_BalanceSTM_P2_motorBudget,
										    const_BalanceSTM_P2_angleBudget,
										    const_BalanceSTM_P2_speedBudget,
										    const_BalanceSTM_P2_rotationBudget,
											0
										);true&CALL__setRightMotorSpeed(
											id__,
										    const_BalanceSTM_P2_maxAngle,
										    const_BalanceSTM_P2_loopTime,
										    const_BalanceSTM_P2_startupDelay,
										    const_BalanceSTM_P2_speedUpdate,
										    const_BalanceSTM_P2_rotationUpdate,
										    const_BalanceSTM_P2_motorBudget,
										    const_BalanceSTM_P2_angleBudget,
										    const_BalanceSTM_P2_speedBudget,
										    const_BalanceSTM_P2_rotationBudget,
											0
										);SHARE_WAIT_INTERVAL({ x | x <- { 0..const_BalanceSTM_P2_motorBudget}, 0<= x, x <=const_BalanceSTM_P2_motorBudget}) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_BalanceSTM_P2_maxAngle,
									    const_BalanceSTM_P2_loopTime,
									    const_BalanceSTM_P2_startupDelay,
									    const_BalanceSTM_P2_speedUpdate,
									    const_BalanceSTM_P2_rotationUpdate,
									    const_BalanceSTM_P2_motorBudget,
									    const_BalanceSTM_P2_angleBudget,
									    const_BalanceSTM_P2_speedBudget,
									    const_BalanceSTM_P2_rotationBudget) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= true&CALL__setLeftMotorSpeed(
											id__,
										    const_BalanceSTM_P2_maxAngle,
										    const_BalanceSTM_P2_loopTime,
										    const_BalanceSTM_P2_startupDelay,
										    const_BalanceSTM_P2_speedUpdate,
										    const_BalanceSTM_P2_rotationUpdate,
										    const_BalanceSTM_P2_motorBudget,
										    const_BalanceSTM_P2_angleBudget,
										    const_BalanceSTM_P2_speedBudget,
										    const_BalanceSTM_P2_rotationBudget,
											0
										);true&CALL__setRightMotorSpeed(
											id__,
										    const_BalanceSTM_P2_maxAngle,
										    const_BalanceSTM_P2_loopTime,
										    const_BalanceSTM_P2_startupDelay,
										    const_BalanceSTM_P2_speedUpdate,
										    const_BalanceSTM_P2_rotationUpdate,
										    const_BalanceSTM_P2_motorBudget,
										    const_BalanceSTM_P2_angleBudget,
										    const_BalanceSTM_P2_speedBudget,
										    const_BalanceSTM_P2_rotationBudget,
											0
										);SHARE_WAIT_INTERVAL({ x | x <- { 0..const_BalanceSTM_P2_motorBudget}, 0<= x, x <=const_BalanceSTM_P2_motorBudget}) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_BalanceSTM_P2_maxAngle,
									          const_BalanceSTM_P2_loopTime,
									          const_BalanceSTM_P2_startupDelay,
									          const_BalanceSTM_P2_speedUpdate,
									          const_BalanceSTM_P2_rotationUpdate,
									          const_BalanceSTM_P2_motorBudget,
									          const_BalanceSTM_P2_angleBudget,
									          const_BalanceSTM_P2_speedBudget,
									          const_BalanceSTM_P2_rotationBudget) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- Junction: j2
					module j2
					exports
					
						channel enter, interrupt
						
						Timed(OneStep) {
							D__(id__,
									    const_BalanceSTM_P2_maxAngle,
									    const_BalanceSTM_P2_loopTime,
									    const_BalanceSTM_P2_startupDelay,
									    const_BalanceSTM_P2_speedUpdate,
									    const_BalanceSTM_P2_rotationUpdate,
									    const_BalanceSTM_P2_motorBudget,
									    const_BalanceSTM_P2_angleBudget,
									    const_BalanceSTM_P2_speedBudget,
									    const_BalanceSTM_P2_rotationBudget) = 
								dbisim(let
									Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
									
									Active 		= share__choice(interrupt -> SKIP) ; Inactive
								within
									Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_BalanceSTM_P2_maxAngle,
									    const_BalanceSTM_P2_loopTime,
									    const_BalanceSTM_P2_startupDelay,
									    const_BalanceSTM_P2_speedUpdate,
									    const_BalanceSTM_P2_rotationUpdate,
									    const_BalanceSTM_P2_motorBudget,
									    const_BalanceSTM_P2_angleBudget,
									    const_BalanceSTM_P2_speedBudget,
									    const_BalanceSTM_P2_rotationBudget) = D__(id__,
									    const_BalanceSTM_P2_maxAngle,
									    const_BalanceSTM_P2_loopTime,
									    const_BalanceSTM_P2_startupDelay,
									    const_BalanceSTM_P2_speedUpdate,
									    const_BalanceSTM_P2_rotationUpdate,
									    const_BalanceSTM_P2_motorBudget,
									    const_BalanceSTM_P2_angleBudget,
									    const_BalanceSTM_P2_speedBudget,
									    const_BalanceSTM_P2_rotationBudget)
						}
					
					endmodule
					----------------------------------------------------------------------
					
					-- END of Nodes --
					
					Timed(OneStep) {
					-- Operation calls --
					-- Only the undefined operations are declared here.
					-- If the state machine is in isolation, all required operations will be undefined.
					-- If it is in the context of a controller, the required operations not provided by the
					-- controller will be declared here, and the defined operations will be defined in the
					-- context of the Controller module, and therefore within scope of the state machine module.
					CALL__setLeftMotorSpeed(id__,
							    const_BalanceSTM_P2_maxAngle,
							    const_BalanceSTM_P2_loopTime,
							    const_BalanceSTM_P2_startupDelay,
							    const_BalanceSTM_P2_speedUpdate,
							    const_BalanceSTM_P2_rotationUpdate,
							    const_BalanceSTM_P2_motorBudget,
							    const_BalanceSTM_P2_angleBudget,
							    const_BalanceSTM_P2_speedBudget,
							    const_BalanceSTM_P2_rotationBudget,
								param_speed) = EDeadline(setLeftMotorSpeedCall.param_speed,0)
					CALL__enableInterrupts(id__,
							    const_BalanceSTM_P2_maxAngle,
							    const_BalanceSTM_P2_loopTime,
							    const_BalanceSTM_P2_startupDelay,
							    const_BalanceSTM_P2_speedUpdate,
							    const_BalanceSTM_P2_rotationUpdate,
							    const_BalanceSTM_P2_motorBudget,
							    const_BalanceSTM_P2_angleBudget,
							    const_BalanceSTM_P2_speedBudget,
							    const_BalanceSTM_P2_rotationBudget) = EDeadline(enableInterruptsCall,0)
					CALL__setRightMotorSpeed(id__,
							    const_BalanceSTM_P2_maxAngle,
							    const_BalanceSTM_P2_loopTime,
							    const_BalanceSTM_P2_startupDelay,
							    const_BalanceSTM_P2_speedUpdate,
							    const_BalanceSTM_P2_rotationUpdate,
							    const_BalanceSTM_P2_motorBudget,
							    const_BalanceSTM_P2_angleBudget,
							    const_BalanceSTM_P2_speedBudget,
							    const_BalanceSTM_P2_rotationBudget,
								param_speed) = EDeadline(setRightMotorSpeedCall.param_speed,0)
					CALL__disableInterrupts(id__,
							    const_BalanceSTM_P2_maxAngle,
							    const_BalanceSTM_P2_loopTime,
							    const_BalanceSTM_P2_startupDelay,
							    const_BalanceSTM_P2_speedUpdate,
							    const_BalanceSTM_P2_rotationUpdate,
							    const_BalanceSTM_P2_motorBudget,
							    const_BalanceSTM_P2_angleBudget,
							    const_BalanceSTM_P2_speedBudget,
							    const_BalanceSTM_P2_rotationBudget) = EDeadline(disableInterruptsCall,0)
					
					-- END of Operation calls --
				
					-- STM processes
					STM(id__,
							    const_BalanceSTM_P2_maxAngle,
							    const_BalanceSTM_P2_loopTime,
							    const_BalanceSTM_P2_startupDelay,
							    const_BalanceSTM_P2_speedUpdate,
							    const_BalanceSTM_P2_rotationUpdate,
							    const_BalanceSTM_P2_motorBudget,
							    const_BalanceSTM_P2_angleBudget,
							    const_BalanceSTM_P2_speedBudget,
							    const_BalanceSTM_P2_rotationBudget) = prioritise(-- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
					( 
						(
							(
								(IteratedStateful(id__,
										    const_BalanceSTM_P2_maxAngle,
										    const_BalanceSTM_P2_loopTime,
										    const_BalanceSTM_P2_startupDelay,
										    const_BalanceSTM_P2_speedUpdate,
										    const_BalanceSTM_P2_rotationUpdate,
										    const_BalanceSTM_P2_motorBudget,
										    const_BalanceSTM_P2_angleBudget,
										    const_BalanceSTM_P2_speedBudget,
										    const_BalanceSTM_P2_rotationBudget) \ {terminate} ; share__choice(terminate -> SKIP))
							 	[[ share__ <- x__ | x__ <- {||} ]]
							)
						[| {share__} |]
						SKIP
						)
						[| union(sharedVarSync,{terminate}) |]
						dbisim(sharedVarMemory(id__,
								    const_BalanceSTM_P2_maxAngle,
								    const_BalanceSTM_P2_loopTime,
								    const_BalanceSTM_P2_startupDelay,
								    const_BalanceSTM_P2_speedUpdate,
								    const_BalanceSTM_P2_rotationUpdate,
								    const_BalanceSTM_P2_motorBudget,
								    const_BalanceSTM_P2_angleBudget,
								    const_BalanceSTM_P2_speedBudget,
								    const_BalanceSTM_P2_rotationBudget))
					)\sharedVarHide
					,<{terminate},{tock}>)
					
					STM_VS_O(id__,
							    const_BalanceSTM_P2_maxAngle,
							    const_BalanceSTM_P2_loopTime,
							    const_BalanceSTM_P2_startupDelay,
							    const_BalanceSTM_P2_speedUpdate,
							    const_BalanceSTM_P2_rotationUpdate,
							    const_BalanceSTM_P2_motorBudget,
							    const_BalanceSTM_P2_angleBudget,
							    const_BalanceSTM_P2_speedBudget,
							    const_BalanceSTM_P2_rotationBudget) = prioritise(-- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
					( 
						(
							(
								(IteratedStateful_VS_O(id__,
										    const_BalanceSTM_P2_maxAngle,
										    const_BalanceSTM_P2_loopTime,
										    const_BalanceSTM_P2_startupDelay,
										    const_BalanceSTM_P2_speedUpdate,
										    const_BalanceSTM_P2_rotationUpdate,
										    const_BalanceSTM_P2_motorBudget,
										    const_BalanceSTM_P2_angleBudget,
										    const_BalanceSTM_P2_speedBudget,
										    const_BalanceSTM_P2_rotationBudget) \ {terminate} ; share__choice(terminate -> SKIP))
							 	[[ share__ <- x__ | x__ <- {||} ]]
							)
						[| {share__} |]
						SKIP
						)
						[| union(sharedVarSync,{terminate}) |]
						dbisim(sharedVarMemory(id__,
								    const_BalanceSTM_P2_maxAngle,
								    const_BalanceSTM_P2_loopTime,
								    const_BalanceSTM_P2_startupDelay,
								    const_BalanceSTM_P2_speedUpdate,
								    const_BalanceSTM_P2_rotationUpdate,
								    const_BalanceSTM_P2_motorBudget,
								    const_BalanceSTM_P2_angleBudget,
								    const_BalanceSTM_P2_speedBudget,
								    const_BalanceSTM_P2_rotationBudget))
					)\sharedVarHide
					,<{terminate},{tock}>)
					
					-- Transitions
					Transitions(id__,
							    const_BalanceSTM_P2_maxAngle,
							    const_BalanceSTM_P2_loopTime,
							    const_BalanceSTM_P2_startupDelay,
							    const_BalanceSTM_P2_speedUpdate,
							    const_BalanceSTM_P2_rotationUpdate,
							    const_BalanceSTM_P2_motorBudget,
							    const_BalanceSTM_P2_angleBudget,
							    const_BalanceSTM_P2_speedBudget,
							    const_BalanceSTM_P2_rotationBudget) = ((let
						Trans = share__choice(get_angleReceived?angleReceived -> get_rotationCount?rotationCount -> get_CLID_loopTimer?loopTimer:CLID_loopTimer_clock_type(id__,
								          const_BalanceSTM_P2_maxAngle,
								          const_BalanceSTM_P2_loopTime,
								          const_BalanceSTM_P2_startupDelay,
								          const_BalanceSTM_P2_speedUpdate,
								          const_BalanceSTM_P2_rotationUpdate,
								          const_BalanceSTM_P2_motorBudget,
								          const_BalanceSTM_P2_angleBudget,
								          const_BalanceSTM_P2_speedBudget,
								          const_BalanceSTM_P2_rotationBudget) -> get_speedCount?speedCount -> get_speedSent?speedSent -> get_currAngle?currAngle -> get_rotationSent?rotationSent -> get_angleSent?angleSent -> TimeOut_1(
							 (share__ -> SKIP
							 [] dbisim((((((((angleReceived==true)) and ((speedSent==false))) and ((rotationSent==false))) and ((((speedCount==0)) or ((speedCount<const_BalanceSTM_P2_speedUpdate))))) and ((((rotationCount==0)) or ((rotationCount<const_BalanceSTM_P2_rotationUpdate))))))&(internal__!NID_ReceiveInput -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; j2::enter -> SKIP)))
							 [] dbisim((angleOutputE__!NID_ReceiveInput.in?angleOutput:{angleOutput|angleOutput <- core_real, (((angleSent==true) and (angleReceived==false)))} -> share__choice(set_angleOutput!angleOutput -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_angleSent!false -> SKIP)));share__choice(true & (share__choice(set_angleReceived!true -> SKIP))) ; ReceiveInput::enter -> SKIP)))
							 [] dbisim(((((angleSent==false) and ((angleReceived==false)))))&(internal__!NID_ReceiveInput -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; SendAngle::enter -> SKIP)))
							 [] dbisim((true)&(internal__!NID_SendAngle -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_angleSent!true -> SKIP))) ; ReceiveInput::enter -> SKIP)))
							 [] dbisim((speedOutputE__!NID_ReceiveInput.in?speedOutput:{speedOutput|speedOutput <- core_real, (speedSent==true)} -> share__choice(set_speedOutput!speedOutput -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_speedSent!false -> SKIP))) ; ReceiveInput::enter -> SKIP)))
							 [] dbisim((((((speedSent==false) and (((speedCount>=const_BalanceSTM_P2_speedUpdate) and (speedCount>0))))) and (angleReceived==true)))&(internal__!NID_ReceiveInput -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; SendSpeed::enter -> SKIP)))
							 [] dbisim((true)&(internal__!NID_SendSpeed -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_speedSent!true -> SKIP))) ; ReceiveInput::enter -> SKIP)))
							 [] dbisim((rotationOutputE__!NID_ReceiveInput.in?rotationOutput:{rotationOutput|rotationOutput <- core_real, (rotationSent==true)} -> share__choice(set_rotationOutput!rotationOutput -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_rotationSent!false -> SKIP))) ; ReceiveInput::enter -> SKIP)))
							 [] dbisim(((((((rotationSent==false) and (((rotationCount>=const_BalanceSTM_P2_rotationUpdate) and (rotationCount>0))))) and (angleReceived==true)) and ((((speedCount==0)) or ((speedCount<const_BalanceSTM_P2_speedUpdate))))))&(internal__!NID_ReceiveInput -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; SendRotation::enter -> SKIP)))
							 [] dbisim((true)&(internal__!NID_SendRotation -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_rotationSent!true -> SKIP))) ; ReceiveInput::enter -> SKIP)))
							 [] dbisim((true)&(internal__!NID_i0 -> SKIP ;  ((SKIP ; Initialisation::enter -> SKIP))))
							 [] dbisim((true)&(internal__!NID_Initialisation -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; WaitForNextIteration::enter -> SKIP)))
							 [] dbisim(((loopTimer>=const_BalanceSTM_P2_loopTime))&(internal__!NID_WaitForNextIteration -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; true&CALL__disableInterrupts(
							 			id__,
							 		    const_BalanceSTM_P2_maxAngle,
							 		    const_BalanceSTM_P2_loopTime,
							 		    const_BalanceSTM_P2_startupDelay,
							 		    const_BalanceSTM_P2_speedUpdate,
							 		    const_BalanceSTM_P2_rotationUpdate,
							 		    const_BalanceSTM_P2_motorBudget,
							 		    const_BalanceSTM_P2_angleBudget,
							 		    const_BalanceSTM_P2_speedBudget,
							 		    const_BalanceSTM_P2_rotationBudget
							 		) ; Setup::enter -> SKIP)))
							 [] dbisim((true)&(internal__!NID_Setup -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; ReceiveInput::enter -> SKIP)))
							 [] dbisim((((currAngle<=const_BalanceSTM_P2_maxAngle) and (currAngle>=Neg(const_BalanceSTM_P2_maxAngle, core_real))))&(internal__!NID_j2 -> SKIP ;  ((SKIP ; SetMotors::enter -> SKIP))))
							 [] dbisim((((currAngle>const_BalanceSTM_P2_maxAngle) or (currAngle<Neg(const_BalanceSTM_P2_maxAngle, core_real))))&(internal__!NID_j2 -> SKIP ;  ((SKIP ; StopMotors::enter -> SKIP))))
							 [] dbisim((true)&(internal__!NID_SetMotors -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; WaitForNextIteration::enter -> SKIP)))
							 [] dbisim((true)&(internal__!NID_StopMotors -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; WaitForNextIteration::enter -> SKIP)))
							 []
							 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
							 []
							 terminate -> SKIP
							 )
						,SKIP);Trans
						)
					within
						Trans [|{terminate}|> SKIP
					)
					)
					
					-- Stateful
					-- RULE: Stateful(stm:StateMachineBody) : CSPProcess
					
					-- Named process definitions
					MachineBody(id__,
							    const_BalanceSTM_P2_maxAngle,
							    const_BalanceSTM_P2_loopTime,
							    const_BalanceSTM_P2_startupDelay,
							    const_BalanceSTM_P2_speedUpdate,
							    const_BalanceSTM_P2_rotationUpdate,
							    const_BalanceSTM_P2_motorBudget,
							    const_BalanceSTM_P2_angleBudget,
							    const_BalanceSTM_P2_speedBudget,
							    const_BalanceSTM_P2_rotationBudget) = 
						dbisim((
						let
							finalNodesEntered = {||}
						within
							(dbisim((dbisim((let
								-- IMPLEMENTATION NOTE:
								-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
								-- modules for defining the semantics of each node.
								enterSS = {|
								i0::enter,
								Initialisation::enter,
								WaitForNextIteration::enter,
								Setup::enter,
								ReceiveInput::enter,
								SendSpeed::enter,
								SendAngle::enter,
								SendRotation::enter,
								SetMotors::enter,
								StopMotors::enter,
								j2::enter
								|}
								hideSet = union(enterSS,{|exit,exited,internal__|})
							within 
								((let
									-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
									-- because CSPM modules are used for the semantics of Node.
									flowevts = union(enterSS,{|exit,exited,interrupt|})
									transSync = {|internal__.NID_ReceiveInput,angleOutputE__.NID_ReceiveInput.in,internal__.NID_ReceiveInput,internal__.NID_SendAngle,speedOutputE__.NID_ReceiveInput.in,internal__.NID_ReceiveInput,internal__.NID_SendSpeed,rotationOutputE__.NID_ReceiveInput.in,internal__.NID_ReceiveInput,internal__.NID_SendRotation,internal__.NID_i0,internal__.NID_Initialisation,internal__.NID_WaitForNextIteration,internal__.NID_Setup,internal__.NID_j2,internal__.NID_j2,internal__.NID_SetMotors,internal__.NID_StopMotors|}
								within
									((
									 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
									   i0::D__(id__,
									   		    const_BalanceSTM_P2_maxAngle,
									   		    const_BalanceSTM_P2_loopTime,
									   		    const_BalanceSTM_P2_startupDelay,
									   		    const_BalanceSTM_P2_speedUpdate,
									   		    const_BalanceSTM_P2_rotationUpdate,
									   		    const_BalanceSTM_P2_motorBudget,
									   		    const_BalanceSTM_P2_angleBudget,
									   		    const_BalanceSTM_P2_speedBudget,
									   		    const_BalanceSTM_P2_rotationBudget)
									   [| { share__, terminate } |] (
									   Initialisation::D__(id__,
									   		    const_BalanceSTM_P2_maxAngle,
									   		    const_BalanceSTM_P2_loopTime,
									   		    const_BalanceSTM_P2_startupDelay,
									   		    const_BalanceSTM_P2_speedUpdate,
									   		    const_BalanceSTM_P2_rotationUpdate,
									   		    const_BalanceSTM_P2_motorBudget,
									   		    const_BalanceSTM_P2_angleBudget,
									   		    const_BalanceSTM_P2_speedBudget,
									   		    const_BalanceSTM_P2_rotationBudget)
									   [| { share__, terminate } |] (
									   WaitForNextIteration::D__(id__,
									   		    const_BalanceSTM_P2_maxAngle,
									   		    const_BalanceSTM_P2_loopTime,
									   		    const_BalanceSTM_P2_startupDelay,
									   		    const_BalanceSTM_P2_speedUpdate,
									   		    const_BalanceSTM_P2_rotationUpdate,
									   		    const_BalanceSTM_P2_motorBudget,
									   		    const_BalanceSTM_P2_angleBudget,
									   		    const_BalanceSTM_P2_speedBudget,
									   		    const_BalanceSTM_P2_rotationBudget)
									   [| { share__, terminate } |] (
									   Setup::D__(id__,
									   		    const_BalanceSTM_P2_maxAngle,
									   		    const_BalanceSTM_P2_loopTime,
									   		    const_BalanceSTM_P2_startupDelay,
									   		    const_BalanceSTM_P2_speedUpdate,
									   		    const_BalanceSTM_P2_rotationUpdate,
									   		    const_BalanceSTM_P2_motorBudget,
									   		    const_BalanceSTM_P2_angleBudget,
									   		    const_BalanceSTM_P2_speedBudget,
									   		    const_BalanceSTM_P2_rotationBudget)
									   [| { share__, terminate } |] (
									   ReceiveInput::D__(id__,
									   		    const_BalanceSTM_P2_maxAngle,
									   		    const_BalanceSTM_P2_loopTime,
									   		    const_BalanceSTM_P2_startupDelay,
									   		    const_BalanceSTM_P2_speedUpdate,
									   		    const_BalanceSTM_P2_rotationUpdate,
									   		    const_BalanceSTM_P2_motorBudget,
									   		    const_BalanceSTM_P2_angleBudget,
									   		    const_BalanceSTM_P2_speedBudget,
									   		    const_BalanceSTM_P2_rotationBudget)
									   [| { share__, terminate } |] (
									   SendSpeed::D__(id__,
									   		    const_BalanceSTM_P2_maxAngle,
									   		    const_BalanceSTM_P2_loopTime,
									   		    const_BalanceSTM_P2_startupDelay,
									   		    const_BalanceSTM_P2_speedUpdate,
									   		    const_BalanceSTM_P2_rotationUpdate,
									   		    const_BalanceSTM_P2_motorBudget,
									   		    const_BalanceSTM_P2_angleBudget,
									   		    const_BalanceSTM_P2_speedBudget,
									   		    const_BalanceSTM_P2_rotationBudget)
									   [| { share__, terminate } |] (
									   SendAngle::D__(id__,
									   		    const_BalanceSTM_P2_maxAngle,
									   		    const_BalanceSTM_P2_loopTime,
									   		    const_BalanceSTM_P2_startupDelay,
									   		    const_BalanceSTM_P2_speedUpdate,
									   		    const_BalanceSTM_P2_rotationUpdate,
									   		    const_BalanceSTM_P2_motorBudget,
									   		    const_BalanceSTM_P2_angleBudget,
									   		    const_BalanceSTM_P2_speedBudget,
									   		    const_BalanceSTM_P2_rotationBudget)
									   [| { share__, terminate } |] (
									   SendRotation::D__(id__,
									   		    const_BalanceSTM_P2_maxAngle,
									   		    const_BalanceSTM_P2_loopTime,
									   		    const_BalanceSTM_P2_startupDelay,
									   		    const_BalanceSTM_P2_speedUpdate,
									   		    const_BalanceSTM_P2_rotationUpdate,
									   		    const_BalanceSTM_P2_motorBudget,
									   		    const_BalanceSTM_P2_angleBudget,
									   		    const_BalanceSTM_P2_speedBudget,
									   		    const_BalanceSTM_P2_rotationBudget)
									   [| { share__, terminate } |] (
									   SetMotors::D__(id__,
									   		    const_BalanceSTM_P2_maxAngle,
									   		    const_BalanceSTM_P2_loopTime,
									   		    const_BalanceSTM_P2_startupDelay,
									   		    const_BalanceSTM_P2_speedUpdate,
									   		    const_BalanceSTM_P2_rotationUpdate,
									   		    const_BalanceSTM_P2_motorBudget,
									   		    const_BalanceSTM_P2_angleBudget,
									   		    const_BalanceSTM_P2_speedBudget,
									   		    const_BalanceSTM_P2_rotationBudget)
									   [| { share__, terminate } |] (
									   StopMotors::D__(id__,
									   		    const_BalanceSTM_P2_maxAngle,
									   		    const_BalanceSTM_P2_loopTime,
									   		    const_BalanceSTM_P2_startupDelay,
									   		    const_BalanceSTM_P2_speedUpdate,
									   		    const_BalanceSTM_P2_rotationUpdate,
									   		    const_BalanceSTM_P2_motorBudget,
									   		    const_BalanceSTM_P2_angleBudget,
									   		    const_BalanceSTM_P2_speedBudget,
									   		    const_BalanceSTM_P2_rotationBudget)
									   [| { share__, terminate } |] (
									   j2::D__(id__,
									   		    const_BalanceSTM_P2_maxAngle,
									   		    const_BalanceSTM_P2_loopTime,
									   		    const_BalanceSTM_P2_startupDelay,
									   		    const_BalanceSTM_P2_speedUpdate,
									   		    const_BalanceSTM_P2_rotationUpdate,
									   		    const_BalanceSTM_P2_motorBudget,
									   		    const_BalanceSTM_P2_angleBudget,
									   		    const_BalanceSTM_P2_speedBudget,
									   		    const_BalanceSTM_P2_rotationBudget)
									   )
									   )
									   )
									   )
									   )
									   )
									   )
									   )
									   )
									   )
									 )
									 [[Initialisation::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_Initialisation|}]]
									 [[WaitForNextIteration::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_WaitForNextIteration|}]]
									 [[Setup::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_Setup|}]]
									 [[ReceiveInput::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_ReceiveInput,angleOutputE__.NID_ReceiveInput.in,internal__.NID_ReceiveInput,speedOutputE__.NID_ReceiveInput.in,internal__.NID_ReceiveInput,rotationOutputE__.NID_ReceiveInput.in,internal__.NID_ReceiveInput|}]]
									 [[SendSpeed::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_SendSpeed|}]]
									 [[SendAngle::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_SendAngle|}]]
									 [[SendRotation::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_SendRotation|}]]
									 [[SetMotors::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_SetMotors|}]]
									 [[StopMotors::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_StopMotors|}]]
									 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
									 [[j2::interrupt <- x__ | x__ <- {|internal__.NID_j2,internal__.NID_j2|}]]
									 )
									  [[ share__ <- x__ | x__ <- {| share__,setR_speedOutput,setR_angleOutput,setR_rotationOutput |} ]] 
									  [[set_angleReceived <- setL_angleReceived,set_rotationCount <- setL_rotationCount,clockReset.CLID_loopTimer <- clockResetL.CLID_loopTimer,set_speedCount <- setL_speedCount,set_speedSent <- setL_speedSent,set_currAngle <- setL_currAngle,set_rotationSent <- setL_rotationSent,set_angleSent <- setL_angleSent]]
									 )
									 [| union(union(union(flowevts,transSync),{terminate}),{|share__
									 			,setL_angleReceived
									 			,setL_rotationCount
									 			,clockResetL.CLID_loopTimer
									 			,setL_speedCount
									 			,setL_speedSent
									 			,setL_currAngle
									 			,setL_rotationSent
									 			,setL_angleSent
									 			,setR_speedOutput
									 			 			,setR_angleOutput
									 			 			,setR_rotationOutput
									 			|}) |]
									 ((i0::enter -> Transitions(id__,
									 		    const_BalanceSTM_P2_maxAngle,
									 		    const_BalanceSTM_P2_loopTime,
									 		    const_BalanceSTM_P2_startupDelay,
									 		    const_BalanceSTM_P2_speedUpdate,
									 		    const_BalanceSTM_P2_rotationUpdate,
									 		    const_BalanceSTM_P2_motorBudget,
									 		    const_BalanceSTM_P2_angleBudget,
									 		    const_BalanceSTM_P2_speedBudget,
									 		    const_BalanceSTM_P2_rotationBudget))
									  [[ share__ <- x__ | x__ <- {| share__,setL_angleReceived,setL_rotationCount,clockResetL.CLID_loopTimer,setL_speedCount,setL_speedSent,setL_currAngle,setL_rotationSent,setL_angleSent |} ]]
									  [[set_speedOutput <- setR_speedOutput,set_angleOutput <- setR_angleOutput,set_rotationOutput <- setR_rotationOutput]]
									 )
									)[[setL_angleReceived <- set_angleReceived,setL_rotationCount <- set_rotationCount,clockResetL.CLID_loopTimer <- clockReset.CLID_loopTimer,setL_speedCount <- set_speedCount,setL_speedSent <- set_speedSent,setL_currAngle <- set_currAngle,setL_rotationSent <- set_rotationSent,setL_angleSent <- set_angleSent]]
									 [[setR_speedOutput <- set_speedOutput,setR_angleOutput <- set_angleOutput,setR_rotationOutput <- set_rotationOutput]]
									)
								)
								 \ hideSet)
								[[
									leftMotorVelocity__.x____ <- leftMotorVelocity,
									rightMotorVelocity__.x____ <- rightMotorVelocity,
									angle__.x____ <- angle,
									gyroX__.x____ <- gyroX,
									gyroY__.x____ <- gyroY,
									gyroZ__.x____ <- gyroZ,
									angleOutputE__.x____ <- angleOutputE,
									anewError__.x____ <- anewError,
									adiff__.x____ <- adiff,
									snewError__.x____ <- snewError,
									speedOutputE__.x____ <- speedOutputE,
									rdiff__.x____ <- rdiff,
									rotationOutputE__.x____ <- rotationOutputE
									| x____ <- NIDS
								]]
							)
							)
							 [| union(stateClockSync,{terminate}) |]
							 StateClocks(id__,
							 		          const_BalanceSTM_P2_maxAngle,
							 		          const_BalanceSTM_P2_loopTime,
							 		          const_BalanceSTM_P2_startupDelay,
							 		          const_BalanceSTM_P2_speedUpdate,
							 		          const_BalanceSTM_P2_rotationUpdate,
							 		          const_BalanceSTM_P2_motorBudget,
							 		          const_BalanceSTM_P2_angleBudget,
							 		          const_BalanceSTM_P2_speedBudget,
							 		          const_BalanceSTM_P2_rotationBudget)
							)\diff(stateClockSync,enteredSS))
							 [| {| interrupt |} |] SKIP)
						)
						)
					
					Behaviour(id__,
							    const_BalanceSTM_P2_maxAngle,
							    const_BalanceSTM_P2_loopTime,
							    const_BalanceSTM_P2_startupDelay,
							    const_BalanceSTM_P2_speedUpdate,
							    const_BalanceSTM_P2_rotationUpdate,
							    const_BalanceSTM_P2_motorBudget,
							    const_BalanceSTM_P2_angleBudget,
							    const_BalanceSTM_P2_speedBudget,
							    const_BalanceSTM_P2_rotationBudget) = 
						dbisim((let
							stateClockSync = {|get_CLID_StopMotors,StopMotors::entered,get_CLID_SendRotation,SendRotation::entered,get_CLID_SendSpeed,SendSpeed::entered,get_CLID_ReceiveInput,ReceiveInput::entered,get_CLID_Initialisation,Initialisation::entered,get_CLID_WaitForNextIteration,WaitForNextIteration::entered,get_CLID_SetMotors,SetMotors::entered,get_CLID_Setup,Setup::entered,get_CLID_SendAngle,SendAngle::entered|}
						 within
							(MachineBody(id__,
									    const_BalanceSTM_P2_maxAngle,
									    const_BalanceSTM_P2_loopTime,
									    const_BalanceSTM_P2_startupDelay,
									    const_BalanceSTM_P2_speedUpdate,
									    const_BalanceSTM_P2_rotationUpdate,
									    const_BalanceSTM_P2_motorBudget,
									    const_BalanceSTM_P2_angleBudget,
									    const_BalanceSTM_P2_speedBudget,
									    const_BalanceSTM_P2_rotationBudget) [| union(stateClockSync,{terminate}) |] StateClocks(id__,
									          const_BalanceSTM_P2_maxAngle,
									          const_BalanceSTM_P2_loopTime,
									          const_BalanceSTM_P2_startupDelay,
									          const_BalanceSTM_P2_speedUpdate,
									          const_BalanceSTM_P2_rotationUpdate,
									          const_BalanceSTM_P2_motorBudget,
									          const_BalanceSTM_P2_angleBudget,
									          const_BalanceSTM_P2_speedBudget,
									          const_BalanceSTM_P2_rotationBudget)) \ union(stateClockSync,enteredSS)
						)
						)
					
					IteratedBehaviour(id__,
							    const_BalanceSTM_P2_maxAngle,
							    const_BalanceSTM_P2_loopTime,
							    const_BalanceSTM_P2_startupDelay,
							    const_BalanceSTM_P2_speedUpdate,
							    const_BalanceSTM_P2_rotationUpdate,
							    const_BalanceSTM_P2_motorBudget,
							    const_BalanceSTM_P2_angleBudget,
							    const_BalanceSTM_P2_speedBudget,
							    const_BalanceSTM_P2_rotationBudget) = 
						dbisim((let
							stateClockSync = {|get_CLID_StopMotors,StopMotors::entered,get_CLID_SendRotation,SendRotation::entered,get_CLID_SendSpeed,SendSpeed::entered,get_CLID_ReceiveInput,ReceiveInput::entered,get_CLID_Initialisation,Initialisation::entered,get_CLID_WaitForNextIteration,WaitForNextIteration::entered,get_CLID_SetMotors,SetMotors::entered,get_CLID_Setup,Setup::entered,get_CLID_SendAngle,SendAngle::entered|}
						 within
							(dbisim(
								sbisim(
									dbisim(
										sbisim(
											dbisim(
												sbisim(
													dbisim(
														sbisim(
															dbisim(
																sbisim(
																	dbisim(
																		sbisim(
																			dbisim(
																				sbisim(
																					dbisim(
																						sbisim(
																							dbisim(
																								sbisim(
																									MachineBody(id__,
																											    const_BalanceSTM_P2_maxAngle,
																											    const_BalanceSTM_P2_loopTime,
																											    const_BalanceSTM_P2_startupDelay,
																											    const_BalanceSTM_P2_speedUpdate,
																											    const_BalanceSTM_P2_rotationUpdate,
																											    const_BalanceSTM_P2_motorBudget,
																											    const_BalanceSTM_P2_angleBudget,
																											    const_BalanceSTM_P2_speedBudget,
																											    const_BalanceSTM_P2_rotationBudget)
																									[| {|get_CLID_SendAngle,SendAngle::entered,terminate|} |]
																									dbisim(Clock_CLID_SendAngle(id__,0,
																											          const_BalanceSTM_P2_maxAngle,
																											          const_BalanceSTM_P2_loopTime,
																											          const_BalanceSTM_P2_startupDelay,
																											          const_BalanceSTM_P2_speedUpdate,
																											          const_BalanceSTM_P2_rotationUpdate,
																											          const_BalanceSTM_P2_motorBudget,
																											          const_BalanceSTM_P2_angleBudget,
																											          const_BalanceSTM_P2_speedBudget,
																											          const_BalanceSTM_P2_rotationBudget))
																								)\{|get_CLID_SendAngle|}
																							)
																							[| {|get_CLID_Setup,Setup::entered,terminate|} |]
																							dbisim(Clock_CLID_Setup(id__,0,
																									          const_BalanceSTM_P2_maxAngle,
																									          const_BalanceSTM_P2_loopTime,
																									          const_BalanceSTM_P2_startupDelay,
																									          const_BalanceSTM_P2_speedUpdate,
																									          const_BalanceSTM_P2_rotationUpdate,
																									          const_BalanceSTM_P2_motorBudget,
																									          const_BalanceSTM_P2_angleBudget,
																									          const_BalanceSTM_P2_speedBudget,
																									          const_BalanceSTM_P2_rotationBudget))
																						)\{|get_CLID_Setup|}
																					)
																					[| {|get_CLID_SetMotors,SetMotors::entered,terminate|} |]
																					dbisim(Clock_CLID_SetMotors(id__,0,
																							          const_BalanceSTM_P2_maxAngle,
																							          const_BalanceSTM_P2_loopTime,
																							          const_BalanceSTM_P2_startupDelay,
																							          const_BalanceSTM_P2_speedUpdate,
																							          const_BalanceSTM_P2_rotationUpdate,
																							          const_BalanceSTM_P2_motorBudget,
																							          const_BalanceSTM_P2_angleBudget,
																							          const_BalanceSTM_P2_speedBudget,
																							          const_BalanceSTM_P2_rotationBudget))
																				)\{|get_CLID_SetMotors|}
																			)
																			[| {|get_CLID_WaitForNextIteration,WaitForNextIteration::entered,terminate|} |]
																			dbisim(Clock_CLID_WaitForNextIteration(id__,0,
																					          const_BalanceSTM_P2_maxAngle,
																					          const_BalanceSTM_P2_loopTime,
																					          const_BalanceSTM_P2_startupDelay,
																					          const_BalanceSTM_P2_speedUpdate,
																					          const_BalanceSTM_P2_rotationUpdate,
																					          const_BalanceSTM_P2_motorBudget,
																					          const_BalanceSTM_P2_angleBudget,
																					          const_BalanceSTM_P2_speedBudget,
																					          const_BalanceSTM_P2_rotationBudget))
																		)\{|get_CLID_WaitForNextIteration|}
																	)
																	[| {|get_CLID_Initialisation,Initialisation::entered,terminate|} |]
																	dbisim(Clock_CLID_Initialisation(id__,0,
																			          const_BalanceSTM_P2_maxAngle,
																			          const_BalanceSTM_P2_loopTime,
																			          const_BalanceSTM_P2_startupDelay,
																			          const_BalanceSTM_P2_speedUpdate,
																			          const_BalanceSTM_P2_rotationUpdate,
																			          const_BalanceSTM_P2_motorBudget,
																			          const_BalanceSTM_P2_angleBudget,
																			          const_BalanceSTM_P2_speedBudget,
																			          const_BalanceSTM_P2_rotationBudget))
																)\{|get_CLID_Initialisation|}
															)
															[| {|get_CLID_ReceiveInput,ReceiveInput::entered,terminate|} |]
															dbisim(Clock_CLID_ReceiveInput(id__,0,
																	          const_BalanceSTM_P2_maxAngle,
																	          const_BalanceSTM_P2_loopTime,
																	          const_BalanceSTM_P2_startupDelay,
																	          const_BalanceSTM_P2_speedUpdate,
																	          const_BalanceSTM_P2_rotationUpdate,
																	          const_BalanceSTM_P2_motorBudget,
																	          const_BalanceSTM_P2_angleBudget,
																	          const_BalanceSTM_P2_speedBudget,
																	          const_BalanceSTM_P2_rotationBudget))
														)\{|get_CLID_ReceiveInput|}
													)
													[| {|get_CLID_SendSpeed,SendSpeed::entered,terminate|} |]
													dbisim(Clock_CLID_SendSpeed(id__,0,
															          const_BalanceSTM_P2_maxAngle,
															          const_BalanceSTM_P2_loopTime,
															          const_BalanceSTM_P2_startupDelay,
															          const_BalanceSTM_P2_speedUpdate,
															          const_BalanceSTM_P2_rotationUpdate,
															          const_BalanceSTM_P2_motorBudget,
															          const_BalanceSTM_P2_angleBudget,
															          const_BalanceSTM_P2_speedBudget,
															          const_BalanceSTM_P2_rotationBudget))
												)\{|get_CLID_SendSpeed|}
											)
											[| {|get_CLID_SendRotation,SendRotation::entered,terminate|} |]
											dbisim(Clock_CLID_SendRotation(id__,0,
													          const_BalanceSTM_P2_maxAngle,
													          const_BalanceSTM_P2_loopTime,
													          const_BalanceSTM_P2_startupDelay,
													          const_BalanceSTM_P2_speedUpdate,
													          const_BalanceSTM_P2_rotationUpdate,
													          const_BalanceSTM_P2_motorBudget,
													          const_BalanceSTM_P2_angleBudget,
													          const_BalanceSTM_P2_speedBudget,
													          const_BalanceSTM_P2_rotationBudget))
										)\{|get_CLID_SendRotation|}
									)
									[| {|get_CLID_StopMotors,StopMotors::entered,terminate|} |]
									dbisim(Clock_CLID_StopMotors(id__,0,
											          const_BalanceSTM_P2_maxAngle,
											          const_BalanceSTM_P2_loopTime,
											          const_BalanceSTM_P2_startupDelay,
											          const_BalanceSTM_P2_speedUpdate,
											          const_BalanceSTM_P2_rotationUpdate,
											          const_BalanceSTM_P2_motorBudget,
											          const_BalanceSTM_P2_angleBudget,
											          const_BalanceSTM_P2_speedBudget,
											          const_BalanceSTM_P2_rotationBudget))
								)\{|get_CLID_StopMotors|}
							)
							) \ union(stateClockSync,enteredSS)
						)
						)
					
					Stateful(id__,
							    const_BalanceSTM_P2_maxAngle,
							    const_BalanceSTM_P2_loopTime,
							    const_BalanceSTM_P2_startupDelay,
							    const_BalanceSTM_P2_speedUpdate,
							    const_BalanceSTM_P2_rotationUpdate,
							    const_BalanceSTM_P2_motorBudget,
							    const_BalanceSTM_P2_angleBudget,
							    const_BalanceSTM_P2_speedBudget,
							    const_BalanceSTM_P2_rotationBudget) = 
						((let
							getsetLocalChannels = {|get_currAngle,set_currAngle,
							get_currGyroX,set_currGyroX,
							get_currGyroY,set_currGyroY,
							get_currGyroZ,set_currGyroZ,
							get_currLeftVel,set_currLeftVel,
							get_currRightVel,set_currRightVel,
							get_speedCount,set_speedCount,
							get_rotationCount,set_rotationCount,
							get_angleOutput,set_angleOutput,
							get_speedOutput,set_speedOutput,
							get_rotationOutput,set_rotationOutput,
							get_speedSent,set_speedSent,
							get_angleSent,set_angleSent,
							get_rotationSent,set_rotationSent,
							get_angleReceived,set_angleReceived,
							get_speedIntegral,set_speedIntegral|}
							clockSync = {|get_CLID_loopTimer,clockReset.CLID_loopTimer|}
						within
							(Behaviour(id__,
									    const_BalanceSTM_P2_maxAngle,
									    const_BalanceSTM_P2_loopTime,
									    const_BalanceSTM_P2_startupDelay,
									    const_BalanceSTM_P2_speedUpdate,
									    const_BalanceSTM_P2_rotationUpdate,
									    const_BalanceSTM_P2_motorBudget,
									    const_BalanceSTM_P2_angleBudget,
									    const_BalanceSTM_P2_speedBudget,
									    const_BalanceSTM_P2_rotationBudget) 
							 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
							 (varMemory(id__,
							 		    const_BalanceSTM_P2_maxAngle,
							 		    const_BalanceSTM_P2_loopTime,
							 		    const_BalanceSTM_P2_startupDelay,
							 		    const_BalanceSTM_P2_speedUpdate,
							 		    const_BalanceSTM_P2_rotationUpdate,
							 		    const_BalanceSTM_P2_motorBudget,
							 		    const_BalanceSTM_P2_angleBudget,
							 		    const_BalanceSTM_P2_speedBudget,
							 		    const_BalanceSTM_P2_rotationBudget) [| {terminate} |] Clocks(id__,
							 		          const_BalanceSTM_P2_maxAngle,
							 		          const_BalanceSTM_P2_loopTime,
							 		          const_BalanceSTM_P2_startupDelay,
							 		          const_BalanceSTM_P2_speedUpdate,
							 		          const_BalanceSTM_P2_rotationUpdate,
							 		          const_BalanceSTM_P2_motorBudget,
							 		          const_BalanceSTM_P2_angleBudget,
							 		          const_BalanceSTM_P2_speedBudget,
							 		          const_BalanceSTM_P2_rotationBudget))
						 	)\union(getsetLocalChannels,clockSync)
						)
						)
					
					IteratedStateful(id__,
							    const_BalanceSTM_P2_maxAngle,
							    const_BalanceSTM_P2_loopTime,
							    const_BalanceSTM_P2_startupDelay,
							    const_BalanceSTM_P2_speedUpdate,
							    const_BalanceSTM_P2_rotationUpdate,
							    const_BalanceSTM_P2_motorBudget,
							    const_BalanceSTM_P2_angleBudget,
							    const_BalanceSTM_P2_speedBudget,
							    const_BalanceSTM_P2_rotationBudget) =
						(dbisim(
							sbisim(
								dbisim(
									sbisim(
										dbisim(
											sbisim(
												dbisim(
													sbisim(
														dbisim(
															sbisim(
																dbisim(
																	sbisim(
																		dbisim(
																			sbisim(
																				dbisim(
																					sbisim(
																						dbisim(
																							sbisim(
																								dbisim(
																									sbisim(
																										dbisim(
																											sbisim(
																												dbisim(
																													sbisim(
																														dbisim(
																															sbisim(
																																dbisim(
																																	sbisim(
																																		dbisim(
																																			sbisim(
																																				dbisim(
																																					sbisim(
																																						dbisim(
																																							sbisim(
																																								IteratedBehaviour(id__,
																																										    const_BalanceSTM_P2_maxAngle,
																																										    const_BalanceSTM_P2_loopTime,
																																										    const_BalanceSTM_P2_startupDelay,
																																										    const_BalanceSTM_P2_speedUpdate,
																																										    const_BalanceSTM_P2_rotationUpdate,
																																										    const_BalanceSTM_P2_motorBudget,
																																										    const_BalanceSTM_P2_angleBudget,
																																										    const_BalanceSTM_P2_speedBudget,
																																										    const_BalanceSTM_P2_rotationBudget)
																																								[| {|get_CLID_loopTimer,clockReset.CLID_loopTimer,terminate|} |]
																																								dbisim(Clock_CLID_loopTimer(id__,0,
																																										          const_BalanceSTM_P2_maxAngle,
																																										          const_BalanceSTM_P2_loopTime,
																																										          const_BalanceSTM_P2_startupDelay,
																																										          const_BalanceSTM_P2_speedUpdate,
																																										          const_BalanceSTM_P2_rotationUpdate,
																																										          const_BalanceSTM_P2_motorBudget,
																																										          const_BalanceSTM_P2_angleBudget,
																																										          const_BalanceSTM_P2_speedBudget,
																																										          const_BalanceSTM_P2_rotationBudget))
																																							)\{|get_CLID_loopTimer,clockReset.CLID_loopTimer|}
																																						)
																																						[| {|get_speedIntegral,set_speedIntegral,terminate|} |]
																																						Memory_speedIntegral(0)
																																					)\{|get_speedIntegral,set_speedIntegral|}
																																				)
																																				[| {|get_angleReceived,set_angleReceived,terminate|} |]
																																				Memory_angleReceived(true)
																																			)\{|get_angleReceived,set_angleReceived|}
																																		)
																																		[| {|get_rotationSent,set_rotationSent,terminate|} |]
																																		Memory_rotationSent(true)
																																	)\{|get_rotationSent,set_rotationSent|}
																																)
																																[| {|get_angleSent,set_angleSent,terminate|} |]
																																Memory_angleSent(true)
																															)\{|get_angleSent,set_angleSent|}
																														)
																														[| {|get_speedSent,set_speedSent,terminate|} |]
																														Memory_speedSent(true)
																													)\{|get_speedSent,set_speedSent|}
																												)
																												[| {|get_rotationOutput,set_rotationOutput,terminate|} |]
																												Memory_rotationOutput(0)
																											)\{|get_rotationOutput,set_rotationOutput|}
																										)
																										[| {|get_speedOutput,set_speedOutput,terminate|} |]
																										Memory_speedOutput(0)
																									)\{|get_speedOutput,set_speedOutput|}
																								)
																								[| {|get_angleOutput,set_angleOutput,terminate|} |]
																								Memory_angleOutput(0)
																							)\{|get_angleOutput,set_angleOutput|}
																						)
																						[| {|get_rotationCount,set_rotationCount,terminate|} |]
																						Memory_rotationCount(0)
																					)\{|get_rotationCount,set_rotationCount|}
																				)
																				[| {|get_speedCount,set_speedCount,terminate|} |]
																				Memory_speedCount(0)
																			)\{|get_speedCount,set_speedCount|}
																		)
																		[| {|get_currRightVel,set_currRightVel,terminate|} |]
																		Memory_currRightVel(0)
																	)\{|get_currRightVel,set_currRightVel|}
																)
																[| {|get_currLeftVel,set_currLeftVel,terminate|} |]
																Memory_currLeftVel(0)
															)\{|get_currLeftVel,set_currLeftVel|}
														)
														[| {|get_currGyroZ,set_currGyroZ,terminate|} |]
														Memory_currGyroZ(0)
													)\{|get_currGyroZ,set_currGyroZ|}
												)
												[| {|get_currGyroY,set_currGyroY,terminate|} |]
												Memory_currGyroY(0)
											)\{|get_currGyroY,set_currGyroY|}
										)
										[| {|get_currGyroX,set_currGyroX,terminate|} |]
										Memory_currGyroX(0)
									)\{|get_currGyroX,set_currGyroX|}
								)
								[| {|get_currAngle,set_currAngle,terminate|} |]
								Memory_currAngle(0)
							)\{|get_currAngle,set_currAngle|}
						)
						)
					
					-- Visible counterparts
					MachineBody_VS_O(id__,
							    const_BalanceSTM_P2_maxAngle,
							    const_BalanceSTM_P2_loopTime,
							    const_BalanceSTM_P2_startupDelay,
							    const_BalanceSTM_P2_speedUpdate,
							    const_BalanceSTM_P2_rotationUpdate,
							    const_BalanceSTM_P2_motorBudget,
							    const_BalanceSTM_P2_angleBudget,
							    const_BalanceSTM_P2_speedBudget,
							    const_BalanceSTM_P2_rotationBudget) = 
						dbisim((
						let
							finalNodesEntered = {||}
						within
							(dbisim((dbisim((let
								-- IMPLEMENTATION NOTE:
								-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
								-- modules for defining the semantics of each node.
								enterSS = {|
								i0::enter,
								Initialisation::enter,
								WaitForNextIteration::enter,
								Setup::enter,
								ReceiveInput::enter,
								SendSpeed::enter,
								SendAngle::enter,
								SendRotation::enter,
								SetMotors::enter,
								StopMotors::enter,
								j2::enter
								|}
								hideSet = union(enterSS,{|exit,exited,internal__|})
							within 
								((let
									-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
									-- because CSPM modules are used for the semantics of Node.
									flowevts = union(enterSS,{|exit,exited,interrupt|})
									transSync = {|internal__.NID_ReceiveInput,angleOutputE__.NID_ReceiveInput.in,internal__.NID_ReceiveInput,internal__.NID_SendAngle,speedOutputE__.NID_ReceiveInput.in,internal__.NID_ReceiveInput,internal__.NID_SendSpeed,rotationOutputE__.NID_ReceiveInput.in,internal__.NID_ReceiveInput,internal__.NID_SendRotation,internal__.NID_i0,internal__.NID_Initialisation,internal__.NID_WaitForNextIteration,internal__.NID_Setup,internal__.NID_j2,internal__.NID_j2,internal__.NID_SetMotors,internal__.NID_StopMotors|}
								within
									((
									 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
									   i0::VS_O__(id__,
									   		    const_BalanceSTM_P2_maxAngle,
									   		    const_BalanceSTM_P2_loopTime,
									   		    const_BalanceSTM_P2_startupDelay,
									   		    const_BalanceSTM_P2_speedUpdate,
									   		    const_BalanceSTM_P2_rotationUpdate,
									   		    const_BalanceSTM_P2_motorBudget,
									   		    const_BalanceSTM_P2_angleBudget,
									   		    const_BalanceSTM_P2_speedBudget,
									   		    const_BalanceSTM_P2_rotationBudget)
									   [| { share__, terminate } |] (
									   Initialisation::VS_O__(id__,
									   		    const_BalanceSTM_P2_maxAngle,
									   		    const_BalanceSTM_P2_loopTime,
									   		    const_BalanceSTM_P2_startupDelay,
									   		    const_BalanceSTM_P2_speedUpdate,
									   		    const_BalanceSTM_P2_rotationUpdate,
									   		    const_BalanceSTM_P2_motorBudget,
									   		    const_BalanceSTM_P2_angleBudget,
									   		    const_BalanceSTM_P2_speedBudget,
									   		    const_BalanceSTM_P2_rotationBudget)
									   [| { share__, terminate } |] (
									   WaitForNextIteration::VS_O__(id__,
									   		    const_BalanceSTM_P2_maxAngle,
									   		    const_BalanceSTM_P2_loopTime,
									   		    const_BalanceSTM_P2_startupDelay,
									   		    const_BalanceSTM_P2_speedUpdate,
									   		    const_BalanceSTM_P2_rotationUpdate,
									   		    const_BalanceSTM_P2_motorBudget,
									   		    const_BalanceSTM_P2_angleBudget,
									   		    const_BalanceSTM_P2_speedBudget,
									   		    const_BalanceSTM_P2_rotationBudget)
									   [| { share__, terminate } |] (
									   Setup::VS_O__(id__,
									   		    const_BalanceSTM_P2_maxAngle,
									   		    const_BalanceSTM_P2_loopTime,
									   		    const_BalanceSTM_P2_startupDelay,
									   		    const_BalanceSTM_P2_speedUpdate,
									   		    const_BalanceSTM_P2_rotationUpdate,
									   		    const_BalanceSTM_P2_motorBudget,
									   		    const_BalanceSTM_P2_angleBudget,
									   		    const_BalanceSTM_P2_speedBudget,
									   		    const_BalanceSTM_P2_rotationBudget)
									   [| { share__, terminate } |] (
									   ReceiveInput::VS_O__(id__,
									   		    const_BalanceSTM_P2_maxAngle,
									   		    const_BalanceSTM_P2_loopTime,
									   		    const_BalanceSTM_P2_startupDelay,
									   		    const_BalanceSTM_P2_speedUpdate,
									   		    const_BalanceSTM_P2_rotationUpdate,
									   		    const_BalanceSTM_P2_motorBudget,
									   		    const_BalanceSTM_P2_angleBudget,
									   		    const_BalanceSTM_P2_speedBudget,
									   		    const_BalanceSTM_P2_rotationBudget)
									   [| { share__, terminate } |] (
									   SendSpeed::VS_O__(id__,
									   		    const_BalanceSTM_P2_maxAngle,
									   		    const_BalanceSTM_P2_loopTime,
									   		    const_BalanceSTM_P2_startupDelay,
									   		    const_BalanceSTM_P2_speedUpdate,
									   		    const_BalanceSTM_P2_rotationUpdate,
									   		    const_BalanceSTM_P2_motorBudget,
									   		    const_BalanceSTM_P2_angleBudget,
									   		    const_BalanceSTM_P2_speedBudget,
									   		    const_BalanceSTM_P2_rotationBudget)
									   [| { share__, terminate } |] (
									   SendAngle::VS_O__(id__,
									   		    const_BalanceSTM_P2_maxAngle,
									   		    const_BalanceSTM_P2_loopTime,
									   		    const_BalanceSTM_P2_startupDelay,
									   		    const_BalanceSTM_P2_speedUpdate,
									   		    const_BalanceSTM_P2_rotationUpdate,
									   		    const_BalanceSTM_P2_motorBudget,
									   		    const_BalanceSTM_P2_angleBudget,
									   		    const_BalanceSTM_P2_speedBudget,
									   		    const_BalanceSTM_P2_rotationBudget)
									   [| { share__, terminate } |] (
									   SendRotation::VS_O__(id__,
									   		    const_BalanceSTM_P2_maxAngle,
									   		    const_BalanceSTM_P2_loopTime,
									   		    const_BalanceSTM_P2_startupDelay,
									   		    const_BalanceSTM_P2_speedUpdate,
									   		    const_BalanceSTM_P2_rotationUpdate,
									   		    const_BalanceSTM_P2_motorBudget,
									   		    const_BalanceSTM_P2_angleBudget,
									   		    const_BalanceSTM_P2_speedBudget,
									   		    const_BalanceSTM_P2_rotationBudget)
									   [| { share__, terminate } |] (
									   SetMotors::VS_O__(id__,
									   		    const_BalanceSTM_P2_maxAngle,
									   		    const_BalanceSTM_P2_loopTime,
									   		    const_BalanceSTM_P2_startupDelay,
									   		    const_BalanceSTM_P2_speedUpdate,
									   		    const_BalanceSTM_P2_rotationUpdate,
									   		    const_BalanceSTM_P2_motorBudget,
									   		    const_BalanceSTM_P2_angleBudget,
									   		    const_BalanceSTM_P2_speedBudget,
									   		    const_BalanceSTM_P2_rotationBudget)
									   [| { share__, terminate } |] (
									   StopMotors::VS_O__(id__,
									   		    const_BalanceSTM_P2_maxAngle,
									   		    const_BalanceSTM_P2_loopTime,
									   		    const_BalanceSTM_P2_startupDelay,
									   		    const_BalanceSTM_P2_speedUpdate,
									   		    const_BalanceSTM_P2_rotationUpdate,
									   		    const_BalanceSTM_P2_motorBudget,
									   		    const_BalanceSTM_P2_angleBudget,
									   		    const_BalanceSTM_P2_speedBudget,
									   		    const_BalanceSTM_P2_rotationBudget)
									   [| { share__, terminate } |] (
									   j2::VS_O__(id__,
									   		    const_BalanceSTM_P2_maxAngle,
									   		    const_BalanceSTM_P2_loopTime,
									   		    const_BalanceSTM_P2_startupDelay,
									   		    const_BalanceSTM_P2_speedUpdate,
									   		    const_BalanceSTM_P2_rotationUpdate,
									   		    const_BalanceSTM_P2_motorBudget,
									   		    const_BalanceSTM_P2_angleBudget,
									   		    const_BalanceSTM_P2_speedBudget,
									   		    const_BalanceSTM_P2_rotationBudget)
									   )
									   )
									   )
									   )
									   )
									   )
									   )
									   )
									   )
									   )
									 )
									 [[Initialisation::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_Initialisation|}]]
									 [[WaitForNextIteration::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_WaitForNextIteration|}]]
									 [[Setup::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_Setup|}]]
									 [[ReceiveInput::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_ReceiveInput,angleOutputE__.NID_ReceiveInput.in,internal__.NID_ReceiveInput,speedOutputE__.NID_ReceiveInput.in,internal__.NID_ReceiveInput,rotationOutputE__.NID_ReceiveInput.in,internal__.NID_ReceiveInput|}]]
									 [[SendSpeed::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_SendSpeed|}]]
									 [[SendAngle::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_SendAngle|}]]
									 [[SendRotation::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_SendRotation|}]]
									 [[SetMotors::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_SetMotors|}]]
									 [[StopMotors::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_StopMotors|}]]
									 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
									 [[j2::interrupt <- x__ | x__ <- {|internal__.NID_j2,internal__.NID_j2|}]]
									 )
									  [[ share__ <- x__ | x__ <- {| share__,setR_speedOutput,setR_angleOutput,setR_rotationOutput |} ]] 
									  [[set_angleReceived <- setL_angleReceived,set_rotationCount <- setL_rotationCount,clockReset.CLID_loopTimer <- clockResetL.CLID_loopTimer,set_speedCount <- setL_speedCount,set_speedSent <- setL_speedSent,set_currAngle <- setL_currAngle,set_rotationSent <- setL_rotationSent,set_angleSent <- setL_angleSent]]
									 )
									 [| union(union(union(flowevts,transSync),{terminate}),{|share__
									 			,setL_angleReceived
									 			,setL_rotationCount
									 			,clockResetL.CLID_loopTimer
									 			,setL_speedCount
									 			,setL_speedSent
									 			,setL_currAngle
									 			,setL_rotationSent
									 			,setL_angleSent
									 			,setR_speedOutput
									 			 			,setR_angleOutput
									 			 			,setR_rotationOutput
									 			|}) |]
									 ((i0::enter -> Transitions(id__,
									 		    const_BalanceSTM_P2_maxAngle,
									 		    const_BalanceSTM_P2_loopTime,
									 		    const_BalanceSTM_P2_startupDelay,
									 		    const_BalanceSTM_P2_speedUpdate,
									 		    const_BalanceSTM_P2_rotationUpdate,
									 		    const_BalanceSTM_P2_motorBudget,
									 		    const_BalanceSTM_P2_angleBudget,
									 		    const_BalanceSTM_P2_speedBudget,
									 		    const_BalanceSTM_P2_rotationBudget))
									  [[ share__ <- x__ | x__ <- {| share__,setL_angleReceived,setL_rotationCount,clockResetL.CLID_loopTimer,setL_speedCount,setL_speedSent,setL_currAngle,setL_rotationSent,setL_angleSent |} ]]
									  [[set_speedOutput <- setR_speedOutput,set_angleOutput <- setR_angleOutput,set_rotationOutput <- setR_rotationOutput]]
									 )
									)[[setL_angleReceived <- set_angleReceived,setL_rotationCount <- set_rotationCount,clockResetL.CLID_loopTimer <- clockReset.CLID_loopTimer,setL_speedCount <- set_speedCount,setL_speedSent <- set_speedSent,setL_currAngle <- set_currAngle,setL_rotationSent <- set_rotationSent,setL_angleSent <- set_angleSent]]
									 [[setR_speedOutput <- set_speedOutput,setR_angleOutput <- set_angleOutput,setR_rotationOutput <- set_rotationOutput]]
									)
								)
								 \ hideSet)
								[[
									leftMotorVelocity__.x____ <- leftMotorVelocity,
									rightMotorVelocity__.x____ <- rightMotorVelocity,
									angle__.x____ <- angle,
									gyroX__.x____ <- gyroX,
									gyroY__.x____ <- gyroY,
									gyroZ__.x____ <- gyroZ,
									angleOutputE__.x____ <- angleOutputE,
									anewError__.x____ <- anewError,
									adiff__.x____ <- adiff,
									snewError__.x____ <- snewError,
									speedOutputE__.x____ <- speedOutputE,
									rdiff__.x____ <- rdiff,
									rotationOutputE__.x____ <- rotationOutputE
									| x____ <- NIDS
								]]
							)
							)
							 [| union(stateClockSync,{terminate}) |]
							 StateClocks(id__,
							 		          const_BalanceSTM_P2_maxAngle,
							 		          const_BalanceSTM_P2_loopTime,
							 		          const_BalanceSTM_P2_startupDelay,
							 		          const_BalanceSTM_P2_speedUpdate,
							 		          const_BalanceSTM_P2_rotationUpdate,
							 		          const_BalanceSTM_P2_motorBudget,
							 		          const_BalanceSTM_P2_angleBudget,
							 		          const_BalanceSTM_P2_speedBudget,
							 		          const_BalanceSTM_P2_rotationBudget)
							)\diff(stateClockSync,enteredSS))
							 [| {| interrupt |} |] SKIP)
						)
						)
					
					Behaviour_VS_O(id__,
							    const_BalanceSTM_P2_maxAngle,
							    const_BalanceSTM_P2_loopTime,
							    const_BalanceSTM_P2_startupDelay,
							    const_BalanceSTM_P2_speedUpdate,
							    const_BalanceSTM_P2_rotationUpdate,
							    const_BalanceSTM_P2_motorBudget,
							    const_BalanceSTM_P2_angleBudget,
							    const_BalanceSTM_P2_speedBudget,
							    const_BalanceSTM_P2_rotationBudget) = 
						dbisim((let
							stateClockSync = {|get_CLID_StopMotors,StopMotors::entered,get_CLID_SendRotation,SendRotation::entered,get_CLID_SendSpeed,SendSpeed::entered,get_CLID_ReceiveInput,ReceiveInput::entered,get_CLID_Initialisation,Initialisation::entered,get_CLID_WaitForNextIteration,WaitForNextIteration::entered,get_CLID_SetMotors,SetMotors::entered,get_CLID_Setup,Setup::entered,get_CLID_SendAngle,SendAngle::entered|}
						 within
							(MachineBody_VS_O(id__,
									    const_BalanceSTM_P2_maxAngle,
									    const_BalanceSTM_P2_loopTime,
									    const_BalanceSTM_P2_startupDelay,
									    const_BalanceSTM_P2_speedUpdate,
									    const_BalanceSTM_P2_rotationUpdate,
									    const_BalanceSTM_P2_motorBudget,
									    const_BalanceSTM_P2_angleBudget,
									    const_BalanceSTM_P2_speedBudget,
									    const_BalanceSTM_P2_rotationBudget) [| union(stateClockSync,{terminate}) |] StateClocks(id__,
									          const_BalanceSTM_P2_maxAngle,
									          const_BalanceSTM_P2_loopTime,
									          const_BalanceSTM_P2_startupDelay,
									          const_BalanceSTM_P2_speedUpdate,
									          const_BalanceSTM_P2_rotationUpdate,
									          const_BalanceSTM_P2_motorBudget,
									          const_BalanceSTM_P2_angleBudget,
									          const_BalanceSTM_P2_speedBudget,
									          const_BalanceSTM_P2_rotationBudget)) \ diff(union(stateClockSync,enteredSS),enteredSS)
						)
						)
					
					IteratedBehaviour_VS_O(id__,
							    const_BalanceSTM_P2_maxAngle,
							    const_BalanceSTM_P2_loopTime,
							    const_BalanceSTM_P2_startupDelay,
							    const_BalanceSTM_P2_speedUpdate,
							    const_BalanceSTM_P2_rotationUpdate,
							    const_BalanceSTM_P2_motorBudget,
							    const_BalanceSTM_P2_angleBudget,
							    const_BalanceSTM_P2_speedBudget,
							    const_BalanceSTM_P2_rotationBudget) = 
						dbisim((let
							stateClockSync = {|get_CLID_StopMotors,StopMotors::entered,get_CLID_SendRotation,SendRotation::entered,get_CLID_SendSpeed,SendSpeed::entered,get_CLID_ReceiveInput,ReceiveInput::entered,get_CLID_Initialisation,Initialisation::entered,get_CLID_WaitForNextIteration,WaitForNextIteration::entered,get_CLID_SetMotors,SetMotors::entered,get_CLID_Setup,Setup::entered,get_CLID_SendAngle,SendAngle::entered|}
						 within
							(dbisim(
								sbisim(
									dbisim(
										sbisim(
											dbisim(
												sbisim(
													dbisim(
														sbisim(
															dbisim(
																sbisim(
																	dbisim(
																		sbisim(
																			dbisim(
																				sbisim(
																					dbisim(
																						sbisim(
																							dbisim(
																								sbisim(
																									MachineBody_VS_O(id__,
																											    const_BalanceSTM_P2_maxAngle,
																											    const_BalanceSTM_P2_loopTime,
																											    const_BalanceSTM_P2_startupDelay,
																											    const_BalanceSTM_P2_speedUpdate,
																											    const_BalanceSTM_P2_rotationUpdate,
																											    const_BalanceSTM_P2_motorBudget,
																											    const_BalanceSTM_P2_angleBudget,
																											    const_BalanceSTM_P2_speedBudget,
																											    const_BalanceSTM_P2_rotationBudget)
																									[| {|get_CLID_SendAngle,SendAngle::entered,terminate|} |]
																									dbisim(Clock_CLID_SendAngle(id__,0,
																											          const_BalanceSTM_P2_maxAngle,
																											          const_BalanceSTM_P2_loopTime,
																											          const_BalanceSTM_P2_startupDelay,
																											          const_BalanceSTM_P2_speedUpdate,
																											          const_BalanceSTM_P2_rotationUpdate,
																											          const_BalanceSTM_P2_motorBudget,
																											          const_BalanceSTM_P2_angleBudget,
																											          const_BalanceSTM_P2_speedBudget,
																											          const_BalanceSTM_P2_rotationBudget))
																								)\{|get_CLID_SendAngle|}
																							)
																							[| {|get_CLID_Setup,Setup::entered,terminate|} |]
																							dbisim(Clock_CLID_Setup(id__,0,
																									          const_BalanceSTM_P2_maxAngle,
																									          const_BalanceSTM_P2_loopTime,
																									          const_BalanceSTM_P2_startupDelay,
																									          const_BalanceSTM_P2_speedUpdate,
																									          const_BalanceSTM_P2_rotationUpdate,
																									          const_BalanceSTM_P2_motorBudget,
																									          const_BalanceSTM_P2_angleBudget,
																									          const_BalanceSTM_P2_speedBudget,
																									          const_BalanceSTM_P2_rotationBudget))
																						)\{|get_CLID_Setup|}
																					)
																					[| {|get_CLID_SetMotors,SetMotors::entered,terminate|} |]
																					dbisim(Clock_CLID_SetMotors(id__,0,
																							          const_BalanceSTM_P2_maxAngle,
																							          const_BalanceSTM_P2_loopTime,
																							          const_BalanceSTM_P2_startupDelay,
																							          const_BalanceSTM_P2_speedUpdate,
																							          const_BalanceSTM_P2_rotationUpdate,
																							          const_BalanceSTM_P2_motorBudget,
																							          const_BalanceSTM_P2_angleBudget,
																							          const_BalanceSTM_P2_speedBudget,
																							          const_BalanceSTM_P2_rotationBudget))
																				)\{|get_CLID_SetMotors|}
																			)
																			[| {|get_CLID_WaitForNextIteration,WaitForNextIteration::entered,terminate|} |]
																			dbisim(Clock_CLID_WaitForNextIteration(id__,0,
																					          const_BalanceSTM_P2_maxAngle,
																					          const_BalanceSTM_P2_loopTime,
																					          const_BalanceSTM_P2_startupDelay,
																					          const_BalanceSTM_P2_speedUpdate,
																					          const_BalanceSTM_P2_rotationUpdate,
																					          const_BalanceSTM_P2_motorBudget,
																					          const_BalanceSTM_P2_angleBudget,
																					          const_BalanceSTM_P2_speedBudget,
																					          const_BalanceSTM_P2_rotationBudget))
																		)\{|get_CLID_WaitForNextIteration|}
																	)
																	[| {|get_CLID_Initialisation,Initialisation::entered,terminate|} |]
																	dbisim(Clock_CLID_Initialisation(id__,0,
																			          const_BalanceSTM_P2_maxAngle,
																			          const_BalanceSTM_P2_loopTime,
																			          const_BalanceSTM_P2_startupDelay,
																			          const_BalanceSTM_P2_speedUpdate,
																			          const_BalanceSTM_P2_rotationUpdate,
																			          const_BalanceSTM_P2_motorBudget,
																			          const_BalanceSTM_P2_angleBudget,
																			          const_BalanceSTM_P2_speedBudget,
																			          const_BalanceSTM_P2_rotationBudget))
																)\{|get_CLID_Initialisation|}
															)
															[| {|get_CLID_ReceiveInput,ReceiveInput::entered,terminate|} |]
															dbisim(Clock_CLID_ReceiveInput(id__,0,
																	          const_BalanceSTM_P2_maxAngle,
																	          const_BalanceSTM_P2_loopTime,
																	          const_BalanceSTM_P2_startupDelay,
																	          const_BalanceSTM_P2_speedUpdate,
																	          const_BalanceSTM_P2_rotationUpdate,
																	          const_BalanceSTM_P2_motorBudget,
																	          const_BalanceSTM_P2_angleBudget,
																	          const_BalanceSTM_P2_speedBudget,
																	          const_BalanceSTM_P2_rotationBudget))
														)\{|get_CLID_ReceiveInput|}
													)
													[| {|get_CLID_SendSpeed,SendSpeed::entered,terminate|} |]
													dbisim(Clock_CLID_SendSpeed(id__,0,
															          const_BalanceSTM_P2_maxAngle,
															          const_BalanceSTM_P2_loopTime,
															          const_BalanceSTM_P2_startupDelay,
															          const_BalanceSTM_P2_speedUpdate,
															          const_BalanceSTM_P2_rotationUpdate,
															          const_BalanceSTM_P2_motorBudget,
															          const_BalanceSTM_P2_angleBudget,
															          const_BalanceSTM_P2_speedBudget,
															          const_BalanceSTM_P2_rotationBudget))
												)\{|get_CLID_SendSpeed|}
											)
											[| {|get_CLID_SendRotation,SendRotation::entered,terminate|} |]
											dbisim(Clock_CLID_SendRotation(id__,0,
													          const_BalanceSTM_P2_maxAngle,
													          const_BalanceSTM_P2_loopTime,
													          const_BalanceSTM_P2_startupDelay,
													          const_BalanceSTM_P2_speedUpdate,
													          const_BalanceSTM_P2_rotationUpdate,
													          const_BalanceSTM_P2_motorBudget,
													          const_BalanceSTM_P2_angleBudget,
													          const_BalanceSTM_P2_speedBudget,
													          const_BalanceSTM_P2_rotationBudget))
										)\{|get_CLID_SendRotation|}
									)
									[| {|get_CLID_StopMotors,StopMotors::entered,terminate|} |]
									dbisim(Clock_CLID_StopMotors(id__,0,
											          const_BalanceSTM_P2_maxAngle,
											          const_BalanceSTM_P2_loopTime,
											          const_BalanceSTM_P2_startupDelay,
											          const_BalanceSTM_P2_speedUpdate,
											          const_BalanceSTM_P2_rotationUpdate,
											          const_BalanceSTM_P2_motorBudget,
											          const_BalanceSTM_P2_angleBudget,
											          const_BalanceSTM_P2_speedBudget,
											          const_BalanceSTM_P2_rotationBudget))
								)\{|get_CLID_StopMotors|}
							)
							) \ diff(union(stateClockSync,enteredSS),enteredSS)
						)
						)
					
					Stateful_VS_O(id__,
							    const_BalanceSTM_P2_maxAngle,
							    const_BalanceSTM_P2_loopTime,
							    const_BalanceSTM_P2_startupDelay,
							    const_BalanceSTM_P2_speedUpdate,
							    const_BalanceSTM_P2_rotationUpdate,
							    const_BalanceSTM_P2_motorBudget,
							    const_BalanceSTM_P2_angleBudget,
							    const_BalanceSTM_P2_speedBudget,
							    const_BalanceSTM_P2_rotationBudget) = 
						dbisim((let
							getsetLocalChannels = {|get_currAngle,set_currAngle,
							get_currGyroX,set_currGyroX,
							get_currGyroY,set_currGyroY,
							get_currGyroZ,set_currGyroZ,
							get_currLeftVel,set_currLeftVel,
							get_currRightVel,set_currRightVel,
							get_speedCount,set_speedCount,
							get_rotationCount,set_rotationCount,
							get_angleOutput,set_angleOutput,
							get_speedOutput,set_speedOutput,
							get_rotationOutput,set_rotationOutput,
							get_speedSent,set_speedSent,
							get_angleSent,set_angleSent,
							get_rotationSent,set_rotationSent,
							get_angleReceived,set_angleReceived,
							get_speedIntegral,set_speedIntegral|}
							clockSync = {|get_CLID_loopTimer,clockReset.CLID_loopTimer|}
						within
							(Behaviour_VS_O(id__,
									    const_BalanceSTM_P2_maxAngle,
									    const_BalanceSTM_P2_loopTime,
									    const_BalanceSTM_P2_startupDelay,
									    const_BalanceSTM_P2_speedUpdate,
									    const_BalanceSTM_P2_rotationUpdate,
									    const_BalanceSTM_P2_motorBudget,
									    const_BalanceSTM_P2_angleBudget,
									    const_BalanceSTM_P2_speedBudget,
									    const_BalanceSTM_P2_rotationBudget) 
							 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
							 (varMemory(id__,
							 		    const_BalanceSTM_P2_maxAngle,
							 		    const_BalanceSTM_P2_loopTime,
							 		    const_BalanceSTM_P2_startupDelay,
							 		    const_BalanceSTM_P2_speedUpdate,
							 		    const_BalanceSTM_P2_rotationUpdate,
							 		    const_BalanceSTM_P2_motorBudget,
							 		    const_BalanceSTM_P2_angleBudget,
							 		    const_BalanceSTM_P2_speedBudget,
							 		    const_BalanceSTM_P2_rotationBudget) [| {terminate} |] Clocks(id__,
							 		          const_BalanceSTM_P2_maxAngle,
							 		          const_BalanceSTM_P2_loopTime,
							 		          const_BalanceSTM_P2_startupDelay,
							 		          const_BalanceSTM_P2_speedUpdate,
							 		          const_BalanceSTM_P2_rotationUpdate,
							 		          const_BalanceSTM_P2_motorBudget,
							 		          const_BalanceSTM_P2_angleBudget,
							 		          const_BalanceSTM_P2_speedBudget,
							 		          const_BalanceSTM_P2_rotationBudget))
						 	)\union(getsetLocalChannels,clockSync)
						)
						)
					
					IteratedStateful_VS_O(id__,
							    const_BalanceSTM_P2_maxAngle,
							    const_BalanceSTM_P2_loopTime,
							    const_BalanceSTM_P2_startupDelay,
							    const_BalanceSTM_P2_speedUpdate,
							    const_BalanceSTM_P2_rotationUpdate,
							    const_BalanceSTM_P2_motorBudget,
							    const_BalanceSTM_P2_angleBudget,
							    const_BalanceSTM_P2_speedBudget,
							    const_BalanceSTM_P2_rotationBudget) =
						(dbisim(
							sbisim(
								dbisim(
									sbisim(
										dbisim(
											sbisim(
												dbisim(
													sbisim(
														dbisim(
															sbisim(
																dbisim(
																	sbisim(
																		dbisim(
																			sbisim(
																				dbisim(
																					sbisim(
																						dbisim(
																							sbisim(
																								dbisim(
																									sbisim(
																										dbisim(
																											sbisim(
																												dbisim(
																													sbisim(
																														dbisim(
																															sbisim(
																																dbisim(
																																	sbisim(
																																		dbisim(
																																			sbisim(
																																				dbisim(
																																					sbisim(
																																						dbisim(
																																							sbisim(
																																								IteratedBehaviour_VS_O(id__,
																																										    const_BalanceSTM_P2_maxAngle,
																																										    const_BalanceSTM_P2_loopTime,
																																										    const_BalanceSTM_P2_startupDelay,
																																										    const_BalanceSTM_P2_speedUpdate,
																																										    const_BalanceSTM_P2_rotationUpdate,
																																										    const_BalanceSTM_P2_motorBudget,
																																										    const_BalanceSTM_P2_angleBudget,
																																										    const_BalanceSTM_P2_speedBudget,
																																										    const_BalanceSTM_P2_rotationBudget)
																																								[| {|get_CLID_loopTimer,clockReset.CLID_loopTimer,terminate|} |]
																																								dbisim(Clock_CLID_loopTimer(id__,0,
																																										          const_BalanceSTM_P2_maxAngle,
																																										          const_BalanceSTM_P2_loopTime,
																																										          const_BalanceSTM_P2_startupDelay,
																																										          const_BalanceSTM_P2_speedUpdate,
																																										          const_BalanceSTM_P2_rotationUpdate,
																																										          const_BalanceSTM_P2_motorBudget,
																																										          const_BalanceSTM_P2_angleBudget,
																																										          const_BalanceSTM_P2_speedBudget,
																																										          const_BalanceSTM_P2_rotationBudget))
																																							)\{|get_CLID_loopTimer,clockReset.CLID_loopTimer|}
																																						)
																																						[| {|get_speedIntegral,set_speedIntegral,terminate|} |]
																																						Memory_speedIntegral(0)
																																					)\{|get_speedIntegral,set_speedIntegral|}
																																				)
																																				[| {|get_angleReceived,set_angleReceived,terminate|} |]
																																				Memory_angleReceived(true)
																																			)\{|get_angleReceived,set_angleReceived|}
																																		)
																																		[| {|get_rotationSent,set_rotationSent,terminate|} |]
																																		Memory_rotationSent(true)
																																	)\{|get_rotationSent,set_rotationSent|}
																																)
																																[| {|get_angleSent,set_angleSent,terminate|} |]
																																Memory_angleSent(true)
																															)\{|get_angleSent,set_angleSent|}
																														)
																														[| {|get_speedSent,set_speedSent,terminate|} |]
																														Memory_speedSent(true)
																													)\{|get_speedSent,set_speedSent|}
																												)
																												[| {|get_rotationOutput,set_rotationOutput,terminate|} |]
																												Memory_rotationOutput(0)
																											)\{|get_rotationOutput,set_rotationOutput|}
																										)
																										[| {|get_speedOutput,set_speedOutput,terminate|} |]
																										Memory_speedOutput(0)
																									)\{|get_speedOutput,set_speedOutput|}
																								)
																								[| {|get_angleOutput,set_angleOutput,terminate|} |]
																								Memory_angleOutput(0)
																							)\{|get_angleOutput,set_angleOutput|}
																						)
																						[| {|get_rotationCount,set_rotationCount,terminate|} |]
																						Memory_rotationCount(0)
																					)\{|get_rotationCount,set_rotationCount|}
																				)
																				[| {|get_speedCount,set_speedCount,terminate|} |]
																				Memory_speedCount(0)
																			)\{|get_speedCount,set_speedCount|}
																		)
																		[| {|get_currRightVel,set_currRightVel,terminate|} |]
																		Memory_currRightVel(0)
																	)\{|get_currRightVel,set_currRightVel|}
																)
																[| {|get_currLeftVel,set_currLeftVel,terminate|} |]
																Memory_currLeftVel(0)
															)\{|get_currLeftVel,set_currLeftVel|}
														)
														[| {|get_currGyroZ,set_currGyroZ,terminate|} |]
														Memory_currGyroZ(0)
													)\{|get_currGyroZ,set_currGyroZ|}
												)
												[| {|get_currGyroY,set_currGyroY,terminate|} |]
												Memory_currGyroY(0)
											)\{|get_currGyroY,set_currGyroY|}
										)
										[| {|get_currGyroX,set_currGyroX,terminate|} |]
										Memory_currGyroX(0)
									)\{|get_currGyroX,set_currGyroX|}
								)
								[| {|get_currAngle,set_currAngle,terminate|} |]
								Memory_currAngle(0)
							)\{|get_currAngle,set_currAngle|}
						)
						)
					
					-- END
					
					-- Memory
					-- Memory variables
					Memory_currAngle(currAngle) =
						get_currAngle!currAngle -> Memory_currAngle(currAngle)
						[]
						set_currAngle?x__ -> Memory_currAngle(x__)
						[]
						terminate -> SKIP
					Memory_currGyroX(currGyroX) =
						get_currGyroX!currGyroX -> Memory_currGyroX(currGyroX)
						[]
						set_currGyroX?x__ -> Memory_currGyroX(x__)
						[]
						terminate -> SKIP
					Memory_currGyroY(currGyroY) =
						get_currGyroY!currGyroY -> Memory_currGyroY(currGyroY)
						[]
						set_currGyroY?x__ -> Memory_currGyroY(x__)
						[]
						terminate -> SKIP
					Memory_currGyroZ(currGyroZ) =
						get_currGyroZ!currGyroZ -> Memory_currGyroZ(currGyroZ)
						[]
						set_currGyroZ?x__ -> Memory_currGyroZ(x__)
						[]
						terminate -> SKIP
					Memory_currLeftVel(currLeftVel) =
						get_currLeftVel!currLeftVel -> Memory_currLeftVel(currLeftVel)
						[]
						set_currLeftVel?x__ -> Memory_currLeftVel(x__)
						[]
						terminate -> SKIP
					Memory_currRightVel(currRightVel) =
						get_currRightVel!currRightVel -> Memory_currRightVel(currRightVel)
						[]
						set_currRightVel?x__ -> Memory_currRightVel(x__)
						[]
						terminate -> SKIP
					Memory_speedCount(speedCount) =
						get_speedCount!speedCount -> Memory_speedCount(speedCount)
						[]
						set_speedCount?x__ -> Memory_speedCount(x__)
						[]
						terminate -> SKIP
					Memory_rotationCount(rotationCount) =
						get_rotationCount!rotationCount -> Memory_rotationCount(rotationCount)
						[]
						set_rotationCount?x__ -> Memory_rotationCount(x__)
						[]
						terminate -> SKIP
					Memory_angleOutput(angleOutput) =
						get_angleOutput!angleOutput -> Memory_angleOutput(angleOutput)
						[]
						set_angleOutput?x__ -> Memory_angleOutput(x__)
						[]
						terminate -> SKIP
					Memory_speedOutput(speedOutput) =
						get_speedOutput!speedOutput -> Memory_speedOutput(speedOutput)
						[]
						set_speedOutput?x__ -> Memory_speedOutput(x__)
						[]
						terminate -> SKIP
					Memory_rotationOutput(rotationOutput) =
						get_rotationOutput!rotationOutput -> Memory_rotationOutput(rotationOutput)
						[]
						set_rotationOutput?x__ -> Memory_rotationOutput(x__)
						[]
						terminate -> SKIP
					Memory_speedSent(speedSent) =
						get_speedSent!speedSent -> Memory_speedSent(speedSent)
						[]
						set_speedSent?x__ -> Memory_speedSent(x__)
						[]
						terminate -> SKIP
					Memory_angleSent(angleSent) =
						get_angleSent!angleSent -> Memory_angleSent(angleSent)
						[]
						set_angleSent?x__ -> Memory_angleSent(x__)
						[]
						terminate -> SKIP
					Memory_rotationSent(rotationSent) =
						get_rotationSent!rotationSent -> Memory_rotationSent(rotationSent)
						[]
						set_rotationSent?x__ -> Memory_rotationSent(x__)
						[]
						terminate -> SKIP
					Memory_angleReceived(angleReceived) =
						get_angleReceived!angleReceived -> Memory_angleReceived(angleReceived)
						[]
						set_angleReceived?x__ -> Memory_angleReceived(x__)
						[]
						terminate -> SKIP
					Memory_speedIntegral(speedIntegral) =
						get_speedIntegral!speedIntegral -> Memory_speedIntegral(speedIntegral)
						[]
						set_speedIntegral?x__ -> Memory_speedIntegral(x__)
						[]
						terminate -> SKIP
					
					-- varMemory process
					varMemory(id__,
							    const_BalanceSTM_P2_maxAngle,
							    const_BalanceSTM_P2_loopTime,
							    const_BalanceSTM_P2_startupDelay,
							    const_BalanceSTM_P2_speedUpdate,
							    const_BalanceSTM_P2_rotationUpdate,
							    const_BalanceSTM_P2_motorBudget,
							    const_BalanceSTM_P2_angleBudget,
							    const_BalanceSTM_P2_speedBudget,
							    const_BalanceSTM_P2_rotationBudget) = Memory_currAngle(0)
					[| { terminate } |] (
					Memory_currGyroX(0)
					[| { terminate } |] (
					Memory_currGyroY(0)
					[| { terminate } |] (
					Memory_currGyroZ(0)
					[| { terminate } |] (
					Memory_currLeftVel(0)
					[| { terminate } |] (
					Memory_currRightVel(0)
					[| { terminate } |] (
					Memory_speedCount(0)
					[| { terminate } |] (
					Memory_rotationCount(0)
					[| { terminate } |] (
					Memory_angleOutput(0)
					[| { terminate } |] (
					Memory_speedOutput(0)
					[| { terminate } |] (
					Memory_rotationOutput(0)
					[| { terminate } |] (
					Memory_speedSent(true)
					[| { terminate } |] (
					Memory_angleSent(true)
					[| { terminate } |] (
					Memory_rotationSent(true)
					[| { terminate } |] (
					Memory_angleReceived(true)
					[| { terminate } |] (
					Memory_speedIntegral(0)
					)
					)
					)
					)
					)
					)
					)
					)
					)
					)
					)
					)
					)
					)
					)
					
					getsetLocalChannels = {|get_currAngle,set_currAngle,get_currGyroX,set_currGyroX,get_currGyroY,set_currGyroY,get_currGyroZ,set_currGyroZ,get_currLeftVel,set_currLeftVel,get_currRightVel,set_currRightVel,get_speedCount,set_speedCount,get_rotationCount,set_rotationCount,get_angleOutput,set_angleOutput,get_speedOutput,set_speedOutput,get_rotationOutput,set_rotationOutput,get_speedSent,set_speedSent,get_angleSent,set_angleSent,get_rotationSent,set_rotationSent,get_angleReceived,set_angleReceived,get_speedIntegral,set_speedIntegral|}
					
					-- Definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
					FVS__(id__,
							    const_BalanceSTM_P2_maxAngle,
							    const_BalanceSTM_P2_loopTime,
							    const_BalanceSTM_P2_startupDelay,
							    const_BalanceSTM_P2_speedUpdate,
							    const_BalanceSTM_P2_rotationUpdate,
							    const_BalanceSTM_P2_motorBudget,
							    const_BalanceSTM_P2_angleBudget,
							    const_BalanceSTM_P2_speedBudget,
							    const_BalanceSTM_P2_rotationBudget) = STM_VS_O(id__,
							    const_BalanceSTM_P2_maxAngle,
							    const_BalanceSTM_P2_loopTime,
							    const_BalanceSTM_P2_startupDelay,
							    const_BalanceSTM_P2_speedUpdate,
							    const_BalanceSTM_P2_rotationUpdate,
							    const_BalanceSTM_P2_motorBudget,
							    const_BalanceSTM_P2_angleBudget,
							    const_BalanceSTM_P2_speedBudget,
							    const_BalanceSTM_P2_rotationBudget) \ localClockResets
					D__(id__,
							    const_BalanceSTM_P2_maxAngle,
							    const_BalanceSTM_P2_loopTime,
							    const_BalanceSTM_P2_startupDelay,
							    const_BalanceSTM_P2_speedUpdate,
							    const_BalanceSTM_P2_rotationUpdate,
							    const_BalanceSTM_P2_motorBudget,
							    const_BalanceSTM_P2_angleBudget,
							    const_BalanceSTM_P2_speedBudget,
							    const_BalanceSTM_P2_rotationBudget) = timed_priority(STM(id__,
							    const_BalanceSTM_P2_maxAngle,
							    const_BalanceSTM_P2_loopTime,
							    const_BalanceSTM_P2_startupDelay,
							    const_BalanceSTM_P2_speedUpdate,
							    const_BalanceSTM_P2_rotationUpdate,
							    const_BalanceSTM_P2_motorBudget,
							    const_BalanceSTM_P2_angleBudget,
							    const_BalanceSTM_P2_speedBudget,
							    const_BalanceSTM_P2_rotationBudget) \ union(internal_events,localClockResets))
					O__(id__,
							    const_BalanceSTM_P2_maxAngle,
							    const_BalanceSTM_P2_loopTime,
							    const_BalanceSTM_P2_startupDelay,
							    const_BalanceSTM_P2_speedUpdate,
							    const_BalanceSTM_P2_rotationUpdate,
							    const_BalanceSTM_P2_motorBudget,
							    const_BalanceSTM_P2_angleBudget,
							    const_BalanceSTM_P2_speedBudget,
							    const_BalanceSTM_P2_rotationBudget) = dbisim(D__(id__,
							    const_BalanceSTM_P2_maxAngle,
							    const_BalanceSTM_P2_loopTime,
							    const_BalanceSTM_P2_startupDelay,
							    const_BalanceSTM_P2_speedUpdate,
							    const_BalanceSTM_P2_rotationUpdate,
							    const_BalanceSTM_P2_motorBudget,
							    const_BalanceSTM_P2_angleBudget,
							    const_BalanceSTM_P2_speedBudget,
							    const_BalanceSTM_P2_rotationBudget))
					VS__(id__,
							    const_BalanceSTM_P2_maxAngle,
							    const_BalanceSTM_P2_loopTime,
							    const_BalanceSTM_P2_startupDelay,
							    const_BalanceSTM_P2_speedUpdate,
							    const_BalanceSTM_P2_rotationUpdate,
							    const_BalanceSTM_P2_motorBudget,
							    const_BalanceSTM_P2_angleBudget,
							    const_BalanceSTM_P2_speedBudget,
							    const_BalanceSTM_P2_rotationBudget) = FVS__(id__,
							    const_BalanceSTM_P2_maxAngle,
							    const_BalanceSTM_P2_loopTime,
							    const_BalanceSTM_P2_startupDelay,
							    const_BalanceSTM_P2_speedUpdate,
							    const_BalanceSTM_P2_rotationUpdate,
							    const_BalanceSTM_P2_motorBudget,
							    const_BalanceSTM_P2_angleBudget,
							    const_BalanceSTM_P2_speedBudget,
							    const_BalanceSTM_P2_rotationBudget)
					VS_O__(id__,
							    const_BalanceSTM_P2_maxAngle,
							    const_BalanceSTM_P2_loopTime,
							    const_BalanceSTM_P2_startupDelay,
							    const_BalanceSTM_P2_speedUpdate,
							    const_BalanceSTM_P2_rotationUpdate,
							    const_BalanceSTM_P2_motorBudget,
							    const_BalanceSTM_P2_angleBudget,
							    const_BalanceSTM_P2_speedBudget,
							    const_BalanceSTM_P2_rotationBudget) = dbisim(FVS__(id__,
							    const_BalanceSTM_P2_maxAngle,
							    const_BalanceSTM_P2_loopTime,
							    const_BalanceSTM_P2_startupDelay,
							    const_BalanceSTM_P2_speedUpdate,
							    const_BalanceSTM_P2_rotationUpdate,
							    const_BalanceSTM_P2_motorBudget,
							    const_BalanceSTM_P2_angleBudget,
							    const_BalanceSTM_P2_speedBudget,
							    const_BalanceSTM_P2_rotationBudget))
					HEXT__(id__,
							    const_BalanceSTM_P2_maxAngle,
							    const_BalanceSTM_P2_loopTime,
							    const_BalanceSTM_P2_startupDelay,
							    const_BalanceSTM_P2_speedUpdate,
							    const_BalanceSTM_P2_rotationUpdate,
							    const_BalanceSTM_P2_motorBudget,
							    const_BalanceSTM_P2_angleBudget,
							    const_BalanceSTM_P2_speedBudget,
							    const_BalanceSTM_P2_rotationBudget) = O__(id__,
							    const_BalanceSTM_P2_maxAngle,
							    const_BalanceSTM_P2_loopTime,
							    const_BalanceSTM_P2_startupDelay,
							    const_BalanceSTM_P2_speedUpdate,
							    const_BalanceSTM_P2_rotationUpdate,
							    const_BalanceSTM_P2_motorBudget,
							    const_BalanceSTM_P2_angleBudget,
							    const_BalanceSTM_P2_speedBudget,
							    const_BalanceSTM_P2_rotationBudget) [|shared_variable_events|] SKIP
					FVS_C__(id__,
							    const_BalanceSTM_P2_maxAngle,
							    const_BalanceSTM_P2_loopTime,
							    const_BalanceSTM_P2_startupDelay,
							    const_BalanceSTM_P2_speedUpdate,
							    const_BalanceSTM_P2_rotationUpdate,
							    const_BalanceSTM_P2_motorBudget,
							    const_BalanceSTM_P2_angleBudget,
							    const_BalanceSTM_P2_speedBudget,
							    const_BalanceSTM_P2_rotationBudget) = dbisim(timed_priority(STM(id__,
							    const_BalanceSTM_P2_maxAngle,
							    const_BalanceSTM_P2_loopTime,
							    const_BalanceSTM_P2_startupDelay,
							    const_BalanceSTM_P2_speedUpdate,
							    const_BalanceSTM_P2_rotationUpdate,
							    const_BalanceSTM_P2_motorBudget,
							    const_BalanceSTM_P2_angleBudget,
							    const_BalanceSTM_P2_speedBudget,
							    const_BalanceSTM_P2_rotationBudget) \ internal_events))
					HUP__(id__,
							    const_BalanceSTM_P2_maxAngle,
							    const_BalanceSTM_P2_loopTime,
							    const_BalanceSTM_P2_startupDelay,
							    const_BalanceSTM_P2_speedUpdate,
							    const_BalanceSTM_P2_rotationUpdate,
							    const_BalanceSTM_P2_motorBudget,
							    const_BalanceSTM_P2_angleBudget,
							    const_BalanceSTM_P2_speedBudget,
							    const_BalanceSTM_P2_rotationBudget) = timed_priority(O__(id__,
							    const_BalanceSTM_P2_maxAngle,
							    const_BalanceSTM_P2_loopTime,
							    const_BalanceSTM_P2_startupDelay,
							    const_BalanceSTM_P2_speedUpdate,
							    const_BalanceSTM_P2_rotationUpdate,
							    const_BalanceSTM_P2_motorBudget,
							    const_BalanceSTM_P2_angleBudget,
							    const_BalanceSTM_P2_speedBudget,
							    const_BalanceSTM_P2_rotationBudget) [|{share__}|] SKIP)
					
					-- Clocks
					Clock_CLID_loopTimer(id__,x__,
							          const_BalanceSTM_P2_maxAngle,
							          const_BalanceSTM_P2_loopTime,
							          const_BalanceSTM_P2_startupDelay,
							          const_BalanceSTM_P2_speedUpdate,
							          const_BalanceSTM_P2_rotationUpdate,
							          const_BalanceSTM_P2_motorBudget,
							          const_BalanceSTM_P2_angleBudget,
							          const_BalanceSTM_P2_speedBudget,
							          const_BalanceSTM_P2_rotationBudget) = 
						TimeOut_1(
							clockReset.CLID_loopTimer -> Clock_CLID_loopTimer(id__,0,
									          const_BalanceSTM_P2_maxAngle,
									          const_BalanceSTM_P2_loopTime,
									          const_BalanceSTM_P2_startupDelay,
									          const_BalanceSTM_P2_speedUpdate,
									          const_BalanceSTM_P2_rotationUpdate,
									          const_BalanceSTM_P2_motorBudget,
									          const_BalanceSTM_P2_angleBudget,
									          const_BalanceSTM_P2_speedBudget,
									          const_BalanceSTM_P2_rotationBudget)
							[]
							get_CLID_loopTimer!x__ -> Clock_CLID_loopTimer(id__,x__,
									          const_BalanceSTM_P2_maxAngle,
									          const_BalanceSTM_P2_loopTime,
									          const_BalanceSTM_P2_startupDelay,
									          const_BalanceSTM_P2_speedUpdate,
									          const_BalanceSTM_P2_rotationUpdate,
									          const_BalanceSTM_P2_motorBudget,
									          const_BalanceSTM_P2_angleBudget,
									          const_BalanceSTM_P2_speedBudget,
									          const_BalanceSTM_P2_rotationBudget)
							[]
							terminate -> SKIP,Clock_CLID_loopTimer(id__,clock_type_plus(x__,1,CLID_loopTimer_clock_type(id__,
									          const_BalanceSTM_P2_maxAngle,
									          const_BalanceSTM_P2_loopTime,
									          const_BalanceSTM_P2_startupDelay,
									          const_BalanceSTM_P2_speedUpdate,
									          const_BalanceSTM_P2_rotationUpdate,
									          const_BalanceSTM_P2_motorBudget,
									          const_BalanceSTM_P2_angleBudget,
									          const_BalanceSTM_P2_speedBudget,
									          const_BalanceSTM_P2_rotationBudget)),
									          const_BalanceSTM_P2_maxAngle,
									          const_BalanceSTM_P2_loopTime,
									          const_BalanceSTM_P2_startupDelay,
									          const_BalanceSTM_P2_speedUpdate,
									          const_BalanceSTM_P2_rotationUpdate,
									          const_BalanceSTM_P2_motorBudget,
									          const_BalanceSTM_P2_angleBudget,
									          const_BalanceSTM_P2_speedBudget,
									          const_BalanceSTM_P2_rotationBudget))
					
					Clocks(id__,
							          const_BalanceSTM_P2_maxAngle,
							          const_BalanceSTM_P2_loopTime,
							          const_BalanceSTM_P2_startupDelay,
							          const_BalanceSTM_P2_speedUpdate,
							          const_BalanceSTM_P2_rotationUpdate,
							          const_BalanceSTM_P2_motorBudget,
							          const_BalanceSTM_P2_angleBudget,
							          const_BalanceSTM_P2_speedBudget,
							          const_BalanceSTM_P2_rotationBudget) = dbisim(Clock_CLID_loopTimer(id__,0,
							          const_BalanceSTM_P2_maxAngle,
							          const_BalanceSTM_P2_loopTime,
							          const_BalanceSTM_P2_startupDelay,
							          const_BalanceSTM_P2_speedUpdate,
							          const_BalanceSTM_P2_rotationUpdate,
							          const_BalanceSTM_P2_motorBudget,
							          const_BalanceSTM_P2_angleBudget,
							          const_BalanceSTM_P2_speedBudget,
							          const_BalanceSTM_P2_rotationBudget))
					
					clockSync = {|get_CLID_loopTimer,clockReset.CLID_loopTimer|}
					
					Clock_CLID_StopMotors(id__,x__,
							          const_BalanceSTM_P2_maxAngle,
							          const_BalanceSTM_P2_loopTime,
							          const_BalanceSTM_P2_startupDelay,
							          const_BalanceSTM_P2_speedUpdate,
							          const_BalanceSTM_P2_rotationUpdate,
							          const_BalanceSTM_P2_motorBudget,
							          const_BalanceSTM_P2_angleBudget,
							          const_BalanceSTM_P2_speedBudget,
							          const_BalanceSTM_P2_rotationBudget) = 
						TimeOut_1(
							StopMotors::entered -> Clock_CLID_StopMotors(id__,0,
									          const_BalanceSTM_P2_maxAngle,
									          const_BalanceSTM_P2_loopTime,
									          const_BalanceSTM_P2_startupDelay,
									          const_BalanceSTM_P2_speedUpdate,
									          const_BalanceSTM_P2_rotationUpdate,
									          const_BalanceSTM_P2_motorBudget,
									          const_BalanceSTM_P2_angleBudget,
									          const_BalanceSTM_P2_speedBudget,
									          const_BalanceSTM_P2_rotationBudget)
							[]
							get_CLID_StopMotors!x__ -> Clock_CLID_StopMotors(id__,x__,
									          const_BalanceSTM_P2_maxAngle,
									          const_BalanceSTM_P2_loopTime,
									          const_BalanceSTM_P2_startupDelay,
									          const_BalanceSTM_P2_speedUpdate,
									          const_BalanceSTM_P2_rotationUpdate,
									          const_BalanceSTM_P2_motorBudget,
									          const_BalanceSTM_P2_angleBudget,
									          const_BalanceSTM_P2_speedBudget,
									          const_BalanceSTM_P2_rotationBudget)
							[]
							terminate -> SKIP,Clock_CLID_StopMotors(id__,clock_type_plus(x__,1,CLID_StopMotors_clock_type(id__,
									          const_BalanceSTM_P2_maxAngle,
									          const_BalanceSTM_P2_loopTime,
									          const_BalanceSTM_P2_startupDelay,
									          const_BalanceSTM_P2_speedUpdate,
									          const_BalanceSTM_P2_rotationUpdate,
									          const_BalanceSTM_P2_motorBudget,
									          const_BalanceSTM_P2_angleBudget,
									          const_BalanceSTM_P2_speedBudget,
									          const_BalanceSTM_P2_rotationBudget)),
									          const_BalanceSTM_P2_maxAngle,
									          const_BalanceSTM_P2_loopTime,
									          const_BalanceSTM_P2_startupDelay,
									          const_BalanceSTM_P2_speedUpdate,
									          const_BalanceSTM_P2_rotationUpdate,
									          const_BalanceSTM_P2_motorBudget,
									          const_BalanceSTM_P2_angleBudget,
									          const_BalanceSTM_P2_speedBudget,
									          const_BalanceSTM_P2_rotationBudget))
					Clock_CLID_SendRotation(id__,x__,
							          const_BalanceSTM_P2_maxAngle,
							          const_BalanceSTM_P2_loopTime,
							          const_BalanceSTM_P2_startupDelay,
							          const_BalanceSTM_P2_speedUpdate,
							          const_BalanceSTM_P2_rotationUpdate,
							          const_BalanceSTM_P2_motorBudget,
							          const_BalanceSTM_P2_angleBudget,
							          const_BalanceSTM_P2_speedBudget,
							          const_BalanceSTM_P2_rotationBudget) = 
						TimeOut_1(
							SendRotation::entered -> Clock_CLID_SendRotation(id__,0,
									          const_BalanceSTM_P2_maxAngle,
									          const_BalanceSTM_P2_loopTime,
									          const_BalanceSTM_P2_startupDelay,
									          const_BalanceSTM_P2_speedUpdate,
									          const_BalanceSTM_P2_rotationUpdate,
									          const_BalanceSTM_P2_motorBudget,
									          const_BalanceSTM_P2_angleBudget,
									          const_BalanceSTM_P2_speedBudget,
									          const_BalanceSTM_P2_rotationBudget)
							[]
							get_CLID_SendRotation!x__ -> Clock_CLID_SendRotation(id__,x__,
									          const_BalanceSTM_P2_maxAngle,
									          const_BalanceSTM_P2_loopTime,
									          const_BalanceSTM_P2_startupDelay,
									          const_BalanceSTM_P2_speedUpdate,
									          const_BalanceSTM_P2_rotationUpdate,
									          const_BalanceSTM_P2_motorBudget,
									          const_BalanceSTM_P2_angleBudget,
									          const_BalanceSTM_P2_speedBudget,
									          const_BalanceSTM_P2_rotationBudget)
							[]
							terminate -> SKIP,Clock_CLID_SendRotation(id__,clock_type_plus(x__,1,CLID_SendRotation_clock_type(id__,
									          const_BalanceSTM_P2_maxAngle,
									          const_BalanceSTM_P2_loopTime,
									          const_BalanceSTM_P2_startupDelay,
									          const_BalanceSTM_P2_speedUpdate,
									          const_BalanceSTM_P2_rotationUpdate,
									          const_BalanceSTM_P2_motorBudget,
									          const_BalanceSTM_P2_angleBudget,
									          const_BalanceSTM_P2_speedBudget,
									          const_BalanceSTM_P2_rotationBudget)),
									          const_BalanceSTM_P2_maxAngle,
									          const_BalanceSTM_P2_loopTime,
									          const_BalanceSTM_P2_startupDelay,
									          const_BalanceSTM_P2_speedUpdate,
									          const_BalanceSTM_P2_rotationUpdate,
									          const_BalanceSTM_P2_motorBudget,
									          const_BalanceSTM_P2_angleBudget,
									          const_BalanceSTM_P2_speedBudget,
									          const_BalanceSTM_P2_rotationBudget))
					Clock_CLID_SendSpeed(id__,x__,
							          const_BalanceSTM_P2_maxAngle,
							          const_BalanceSTM_P2_loopTime,
							          const_BalanceSTM_P2_startupDelay,
							          const_BalanceSTM_P2_speedUpdate,
							          const_BalanceSTM_P2_rotationUpdate,
							          const_BalanceSTM_P2_motorBudget,
							          const_BalanceSTM_P2_angleBudget,
							          const_BalanceSTM_P2_speedBudget,
							          const_BalanceSTM_P2_rotationBudget) = 
						TimeOut_1(
							SendSpeed::entered -> Clock_CLID_SendSpeed(id__,0,
									          const_BalanceSTM_P2_maxAngle,
									          const_BalanceSTM_P2_loopTime,
									          const_BalanceSTM_P2_startupDelay,
									          const_BalanceSTM_P2_speedUpdate,
									          const_BalanceSTM_P2_rotationUpdate,
									          const_BalanceSTM_P2_motorBudget,
									          const_BalanceSTM_P2_angleBudget,
									          const_BalanceSTM_P2_speedBudget,
									          const_BalanceSTM_P2_rotationBudget)
							[]
							get_CLID_SendSpeed!x__ -> Clock_CLID_SendSpeed(id__,x__,
									          const_BalanceSTM_P2_maxAngle,
									          const_BalanceSTM_P2_loopTime,
									          const_BalanceSTM_P2_startupDelay,
									          const_BalanceSTM_P2_speedUpdate,
									          const_BalanceSTM_P2_rotationUpdate,
									          const_BalanceSTM_P2_motorBudget,
									          const_BalanceSTM_P2_angleBudget,
									          const_BalanceSTM_P2_speedBudget,
									          const_BalanceSTM_P2_rotationBudget)
							[]
							terminate -> SKIP,Clock_CLID_SendSpeed(id__,clock_type_plus(x__,1,CLID_SendSpeed_clock_type(id__,
									          const_BalanceSTM_P2_maxAngle,
									          const_BalanceSTM_P2_loopTime,
									          const_BalanceSTM_P2_startupDelay,
									          const_BalanceSTM_P2_speedUpdate,
									          const_BalanceSTM_P2_rotationUpdate,
									          const_BalanceSTM_P2_motorBudget,
									          const_BalanceSTM_P2_angleBudget,
									          const_BalanceSTM_P2_speedBudget,
									          const_BalanceSTM_P2_rotationBudget)),
									          const_BalanceSTM_P2_maxAngle,
									          const_BalanceSTM_P2_loopTime,
									          const_BalanceSTM_P2_startupDelay,
									          const_BalanceSTM_P2_speedUpdate,
									          const_BalanceSTM_P2_rotationUpdate,
									          const_BalanceSTM_P2_motorBudget,
									          const_BalanceSTM_P2_angleBudget,
									          const_BalanceSTM_P2_speedBudget,
									          const_BalanceSTM_P2_rotationBudget))
					Clock_CLID_ReceiveInput(id__,x__,
							          const_BalanceSTM_P2_maxAngle,
							          const_BalanceSTM_P2_loopTime,
							          const_BalanceSTM_P2_startupDelay,
							          const_BalanceSTM_P2_speedUpdate,
							          const_BalanceSTM_P2_rotationUpdate,
							          const_BalanceSTM_P2_motorBudget,
							          const_BalanceSTM_P2_angleBudget,
							          const_BalanceSTM_P2_speedBudget,
							          const_BalanceSTM_P2_rotationBudget) = 
						TimeOut_1(
							ReceiveInput::entered -> Clock_CLID_ReceiveInput(id__,0,
									          const_BalanceSTM_P2_maxAngle,
									          const_BalanceSTM_P2_loopTime,
									          const_BalanceSTM_P2_startupDelay,
									          const_BalanceSTM_P2_speedUpdate,
									          const_BalanceSTM_P2_rotationUpdate,
									          const_BalanceSTM_P2_motorBudget,
									          const_BalanceSTM_P2_angleBudget,
									          const_BalanceSTM_P2_speedBudget,
									          const_BalanceSTM_P2_rotationBudget)
							[]
							get_CLID_ReceiveInput!x__ -> Clock_CLID_ReceiveInput(id__,x__,
									          const_BalanceSTM_P2_maxAngle,
									          const_BalanceSTM_P2_loopTime,
									          const_BalanceSTM_P2_startupDelay,
									          const_BalanceSTM_P2_speedUpdate,
									          const_BalanceSTM_P2_rotationUpdate,
									          const_BalanceSTM_P2_motorBudget,
									          const_BalanceSTM_P2_angleBudget,
									          const_BalanceSTM_P2_speedBudget,
									          const_BalanceSTM_P2_rotationBudget)
							[]
							terminate -> SKIP,Clock_CLID_ReceiveInput(id__,clock_type_plus(x__,1,CLID_ReceiveInput_clock_type(id__,
									          const_BalanceSTM_P2_maxAngle,
									          const_BalanceSTM_P2_loopTime,
									          const_BalanceSTM_P2_startupDelay,
									          const_BalanceSTM_P2_speedUpdate,
									          const_BalanceSTM_P2_rotationUpdate,
									          const_BalanceSTM_P2_motorBudget,
									          const_BalanceSTM_P2_angleBudget,
									          const_BalanceSTM_P2_speedBudget,
									          const_BalanceSTM_P2_rotationBudget)),
									          const_BalanceSTM_P2_maxAngle,
									          const_BalanceSTM_P2_loopTime,
									          const_BalanceSTM_P2_startupDelay,
									          const_BalanceSTM_P2_speedUpdate,
									          const_BalanceSTM_P2_rotationUpdate,
									          const_BalanceSTM_P2_motorBudget,
									          const_BalanceSTM_P2_angleBudget,
									          const_BalanceSTM_P2_speedBudget,
									          const_BalanceSTM_P2_rotationBudget))
					Clock_CLID_Initialisation(id__,x__,
							          const_BalanceSTM_P2_maxAngle,
							          const_BalanceSTM_P2_loopTime,
							          const_BalanceSTM_P2_startupDelay,
							          const_BalanceSTM_P2_speedUpdate,
							          const_BalanceSTM_P2_rotationUpdate,
							          const_BalanceSTM_P2_motorBudget,
							          const_BalanceSTM_P2_angleBudget,
							          const_BalanceSTM_P2_speedBudget,
							          const_BalanceSTM_P2_rotationBudget) = 
						TimeOut_1(
							Initialisation::entered -> Clock_CLID_Initialisation(id__,0,
									          const_BalanceSTM_P2_maxAngle,
									          const_BalanceSTM_P2_loopTime,
									          const_BalanceSTM_P2_startupDelay,
									          const_BalanceSTM_P2_speedUpdate,
									          const_BalanceSTM_P2_rotationUpdate,
									          const_BalanceSTM_P2_motorBudget,
									          const_BalanceSTM_P2_angleBudget,
									          const_BalanceSTM_P2_speedBudget,
									          const_BalanceSTM_P2_rotationBudget)
							[]
							get_CLID_Initialisation!x__ -> Clock_CLID_Initialisation(id__,x__,
									          const_BalanceSTM_P2_maxAngle,
									          const_BalanceSTM_P2_loopTime,
									          const_BalanceSTM_P2_startupDelay,
									          const_BalanceSTM_P2_speedUpdate,
									          const_BalanceSTM_P2_rotationUpdate,
									          const_BalanceSTM_P2_motorBudget,
									          const_BalanceSTM_P2_angleBudget,
									          const_BalanceSTM_P2_speedBudget,
									          const_BalanceSTM_P2_rotationBudget)
							[]
							terminate -> SKIP,Clock_CLID_Initialisation(id__,clock_type_plus(x__,1,CLID_Initialisation_clock_type(id__,
									          const_BalanceSTM_P2_maxAngle,
									          const_BalanceSTM_P2_loopTime,
									          const_BalanceSTM_P2_startupDelay,
									          const_BalanceSTM_P2_speedUpdate,
									          const_BalanceSTM_P2_rotationUpdate,
									          const_BalanceSTM_P2_motorBudget,
									          const_BalanceSTM_P2_angleBudget,
									          const_BalanceSTM_P2_speedBudget,
									          const_BalanceSTM_P2_rotationBudget)),
									          const_BalanceSTM_P2_maxAngle,
									          const_BalanceSTM_P2_loopTime,
									          const_BalanceSTM_P2_startupDelay,
									          const_BalanceSTM_P2_speedUpdate,
									          const_BalanceSTM_P2_rotationUpdate,
									          const_BalanceSTM_P2_motorBudget,
									          const_BalanceSTM_P2_angleBudget,
									          const_BalanceSTM_P2_speedBudget,
									          const_BalanceSTM_P2_rotationBudget))
					Clock_CLID_WaitForNextIteration(id__,x__,
							          const_BalanceSTM_P2_maxAngle,
							          const_BalanceSTM_P2_loopTime,
							          const_BalanceSTM_P2_startupDelay,
							          const_BalanceSTM_P2_speedUpdate,
							          const_BalanceSTM_P2_rotationUpdate,
							          const_BalanceSTM_P2_motorBudget,
							          const_BalanceSTM_P2_angleBudget,
							          const_BalanceSTM_P2_speedBudget,
							          const_BalanceSTM_P2_rotationBudget) = 
						TimeOut_1(
							WaitForNextIteration::entered -> Clock_CLID_WaitForNextIteration(id__,0,
									          const_BalanceSTM_P2_maxAngle,
									          const_BalanceSTM_P2_loopTime,
									          const_BalanceSTM_P2_startupDelay,
									          const_BalanceSTM_P2_speedUpdate,
									          const_BalanceSTM_P2_rotationUpdate,
									          const_BalanceSTM_P2_motorBudget,
									          const_BalanceSTM_P2_angleBudget,
									          const_BalanceSTM_P2_speedBudget,
									          const_BalanceSTM_P2_rotationBudget)
							[]
							get_CLID_WaitForNextIteration!x__ -> Clock_CLID_WaitForNextIteration(id__,x__,
									          const_BalanceSTM_P2_maxAngle,
									          const_BalanceSTM_P2_loopTime,
									          const_BalanceSTM_P2_startupDelay,
									          const_BalanceSTM_P2_speedUpdate,
									          const_BalanceSTM_P2_rotationUpdate,
									          const_BalanceSTM_P2_motorBudget,
									          const_BalanceSTM_P2_angleBudget,
									          const_BalanceSTM_P2_speedBudget,
									          const_BalanceSTM_P2_rotationBudget)
							[]
							terminate -> SKIP,Clock_CLID_WaitForNextIteration(id__,clock_type_plus(x__,1,CLID_WaitForNextIteration_clock_type(id__,
									          const_BalanceSTM_P2_maxAngle,
									          const_BalanceSTM_P2_loopTime,
									          const_BalanceSTM_P2_startupDelay,
									          const_BalanceSTM_P2_speedUpdate,
									          const_BalanceSTM_P2_rotationUpdate,
									          const_BalanceSTM_P2_motorBudget,
									          const_BalanceSTM_P2_angleBudget,
									          const_BalanceSTM_P2_speedBudget,
									          const_BalanceSTM_P2_rotationBudget)),
									          const_BalanceSTM_P2_maxAngle,
									          const_BalanceSTM_P2_loopTime,
									          const_BalanceSTM_P2_startupDelay,
									          const_BalanceSTM_P2_speedUpdate,
									          const_BalanceSTM_P2_rotationUpdate,
									          const_BalanceSTM_P2_motorBudget,
									          const_BalanceSTM_P2_angleBudget,
									          const_BalanceSTM_P2_speedBudget,
									          const_BalanceSTM_P2_rotationBudget))
					Clock_CLID_SetMotors(id__,x__,
							          const_BalanceSTM_P2_maxAngle,
							          const_BalanceSTM_P2_loopTime,
							          const_BalanceSTM_P2_startupDelay,
							          const_BalanceSTM_P2_speedUpdate,
							          const_BalanceSTM_P2_rotationUpdate,
							          const_BalanceSTM_P2_motorBudget,
							          const_BalanceSTM_P2_angleBudget,
							          const_BalanceSTM_P2_speedBudget,
							          const_BalanceSTM_P2_rotationBudget) = 
						TimeOut_1(
							SetMotors::entered -> Clock_CLID_SetMotors(id__,0,
									          const_BalanceSTM_P2_maxAngle,
									          const_BalanceSTM_P2_loopTime,
									          const_BalanceSTM_P2_startupDelay,
									          const_BalanceSTM_P2_speedUpdate,
									          const_BalanceSTM_P2_rotationUpdate,
									          const_BalanceSTM_P2_motorBudget,
									          const_BalanceSTM_P2_angleBudget,
									          const_BalanceSTM_P2_speedBudget,
									          const_BalanceSTM_P2_rotationBudget)
							[]
							get_CLID_SetMotors!x__ -> Clock_CLID_SetMotors(id__,x__,
									          const_BalanceSTM_P2_maxAngle,
									          const_BalanceSTM_P2_loopTime,
									          const_BalanceSTM_P2_startupDelay,
									          const_BalanceSTM_P2_speedUpdate,
									          const_BalanceSTM_P2_rotationUpdate,
									          const_BalanceSTM_P2_motorBudget,
									          const_BalanceSTM_P2_angleBudget,
									          const_BalanceSTM_P2_speedBudget,
									          const_BalanceSTM_P2_rotationBudget)
							[]
							terminate -> SKIP,Clock_CLID_SetMotors(id__,clock_type_plus(x__,1,CLID_SetMotors_clock_type(id__,
									          const_BalanceSTM_P2_maxAngle,
									          const_BalanceSTM_P2_loopTime,
									          const_BalanceSTM_P2_startupDelay,
									          const_BalanceSTM_P2_speedUpdate,
									          const_BalanceSTM_P2_rotationUpdate,
									          const_BalanceSTM_P2_motorBudget,
									          const_BalanceSTM_P2_angleBudget,
									          const_BalanceSTM_P2_speedBudget,
									          const_BalanceSTM_P2_rotationBudget)),
									          const_BalanceSTM_P2_maxAngle,
									          const_BalanceSTM_P2_loopTime,
									          const_BalanceSTM_P2_startupDelay,
									          const_BalanceSTM_P2_speedUpdate,
									          const_BalanceSTM_P2_rotationUpdate,
									          const_BalanceSTM_P2_motorBudget,
									          const_BalanceSTM_P2_angleBudget,
									          const_BalanceSTM_P2_speedBudget,
									          const_BalanceSTM_P2_rotationBudget))
					Clock_CLID_Setup(id__,x__,
							          const_BalanceSTM_P2_maxAngle,
							          const_BalanceSTM_P2_loopTime,
							          const_BalanceSTM_P2_startupDelay,
							          const_BalanceSTM_P2_speedUpdate,
							          const_BalanceSTM_P2_rotationUpdate,
							          const_BalanceSTM_P2_motorBudget,
							          const_BalanceSTM_P2_angleBudget,
							          const_BalanceSTM_P2_speedBudget,
							          const_BalanceSTM_P2_rotationBudget) = 
						TimeOut_1(
							Setup::entered -> Clock_CLID_Setup(id__,0,
									          const_BalanceSTM_P2_maxAngle,
									          const_BalanceSTM_P2_loopTime,
									          const_BalanceSTM_P2_startupDelay,
									          const_BalanceSTM_P2_speedUpdate,
									          const_BalanceSTM_P2_rotationUpdate,
									          const_BalanceSTM_P2_motorBudget,
									          const_BalanceSTM_P2_angleBudget,
									          const_BalanceSTM_P2_speedBudget,
									          const_BalanceSTM_P2_rotationBudget)
							[]
							get_CLID_Setup!x__ -> Clock_CLID_Setup(id__,x__,
									          const_BalanceSTM_P2_maxAngle,
									          const_BalanceSTM_P2_loopTime,
									          const_BalanceSTM_P2_startupDelay,
									          const_BalanceSTM_P2_speedUpdate,
									          const_BalanceSTM_P2_rotationUpdate,
									          const_BalanceSTM_P2_motorBudget,
									          const_BalanceSTM_P2_angleBudget,
									          const_BalanceSTM_P2_speedBudget,
									          const_BalanceSTM_P2_rotationBudget)
							[]
							terminate -> SKIP,Clock_CLID_Setup(id__,clock_type_plus(x__,1,CLID_Setup_clock_type(id__,
									          const_BalanceSTM_P2_maxAngle,
									          const_BalanceSTM_P2_loopTime,
									          const_BalanceSTM_P2_startupDelay,
									          const_BalanceSTM_P2_speedUpdate,
									          const_BalanceSTM_P2_rotationUpdate,
									          const_BalanceSTM_P2_motorBudget,
									          const_BalanceSTM_P2_angleBudget,
									          const_BalanceSTM_P2_speedBudget,
									          const_BalanceSTM_P2_rotationBudget)),
									          const_BalanceSTM_P2_maxAngle,
									          const_BalanceSTM_P2_loopTime,
									          const_BalanceSTM_P2_startupDelay,
									          const_BalanceSTM_P2_speedUpdate,
									          const_BalanceSTM_P2_rotationUpdate,
									          const_BalanceSTM_P2_motorBudget,
									          const_BalanceSTM_P2_angleBudget,
									          const_BalanceSTM_P2_speedBudget,
									          const_BalanceSTM_P2_rotationBudget))
					Clock_CLID_SendAngle(id__,x__,
							          const_BalanceSTM_P2_maxAngle,
							          const_BalanceSTM_P2_loopTime,
							          const_BalanceSTM_P2_startupDelay,
							          const_BalanceSTM_P2_speedUpdate,
							          const_BalanceSTM_P2_rotationUpdate,
							          const_BalanceSTM_P2_motorBudget,
							          const_BalanceSTM_P2_angleBudget,
							          const_BalanceSTM_P2_speedBudget,
							          const_BalanceSTM_P2_rotationBudget) = 
						TimeOut_1(
							SendAngle::entered -> Clock_CLID_SendAngle(id__,0,
									          const_BalanceSTM_P2_maxAngle,
									          const_BalanceSTM_P2_loopTime,
									          const_BalanceSTM_P2_startupDelay,
									          const_BalanceSTM_P2_speedUpdate,
									          const_BalanceSTM_P2_rotationUpdate,
									          const_BalanceSTM_P2_motorBudget,
									          const_BalanceSTM_P2_angleBudget,
									          const_BalanceSTM_P2_speedBudget,
									          const_BalanceSTM_P2_rotationBudget)
							[]
							get_CLID_SendAngle!x__ -> Clock_CLID_SendAngle(id__,x__,
									          const_BalanceSTM_P2_maxAngle,
									          const_BalanceSTM_P2_loopTime,
									          const_BalanceSTM_P2_startupDelay,
									          const_BalanceSTM_P2_speedUpdate,
									          const_BalanceSTM_P2_rotationUpdate,
									          const_BalanceSTM_P2_motorBudget,
									          const_BalanceSTM_P2_angleBudget,
									          const_BalanceSTM_P2_speedBudget,
									          const_BalanceSTM_P2_rotationBudget)
							[]
							terminate -> SKIP,Clock_CLID_SendAngle(id__,clock_type_plus(x__,1,CLID_SendAngle_clock_type(id__,
									          const_BalanceSTM_P2_maxAngle,
									          const_BalanceSTM_P2_loopTime,
									          const_BalanceSTM_P2_startupDelay,
									          const_BalanceSTM_P2_speedUpdate,
									          const_BalanceSTM_P2_rotationUpdate,
									          const_BalanceSTM_P2_motorBudget,
									          const_BalanceSTM_P2_angleBudget,
									          const_BalanceSTM_P2_speedBudget,
									          const_BalanceSTM_P2_rotationBudget)),
									          const_BalanceSTM_P2_maxAngle,
									          const_BalanceSTM_P2_loopTime,
									          const_BalanceSTM_P2_startupDelay,
									          const_BalanceSTM_P2_speedUpdate,
									          const_BalanceSTM_P2_rotationUpdate,
									          const_BalanceSTM_P2_motorBudget,
									          const_BalanceSTM_P2_angleBudget,
									          const_BalanceSTM_P2_speedBudget,
									          const_BalanceSTM_P2_rotationBudget))
					
					StateClocks(id__,
							          const_BalanceSTM_P2_maxAngle,
							          const_BalanceSTM_P2_loopTime,
							          const_BalanceSTM_P2_startupDelay,
							          const_BalanceSTM_P2_speedUpdate,
							          const_BalanceSTM_P2_rotationUpdate,
							          const_BalanceSTM_P2_motorBudget,
							          const_BalanceSTM_P2_angleBudget,
							          const_BalanceSTM_P2_speedBudget,
							          const_BalanceSTM_P2_rotationBudget) = dbisim(Clock_CLID_StopMotors(id__,0,
							          const_BalanceSTM_P2_maxAngle,
							          const_BalanceSTM_P2_loopTime,
							          const_BalanceSTM_P2_startupDelay,
							          const_BalanceSTM_P2_speedUpdate,
							          const_BalanceSTM_P2_rotationUpdate,
							          const_BalanceSTM_P2_motorBudget,
							          const_BalanceSTM_P2_angleBudget,
							          const_BalanceSTM_P2_speedBudget,
							          const_BalanceSTM_P2_rotationBudget))
					[| { terminate } |] (
					dbisim(Clock_CLID_SendRotation(id__,0,
							          const_BalanceSTM_P2_maxAngle,
							          const_BalanceSTM_P2_loopTime,
							          const_BalanceSTM_P2_startupDelay,
							          const_BalanceSTM_P2_speedUpdate,
							          const_BalanceSTM_P2_rotationUpdate,
							          const_BalanceSTM_P2_motorBudget,
							          const_BalanceSTM_P2_angleBudget,
							          const_BalanceSTM_P2_speedBudget,
							          const_BalanceSTM_P2_rotationBudget))
					[| { terminate } |] (
					dbisim(Clock_CLID_SendSpeed(id__,0,
							          const_BalanceSTM_P2_maxAngle,
							          const_BalanceSTM_P2_loopTime,
							          const_BalanceSTM_P2_startupDelay,
							          const_BalanceSTM_P2_speedUpdate,
							          const_BalanceSTM_P2_rotationUpdate,
							          const_BalanceSTM_P2_motorBudget,
							          const_BalanceSTM_P2_angleBudget,
							          const_BalanceSTM_P2_speedBudget,
							          const_BalanceSTM_P2_rotationBudget))
					[| { terminate } |] (
					dbisim(Clock_CLID_ReceiveInput(id__,0,
							          const_BalanceSTM_P2_maxAngle,
							          const_BalanceSTM_P2_loopTime,
							          const_BalanceSTM_P2_startupDelay,
							          const_BalanceSTM_P2_speedUpdate,
							          const_BalanceSTM_P2_rotationUpdate,
							          const_BalanceSTM_P2_motorBudget,
							          const_BalanceSTM_P2_angleBudget,
							          const_BalanceSTM_P2_speedBudget,
							          const_BalanceSTM_P2_rotationBudget))
					[| { terminate } |] (
					dbisim(Clock_CLID_Initialisation(id__,0,
							          const_BalanceSTM_P2_maxAngle,
							          const_BalanceSTM_P2_loopTime,
							          const_BalanceSTM_P2_startupDelay,
							          const_BalanceSTM_P2_speedUpdate,
							          const_BalanceSTM_P2_rotationUpdate,
							          const_BalanceSTM_P2_motorBudget,
							          const_BalanceSTM_P2_angleBudget,
							          const_BalanceSTM_P2_speedBudget,
							          const_BalanceSTM_P2_rotationBudget))
					[| { terminate } |] (
					dbisim(Clock_CLID_WaitForNextIteration(id__,0,
							          const_BalanceSTM_P2_maxAngle,
							          const_BalanceSTM_P2_loopTime,
							          const_BalanceSTM_P2_startupDelay,
							          const_BalanceSTM_P2_speedUpdate,
							          const_BalanceSTM_P2_rotationUpdate,
							          const_BalanceSTM_P2_motorBudget,
							          const_BalanceSTM_P2_angleBudget,
							          const_BalanceSTM_P2_speedBudget,
							          const_BalanceSTM_P2_rotationBudget))
					[| { terminate } |] (
					dbisim(Clock_CLID_SetMotors(id__,0,
							          const_BalanceSTM_P2_maxAngle,
							          const_BalanceSTM_P2_loopTime,
							          const_BalanceSTM_P2_startupDelay,
							          const_BalanceSTM_P2_speedUpdate,
							          const_BalanceSTM_P2_rotationUpdate,
							          const_BalanceSTM_P2_motorBudget,
							          const_BalanceSTM_P2_angleBudget,
							          const_BalanceSTM_P2_speedBudget,
							          const_BalanceSTM_P2_rotationBudget))
					[| { terminate } |] (
					dbisim(Clock_CLID_Setup(id__,0,
							          const_BalanceSTM_P2_maxAngle,
							          const_BalanceSTM_P2_loopTime,
							          const_BalanceSTM_P2_startupDelay,
							          const_BalanceSTM_P2_speedUpdate,
							          const_BalanceSTM_P2_rotationUpdate,
							          const_BalanceSTM_P2_motorBudget,
							          const_BalanceSTM_P2_angleBudget,
							          const_BalanceSTM_P2_speedBudget,
							          const_BalanceSTM_P2_rotationBudget))
					[| { terminate } |] (
					dbisim(Clock_CLID_SendAngle(id__,0,
							          const_BalanceSTM_P2_maxAngle,
							          const_BalanceSTM_P2_loopTime,
							          const_BalanceSTM_P2_startupDelay,
							          const_BalanceSTM_P2_speedUpdate,
							          const_BalanceSTM_P2_rotationUpdate,
							          const_BalanceSTM_P2_motorBudget,
							          const_BalanceSTM_P2_angleBudget,
							          const_BalanceSTM_P2_speedBudget,
							          const_BalanceSTM_P2_rotationBudget))
					)
					)
					)
					)
					)
					)
					)
					)
					
					stateClockSync = {|get_CLID_StopMotors,StopMotors::entered,get_CLID_SendRotation,SendRotation::entered,get_CLID_SendSpeed,SendSpeed::entered,get_CLID_ReceiveInput,ReceiveInput::entered,get_CLID_Initialisation,Initialisation::entered,get_CLID_WaitForNextIteration,WaitForNextIteration::entered,get_CLID_SetMotors,SetMotors::entered,get_CLID_Setup,Setup::entered,get_CLID_SendAngle,SendAngle::entered|}
					
					-- Shared memory
					-- Shared memory variables
					
					-- sharedVarMemory process
					sharedVarMemory(id__,
							    const_BalanceSTM_P2_maxAngle,
							    const_BalanceSTM_P2_loopTime,
							    const_BalanceSTM_P2_startupDelay,
							    const_BalanceSTM_P2_speedUpdate,
							    const_BalanceSTM_P2_rotationUpdate,
							    const_BalanceSTM_P2_motorBudget,
							    const_BalanceSTM_P2_angleBudget,
							    const_BalanceSTM_P2_speedBudget,
							    const_BalanceSTM_P2_rotationBudget) = terminate -> SKIP
					
					sharedVarSync = {||}
					
					sharedVarHide = {||}
					}
			endmodule
			module stm_ref1
			exports
				transparent diamond
				transparent sbisim
				transparent dbisim
				transparent chase
			
				-- Transition identifiers
				-- declaring identifiers of transitions
				datatype NIDS = 
				              NID_i0|
				              NID_Read|
				              NID_UpdateOutput
				
				channel internal__ : NIDS
				
				-- Flow channels		
				channel interrupt
				channel exited
				channel exit
				channel terminate
				
				-- Variable channels
				channel get_currAngleOut, set_currAngleOut, setL_currAngleOut, setR_currAngleOut: core_real
				channel get_currNewError, set_currNewError, setL_currNewError, setR_currNewError: core_real
				channel get_currDiff, set_currDiff, setL_currDiff, setR_currDiff: core_real
				
				-- Shared variable channels
				
				-- Local variable channels for defined operations that are required by the state machine
				
				-- Declaring state machine events
				channel angleOutputE__: NIDS.InOut.core_real
				channel angleOutputE: InOut.core_real
				channel anewError__: NIDS.InOut.core_real
				channel anewError: InOut.core_real
				channel adiff__: NIDS.InOut.core_real
				channel adiff: InOut.core_real
				
				-- Declaring call and ret events for undefined operations
				
				enterSS = {|
				i0::enter,
				Read::enter,
				UpdateOutput::enter
				|}
				
				enteredSS = 	{|
				Read::entered,
				UpdateOutput::entered
				|}
				
				internal_events = union(enteredSS,union(enterSS,{|interrupt,exited|}))
				
				shared_variable_events = {|
				|}
				
				-- channel set with all visible events
				sem__events = {|
					terminate
				,	angleOutputE,
					anewError,
					adiff
					|}
				
				channel clockReset, clockResetL, clockResetR 
				
				localClockResets = {||}
				
				
				channel get_CLID_Read : core_clock_type 
				channel get_CLID_UpdateOutput : core_clock_type 
				--channel increment__
				
				CLID_Read_clock_type(id__,
						          const_AnglePID_S_P,
						          const_AnglePID_S_D) = 
					let
						max = (clock_type_max(Union({
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_UpdateOutput_clock_type(id__,
						          const_AnglePID_S_P,
						          const_AnglePID_S_D) = 
					let
						max = (clock_type_max(Union({
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				
			
					-- Nodes --
					-- declaring all nodes
					
					----------------------------------------------------------------------
					-- Initial: i0
					module i0
					exports
					
						channel enter, interrupt
						
						Timed(OneStep) {
							D__(id__,
									    const_AnglePID_S_P,
									    const_AnglePID_S_D) = 
								dbisim(let
									Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
									
									Termination = terminate -> SKIP
									
									Active 		= share__choice(interrupt -> SKIP) ; Inactive
								within
									Inactive [| {terminate} |> SKIP)
							
							VS_O__(id__,
									    const_AnglePID_S_P,
									    const_AnglePID_S_D) = D__(id__,
									    const_AnglePID_S_P,
									    const_AnglePID_S_D)
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: Read
					module Read
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_AnglePID_S_P,
									    const_AnglePID_S_D) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= true&(share__choice(anewError.in?currNewError -> (SStop /\ set_currNewError!currNewError -> SKIP)));true&(share__choice(adiff.in?currDiff -> (SStop /\ set_currDiff!currDiff -> SKIP))) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_AnglePID_S_P,
									    const_AnglePID_S_D) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= true&(share__choice(anewError.in?currNewError -> (SStop /\ set_currNewError!currNewError -> SKIP)));true&(share__choice(adiff.in?currDiff -> (SStop /\ set_currDiff!currDiff -> SKIP))) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_AnglePID_S_P,
									          const_AnglePID_S_D) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: UpdateOutput
					module UpdateOutput
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_AnglePID_S_P,
									    const_AnglePID_S_D) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(share__choice(get_currNewError?currNewError -> share__choice(get_currDiff?currDiff -> true & (share__choice(set_currAngleOut!Plus(Mult(currNewError, const_AnglePID_S_P, core_real), Mult(currDiff, const_AnglePID_S_D, core_real), core_real) -> SKIP))))) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_AnglePID_S_P,
									    const_AnglePID_S_D) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(share__choice(get_currNewError?currNewError -> share__choice(get_currDiff?currDiff -> true & (share__choice(set_currAngleOut!Plus(Mult(currNewError, const_AnglePID_S_P, core_real), Mult(currDiff, const_AnglePID_S_D, core_real), core_real) -> SKIP))))) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_AnglePID_S_P,
									          const_AnglePID_S_D) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					-- END of Nodes --
					
					Timed(OneStep) {
					-- Operation calls --
					-- Only the undefined operations are declared here.
					-- If the state machine is in isolation, all required operations will be undefined.
					-- If it is in the context of a controller, the required operations not provided by the
					-- controller will be declared here, and the defined operations will be defined in the
					-- context of the Controller module, and therefore within scope of the state machine module.
					
					-- END of Operation calls --
				
					-- STM processes
					STM(id__,
							    const_AnglePID_S_P,
							    const_AnglePID_S_D) = prioritise(-- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
					( 
						(
							(
								(IteratedStateful(id__,
										    const_AnglePID_S_P,
										    const_AnglePID_S_D) \ {terminate} ; share__choice(terminate -> SKIP))
							 	[[ share__ <- x__ | x__ <- {||} ]]
							)
						[| {share__} |]
						SKIP
						)
						[| union(sharedVarSync,{terminate}) |]
						dbisim(sharedVarMemory(id__,
								    const_AnglePID_S_P,
								    const_AnglePID_S_D))
					)\sharedVarHide
					,<{terminate},{tock}>)
					
					STM_VS_O(id__,
							    const_AnglePID_S_P,
							    const_AnglePID_S_D) = prioritise(-- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
					( 
						(
							(
								(IteratedStateful_VS_O(id__,
										    const_AnglePID_S_P,
										    const_AnglePID_S_D) \ {terminate} ; share__choice(terminate -> SKIP))
							 	[[ share__ <- x__ | x__ <- {||} ]]
							)
						[| {share__} |]
						SKIP
						)
						[| union(sharedVarSync,{terminate}) |]
						dbisim(sharedVarMemory(id__,
								    const_AnglePID_S_P,
								    const_AnglePID_S_D))
					)\sharedVarHide
					,<{terminate},{tock}>)
					
					-- Transitions
					Transitions(id__,
							    const_AnglePID_S_P,
							    const_AnglePID_S_D) = ((let
						Trans = TimeOut_1(
							 (share__ -> SKIP
							 [] dbisim((true)&(internal__!NID_Read -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; UpdateOutput::enter -> SKIP)))
							 [] dbisim((true)&(internal__!NID_UpdateOutput -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(get_currAngleOut?currAngleOut -> true&(share__choice(angleOutputE.out!currAngleOut -> SKIP))) ; Read::enter -> SKIP)))
							 [] dbisim((true)&(internal__!NID_i0 -> SKIP ;  ((SKIP ; Read::enter -> SKIP))))
							 []
							 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
							 []
							 terminate -> SKIP
							 )
						,SKIP);Trans
					within
						Trans [|{terminate}|> SKIP
					)
					)
					
					-- Stateful
					-- RULE: Stateful(stm:StateMachineBody) : CSPProcess
					
					-- Named process definitions
					MachineBody(id__,
							    const_AnglePID_S_P,
							    const_AnglePID_S_D) = 
						dbisim((
						let
							finalNodesEntered = {||}
						within
							(dbisim((dbisim((let
								-- IMPLEMENTATION NOTE:
								-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
								-- modules for defining the semantics of each node.
								enterSS = {|
								i0::enter,
								Read::enter,
								UpdateOutput::enter
								|}
								hideSet = union(enterSS,{|exit,exited,internal__|})
							within 
								((let
									-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
									-- because CSPM modules are used for the semantics of Node.
									flowevts = union(enterSS,{|exit,exited,interrupt|})
									transSync = {|internal__.NID_Read,internal__.NID_UpdateOutput,internal__.NID_i0|}
								within
									((
									 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
									   i0::D__(id__,
									   		    const_AnglePID_S_P,
									   		    const_AnglePID_S_D)
									   [| { share__, terminate } |] (
									   Read::D__(id__,
									   		    const_AnglePID_S_P,
									   		    const_AnglePID_S_D)
									   [| { share__, terminate } |] (
									   UpdateOutput::D__(id__,
									   		    const_AnglePID_S_P,
									   		    const_AnglePID_S_D)
									   )
									   )
									 )
									 [[Read::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_Read|}]]
									 [[UpdateOutput::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_UpdateOutput|}]]
									 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
									 )
									  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
									 )
									 [| union(union(union(flowevts,transSync),{terminate}),{|share__
									|}) |]
									 ((i0::enter -> Transitions(id__,
									 		    const_AnglePID_S_P,
									 		    const_AnglePID_S_D))
									  [[ share__ <- x__ | x__ <- {| share__ |} ]]
									 )
									)
									)
								)
								 \ hideSet)
								[[
									angleOutputE__.x____ <- angleOutputE,
									anewError__.x____ <- anewError,
									adiff__.x____ <- adiff
									| x____ <- NIDS
								]]
							)
							)
							 [| union(stateClockSync,{terminate}) |]
							 StateClocks(id__,
							 		          const_AnglePID_S_P,
							 		          const_AnglePID_S_D)
							)\diff(stateClockSync,enteredSS))
							 [| {| interrupt |} |] SKIP)
						)
						)
					
					Behaviour(id__,
							    const_AnglePID_S_P,
							    const_AnglePID_S_D) = 
						dbisim((let
							stateClockSync = {|get_CLID_Read,Read::entered,get_CLID_UpdateOutput,UpdateOutput::entered|}
						 within
							(MachineBody(id__,
									    const_AnglePID_S_P,
									    const_AnglePID_S_D) [| union(stateClockSync,{terminate}) |] StateClocks(id__,
									          const_AnglePID_S_P,
									          const_AnglePID_S_D)) \ union(stateClockSync,enteredSS)
						)
						)
					
					IteratedBehaviour(id__,
							    const_AnglePID_S_P,
							    const_AnglePID_S_D) = 
						dbisim((let
							stateClockSync = {|get_CLID_Read,Read::entered,get_CLID_UpdateOutput,UpdateOutput::entered|}
						 within
							(dbisim(
								sbisim(
									dbisim(
										sbisim(
											MachineBody(id__,
													    const_AnglePID_S_P,
													    const_AnglePID_S_D)
											[| {|get_CLID_UpdateOutput,UpdateOutput::entered,terminate|} |]
											dbisim(Clock_CLID_UpdateOutput(id__,0,
													          const_AnglePID_S_P,
													          const_AnglePID_S_D))
										)\{|get_CLID_UpdateOutput|}
									)
									[| {|get_CLID_Read,Read::entered,terminate|} |]
									dbisim(Clock_CLID_Read(id__,0,
											          const_AnglePID_S_P,
											          const_AnglePID_S_D))
								)\{|get_CLID_Read|}
							)
							) \ union(stateClockSync,enteredSS)
						)
						)
					
					Stateful(id__,
							    const_AnglePID_S_P,
							    const_AnglePID_S_D) = 
						((let
							getsetLocalChannels = {|get_currAngleOut,set_currAngleOut,
							get_currNewError,set_currNewError,
							get_currDiff,set_currDiff|}
							clockSync = {||}
						within
							(Behaviour(id__,
									    const_AnglePID_S_P,
									    const_AnglePID_S_D) 
							 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
							 (varMemory(id__,
							 		    const_AnglePID_S_P,
							 		    const_AnglePID_S_D) [| {terminate} |] Clocks(id__,
							 		          const_AnglePID_S_P,
							 		          const_AnglePID_S_D))
						 	)\union(getsetLocalChannels,clockSync)
						)
						)
					
					IteratedStateful(id__,
							    const_AnglePID_S_P,
							    const_AnglePID_S_D) =
						(dbisim(
							sbisim(
								dbisim(
									sbisim(
										dbisim(
											sbisim(
												IteratedBehaviour(id__,
														    const_AnglePID_S_P,
														    const_AnglePID_S_D)
												[| {|get_currDiff,set_currDiff,terminate|} |]
												Memory_currDiff(0)
											)\{|get_currDiff,set_currDiff|}
										)
										[| {|get_currNewError,set_currNewError,terminate|} |]
										Memory_currNewError(0)
									)\{|get_currNewError,set_currNewError|}
								)
								[| {|get_currAngleOut,set_currAngleOut,terminate|} |]
								Memory_currAngleOut(0)
							)\{|get_currAngleOut,set_currAngleOut|}
						)
						)
					
					-- Visible counterparts
					MachineBody_VS_O(id__,
							    const_AnglePID_S_P,
							    const_AnglePID_S_D) = 
						dbisim((
						let
							finalNodesEntered = {||}
						within
							(dbisim((dbisim((let
								-- IMPLEMENTATION NOTE:
								-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
								-- modules for defining the semantics of each node.
								enterSS = {|
								i0::enter,
								Read::enter,
								UpdateOutput::enter
								|}
								hideSet = union(enterSS,{|exit,exited,internal__|})
							within 
								((let
									-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
									-- because CSPM modules are used for the semantics of Node.
									flowevts = union(enterSS,{|exit,exited,interrupt|})
									transSync = {|internal__.NID_Read,internal__.NID_UpdateOutput,internal__.NID_i0|}
								within
									((
									 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
									   i0::VS_O__(id__,
									   		    const_AnglePID_S_P,
									   		    const_AnglePID_S_D)
									   [| { share__, terminate } |] (
									   Read::VS_O__(id__,
									   		    const_AnglePID_S_P,
									   		    const_AnglePID_S_D)
									   [| { share__, terminate } |] (
									   UpdateOutput::VS_O__(id__,
									   		    const_AnglePID_S_P,
									   		    const_AnglePID_S_D)
									   )
									   )
									 )
									 [[Read::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_Read|}]]
									 [[UpdateOutput::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_UpdateOutput|}]]
									 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
									 )
									  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
									 )
									 [| union(union(union(flowevts,transSync),{terminate}),{|share__
									|}) |]
									 ((i0::enter -> Transitions(id__,
									 		    const_AnglePID_S_P,
									 		    const_AnglePID_S_D))
									  [[ share__ <- x__ | x__ <- {| share__ |} ]]
									 )
									)
									)
								)
								 \ hideSet)
								[[
									angleOutputE__.x____ <- angleOutputE,
									anewError__.x____ <- anewError,
									adiff__.x____ <- adiff
									| x____ <- NIDS
								]]
							)
							)
							 [| union(stateClockSync,{terminate}) |]
							 StateClocks(id__,
							 		          const_AnglePID_S_P,
							 		          const_AnglePID_S_D)
							)\diff(stateClockSync,enteredSS))
							 [| {| interrupt |} |] SKIP)
						)
						)
					
					Behaviour_VS_O(id__,
							    const_AnglePID_S_P,
							    const_AnglePID_S_D) = 
						dbisim((let
							stateClockSync = {|get_CLID_Read,Read::entered,get_CLID_UpdateOutput,UpdateOutput::entered|}
						 within
							(MachineBody_VS_O(id__,
									    const_AnglePID_S_P,
									    const_AnglePID_S_D) [| union(stateClockSync,{terminate}) |] StateClocks(id__,
									          const_AnglePID_S_P,
									          const_AnglePID_S_D)) \ diff(union(stateClockSync,enteredSS),enteredSS)
						)
						)
					
					IteratedBehaviour_VS_O(id__,
							    const_AnglePID_S_P,
							    const_AnglePID_S_D) = 
						dbisim((let
							stateClockSync = {|get_CLID_Read,Read::entered,get_CLID_UpdateOutput,UpdateOutput::entered|}
						 within
							(dbisim(
								sbisim(
									dbisim(
										sbisim(
											MachineBody_VS_O(id__,
													    const_AnglePID_S_P,
													    const_AnglePID_S_D)
											[| {|get_CLID_UpdateOutput,UpdateOutput::entered,terminate|} |]
											dbisim(Clock_CLID_UpdateOutput(id__,0,
													          const_AnglePID_S_P,
													          const_AnglePID_S_D))
										)\{|get_CLID_UpdateOutput|}
									)
									[| {|get_CLID_Read,Read::entered,terminate|} |]
									dbisim(Clock_CLID_Read(id__,0,
											          const_AnglePID_S_P,
											          const_AnglePID_S_D))
								)\{|get_CLID_Read|}
							)
							) \ diff(union(stateClockSync,enteredSS),enteredSS)
						)
						)
					
					Stateful_VS_O(id__,
							    const_AnglePID_S_P,
							    const_AnglePID_S_D) = 
						dbisim((let
							getsetLocalChannels = {|get_currAngleOut,set_currAngleOut,
							get_currNewError,set_currNewError,
							get_currDiff,set_currDiff|}
							clockSync = {||}
						within
							(Behaviour_VS_O(id__,
									    const_AnglePID_S_P,
									    const_AnglePID_S_D) 
							 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
							 (varMemory(id__,
							 		    const_AnglePID_S_P,
							 		    const_AnglePID_S_D) [| {terminate} |] Clocks(id__,
							 		          const_AnglePID_S_P,
							 		          const_AnglePID_S_D))
						 	)\union(getsetLocalChannels,clockSync)
						)
						)
					
					IteratedStateful_VS_O(id__,
							    const_AnglePID_S_P,
							    const_AnglePID_S_D) =
						(dbisim(
							sbisim(
								dbisim(
									sbisim(
										dbisim(
											sbisim(
												IteratedBehaviour_VS_O(id__,
														    const_AnglePID_S_P,
														    const_AnglePID_S_D)
												[| {|get_currDiff,set_currDiff,terminate|} |]
												Memory_currDiff(0)
											)\{|get_currDiff,set_currDiff|}
										)
										[| {|get_currNewError,set_currNewError,terminate|} |]
										Memory_currNewError(0)
									)\{|get_currNewError,set_currNewError|}
								)
								[| {|get_currAngleOut,set_currAngleOut,terminate|} |]
								Memory_currAngleOut(0)
							)\{|get_currAngleOut,set_currAngleOut|}
						)
						)
					
					-- END
					
					-- Memory
					-- Memory variables
					Memory_currAngleOut(currAngleOut) =
						get_currAngleOut!currAngleOut -> Memory_currAngleOut(currAngleOut)
						[]
						set_currAngleOut?x__ -> Memory_currAngleOut(x__)
						[]
						terminate -> SKIP
					Memory_currNewError(currNewError) =
						get_currNewError!currNewError -> Memory_currNewError(currNewError)
						[]
						set_currNewError?x__ -> Memory_currNewError(x__)
						[]
						terminate -> SKIP
					Memory_currDiff(currDiff) =
						get_currDiff!currDiff -> Memory_currDiff(currDiff)
						[]
						set_currDiff?x__ -> Memory_currDiff(x__)
						[]
						terminate -> SKIP
					
					-- varMemory process
					varMemory(id__,
							    const_AnglePID_S_P,
							    const_AnglePID_S_D) = Memory_currAngleOut(0)
					[| { terminate } |] (
					Memory_currNewError(0)
					[| { terminate } |] (
					Memory_currDiff(0)
					)
					)
					
					getsetLocalChannels = {|get_currAngleOut,set_currAngleOut,get_currNewError,set_currNewError,get_currDiff,set_currDiff|}
					
					-- Definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
					FVS__(id__,
							    const_AnglePID_S_P,
							    const_AnglePID_S_D) = STM_VS_O(id__,
							    const_AnglePID_S_P,
							    const_AnglePID_S_D) \ localClockResets
					D__(id__,
							    const_AnglePID_S_P,
							    const_AnglePID_S_D) = timed_priority(STM(id__,
							    const_AnglePID_S_P,
							    const_AnglePID_S_D) \ union(internal_events,localClockResets))
					O__(id__,
							    const_AnglePID_S_P,
							    const_AnglePID_S_D) = dbisim(D__(id__,
							    const_AnglePID_S_P,
							    const_AnglePID_S_D))
					VS__(id__,
							    const_AnglePID_S_P,
							    const_AnglePID_S_D) = FVS__(id__,
							    const_AnglePID_S_P,
							    const_AnglePID_S_D)
					VS_O__(id__,
							    const_AnglePID_S_P,
							    const_AnglePID_S_D) = dbisim(FVS__(id__,
							    const_AnglePID_S_P,
							    const_AnglePID_S_D))
					HEXT__(id__,
							    const_AnglePID_S_P,
							    const_AnglePID_S_D) = O__(id__,
							    const_AnglePID_S_P,
							    const_AnglePID_S_D) [|shared_variable_events|] SKIP
					FVS_C__(id__,
							    const_AnglePID_S_P,
							    const_AnglePID_S_D) = dbisim(timed_priority(STM(id__,
							    const_AnglePID_S_P,
							    const_AnglePID_S_D) \ internal_events))
					HUP__(id__,
							    const_AnglePID_S_P,
							    const_AnglePID_S_D) = timed_priority(O__(id__,
							    const_AnglePID_S_P,
							    const_AnglePID_S_D) [|{share__}|] SKIP)
					
					-- Clocks
					
					Clocks(id__,
							          const_AnglePID_S_P,
							          const_AnglePID_S_D) = terminate -> SKIP
					
					clockSync = {||}
					
					Clock_CLID_Read(id__,x__,
							          const_AnglePID_S_P,
							          const_AnglePID_S_D) = 
						TimeOut_1(
							Read::entered -> Clock_CLID_Read(id__,0,
									          const_AnglePID_S_P,
									          const_AnglePID_S_D)
							[]
							get_CLID_Read!x__ -> Clock_CLID_Read(id__,x__,
									          const_AnglePID_S_P,
									          const_AnglePID_S_D)
							[]
							terminate -> SKIP,Clock_CLID_Read(id__,clock_type_plus(x__,1,CLID_Read_clock_type(id__,
									          const_AnglePID_S_P,
									          const_AnglePID_S_D)),
									          const_AnglePID_S_P,
									          const_AnglePID_S_D))
					Clock_CLID_UpdateOutput(id__,x__,
							          const_AnglePID_S_P,
							          const_AnglePID_S_D) = 
						TimeOut_1(
							UpdateOutput::entered -> Clock_CLID_UpdateOutput(id__,0,
									          const_AnglePID_S_P,
									          const_AnglePID_S_D)
							[]
							get_CLID_UpdateOutput!x__ -> Clock_CLID_UpdateOutput(id__,x__,
									          const_AnglePID_S_P,
									          const_AnglePID_S_D)
							[]
							terminate -> SKIP,Clock_CLID_UpdateOutput(id__,clock_type_plus(x__,1,CLID_UpdateOutput_clock_type(id__,
									          const_AnglePID_S_P,
									          const_AnglePID_S_D)),
									          const_AnglePID_S_P,
									          const_AnglePID_S_D))
					
					StateClocks(id__,
							          const_AnglePID_S_P,
							          const_AnglePID_S_D) = dbisim(Clock_CLID_Read(id__,0,
							          const_AnglePID_S_P,
							          const_AnglePID_S_D))
					[| { terminate } |] (
					dbisim(Clock_CLID_UpdateOutput(id__,0,
							          const_AnglePID_S_P,
							          const_AnglePID_S_D))
					)
					
					stateClockSync = {|get_CLID_Read,Read::entered,get_CLID_UpdateOutput,UpdateOutput::entered|}
					
					-- Shared memory
					-- Shared memory variables
					
					-- sharedVarMemory process
					sharedVarMemory(id__,
							    const_AnglePID_S_P,
							    const_AnglePID_S_D) = terminate -> SKIP
					
					sharedVarSync = {||}
					
					sharedVarHide = {||}
					}
			endmodule
			module stm_ref2
			exports
				transparent diamond
				transparent sbisim
				transparent dbisim
				transparent chase
			
				-- Transition identifiers
				-- declaring identifiers of transitions
				datatype NIDS = 
				              NID_i0|
				              NID_Read|
				              NID_UpdateIntegral|
				              NID_UpdateOutput
				
				channel internal__ : NIDS
				
				-- Flow channels		
				channel interrupt
				channel exited
				channel exit
				channel terminate
				
				-- Variable channels
				channel get_currNewError, set_currNewError, setL_currNewError, setR_currNewError: core_real
				channel get_currSpeedOutput, set_currSpeedOutput, setL_currSpeedOutput, setR_currSpeedOutput: core_real
				channel get_speedIntegral, set_speedIntegral, setL_speedIntegral, setR_speedIntegral: core_real
				
				-- Shared variable channels
				
				-- Local variable channels for defined operations that are required by the state machine
				
				-- Declaring state machine events
				channel snewError__: NIDS.InOut.core_real
				channel snewError: InOut.core_real
				channel speedOutputE__: NIDS.InOut.core_real
				channel speedOutputE: InOut.core_real
				
				-- Declaring call and ret events for undefined operations
				
				enterSS = {|
				i0::enter,
				Read::enter,
				UpdateIntegral::enter,
				UpdateOutput::enter
				|}
				
				enteredSS = 	{|
				Read::entered,
				UpdateIntegral::entered,
				UpdateOutput::entered
				|}
				
				internal_events = union(enteredSS,union(enterSS,{|interrupt,exited|}))
				
				shared_variable_events = {|
				|}
				
				-- channel set with all visible events
				sem__events = {|
					terminate
				,	snewError,
					speedOutputE
					|}
				
				channel clockReset, clockResetL, clockResetR 
				
				localClockResets = {||}
				
				
				channel get_CLID_UpdateIntegral : core_clock_type 
				channel get_CLID_Read : core_clock_type 
				channel get_CLID_UpdateOutput : core_clock_type 
				--channel increment__
				
				CLID_UpdateIntegral_clock_type(id__,
						          const_SpeedPID_S_P,
						          const_SpeedPID_S_I,
						          const_SpeedPID_S_maxIntegral) = 
					let
						max = (clock_type_max(Union({
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_Read_clock_type(id__,
						          const_SpeedPID_S_P,
						          const_SpeedPID_S_I,
						          const_SpeedPID_S_maxIntegral) = 
					let
						max = (clock_type_max(Union({
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_UpdateOutput_clock_type(id__,
						          const_SpeedPID_S_P,
						          const_SpeedPID_S_I,
						          const_SpeedPID_S_maxIntegral) = 
					let
						max = (clock_type_max(Union({
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				
			
					-- Nodes --
					-- declaring all nodes
					
					----------------------------------------------------------------------
					-- Initial: i0
					module i0
					exports
					
						channel enter, interrupt
						
						Timed(OneStep) {
							D__(id__,
									    const_SpeedPID_S_P,
									    const_SpeedPID_S_I,
									    const_SpeedPID_S_maxIntegral) = 
								dbisim(let
									Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
									
									Termination = terminate -> SKIP
									
									Active 		= share__choice(interrupt -> SKIP) ; Inactive
								within
									Inactive [| {terminate} |> SKIP)
							
							VS_O__(id__,
									    const_SpeedPID_S_P,
									    const_SpeedPID_S_I,
									    const_SpeedPID_S_maxIntegral) = D__(id__,
									    const_SpeedPID_S_P,
									    const_SpeedPID_S_I,
									    const_SpeedPID_S_maxIntegral)
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: Read
					module Read
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_SpeedPID_S_P,
									    const_SpeedPID_S_I,
									    const_SpeedPID_S_maxIntegral) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_SpeedPID_S_P,
									    const_SpeedPID_S_I,
									    const_SpeedPID_S_maxIntegral) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_SpeedPID_S_P,
									          const_SpeedPID_S_I,
									          const_SpeedPID_S_maxIntegral) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: UpdateIntegral
					module UpdateIntegral
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_SpeedPID_S_P,
									    const_SpeedPID_S_I,
									    const_SpeedPID_S_maxIntegral) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(share__choice(get_speedIntegral?speedIntegral -> share__choice(get_currNewError?currNewError -> true & (share__choice(set_speedIntegral!Plus(speedIntegral, currNewError, core_real) -> SKIP)))));share__choice(share__choice(get_speedIntegral?speedIntegral -> true & (share__choice(set_speedIntegral!(if (speedIntegral>const_SpeedPID_S_maxIntegral) then const_SpeedPID_S_maxIntegral else (if (speedIntegral<Neg(const_SpeedPID_S_maxIntegral, core_real)) then Neg(const_SpeedPID_S_maxIntegral, core_real) else speedIntegral)) -> SKIP)))) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_SpeedPID_S_P,
									    const_SpeedPID_S_I,
									    const_SpeedPID_S_maxIntegral) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(share__choice(get_speedIntegral?speedIntegral -> share__choice(get_currNewError?currNewError -> true & (share__choice(set_speedIntegral!Plus(speedIntegral, currNewError, core_real) -> SKIP)))));share__choice(share__choice(get_speedIntegral?speedIntegral -> true & (share__choice(set_speedIntegral!(if (speedIntegral>const_SpeedPID_S_maxIntegral) then const_SpeedPID_S_maxIntegral else (if (speedIntegral<Neg(const_SpeedPID_S_maxIntegral, core_real)) then Neg(const_SpeedPID_S_maxIntegral, core_real) else speedIntegral)) -> SKIP)))) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_SpeedPID_S_P,
									          const_SpeedPID_S_I,
									          const_SpeedPID_S_maxIntegral) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: UpdateOutput
					module UpdateOutput
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_SpeedPID_S_P,
									    const_SpeedPID_S_I,
									    const_SpeedPID_S_maxIntegral) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(share__choice(get_speedIntegral?speedIntegral -> share__choice(get_currNewError?currNewError -> true & (share__choice(set_currSpeedOutput!Plus(Mult(currNewError, const_SpeedPID_S_P, core_real), Mult(speedIntegral, const_SpeedPID_S_I, core_real), core_real) -> SKIP))))) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_SpeedPID_S_P,
									    const_SpeedPID_S_I,
									    const_SpeedPID_S_maxIntegral) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(share__choice(get_speedIntegral?speedIntegral -> share__choice(get_currNewError?currNewError -> true & (share__choice(set_currSpeedOutput!Plus(Mult(currNewError, const_SpeedPID_S_P, core_real), Mult(speedIntegral, const_SpeedPID_S_I, core_real), core_real) -> SKIP))))) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_SpeedPID_S_P,
									          const_SpeedPID_S_I,
									          const_SpeedPID_S_maxIntegral) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					-- END of Nodes --
					
					Timed(OneStep) {
					-- Operation calls --
					-- Only the undefined operations are declared here.
					-- If the state machine is in isolation, all required operations will be undefined.
					-- If it is in the context of a controller, the required operations not provided by the
					-- controller will be declared here, and the defined operations will be defined in the
					-- context of the Controller module, and therefore within scope of the state machine module.
					
					-- END of Operation calls --
				
					-- STM processes
					STM(id__,
							    const_SpeedPID_S_P,
							    const_SpeedPID_S_I,
							    const_SpeedPID_S_maxIntegral) = prioritise(-- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
					( 
						(
							(
								(IteratedStateful(id__,
										    const_SpeedPID_S_P,
										    const_SpeedPID_S_I,
										    const_SpeedPID_S_maxIntegral) \ {terminate} ; share__choice(terminate -> SKIP))
							 	[[ share__ <- x__ | x__ <- {||} ]]
							)
						[| {share__} |]
						SKIP
						)
						[| union(sharedVarSync,{terminate}) |]
						dbisim(sharedVarMemory(id__,
								    const_SpeedPID_S_P,
								    const_SpeedPID_S_I,
								    const_SpeedPID_S_maxIntegral))
					)\sharedVarHide
					,<{terminate},{tock}>)
					
					STM_VS_O(id__,
							    const_SpeedPID_S_P,
							    const_SpeedPID_S_I,
							    const_SpeedPID_S_maxIntegral) = prioritise(-- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
					( 
						(
							(
								(IteratedStateful_VS_O(id__,
										    const_SpeedPID_S_P,
										    const_SpeedPID_S_I,
										    const_SpeedPID_S_maxIntegral) \ {terminate} ; share__choice(terminate -> SKIP))
							 	[[ share__ <- x__ | x__ <- {||} ]]
							)
						[| {share__} |]
						SKIP
						)
						[| union(sharedVarSync,{terminate}) |]
						dbisim(sharedVarMemory(id__,
								    const_SpeedPID_S_P,
								    const_SpeedPID_S_I,
								    const_SpeedPID_S_maxIntegral))
					)\sharedVarHide
					,<{terminate},{tock}>)
					
					-- Transitions
					Transitions(id__,
							    const_SpeedPID_S_P,
							    const_SpeedPID_S_I,
							    const_SpeedPID_S_maxIntegral) = ((let
						Trans = TimeOut_1(
							 (share__ -> SKIP
							 [] dbisim((true)&(internal__!NID_i0 -> SKIP ;  ((SKIP ; Read::enter -> SKIP))))
							 [] dbisim((true)&(internal__!NID_UpdateIntegral -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; UpdateOutput::enter -> SKIP)))
							 [] dbisim((true)&(internal__!NID_UpdateOutput -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(get_currSpeedOutput?currSpeedOutput -> true&(share__choice(speedOutputE.out!currSpeedOutput -> SKIP))) ; Read::enter -> SKIP)))
							 [] dbisim((true)&(snewError__!NID_Read.in?currNewError:{currNewError|currNewError <- core_real, true} -> share__choice(set_currNewError!currNewError -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; UpdateIntegral::enter -> SKIP)))
							 []
							 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
							 []
							 terminate -> SKIP
							 )
						,SKIP);Trans
					within
						Trans [|{terminate}|> SKIP
					)
					)
					
					-- Stateful
					-- RULE: Stateful(stm:StateMachineBody) : CSPProcess
					
					-- Named process definitions
					MachineBody(id__,
							    const_SpeedPID_S_P,
							    const_SpeedPID_S_I,
							    const_SpeedPID_S_maxIntegral) = 
						dbisim((
						let
							finalNodesEntered = {||}
						within
							(dbisim((dbisim((let
								-- IMPLEMENTATION NOTE:
								-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
								-- modules for defining the semantics of each node.
								enterSS = {|
								i0::enter,
								Read::enter,
								UpdateIntegral::enter,
								UpdateOutput::enter
								|}
								hideSet = union(enterSS,{|exit,exited,internal__|})
							within 
								((let
									-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
									-- because CSPM modules are used for the semantics of Node.
									flowevts = union(enterSS,{|exit,exited,interrupt|})
									transSync = {|internal__.NID_i0,internal__.NID_UpdateIntegral,internal__.NID_UpdateOutput,snewError__.NID_Read.in|}
								within
									((
									 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
									   i0::D__(id__,
									   		    const_SpeedPID_S_P,
									   		    const_SpeedPID_S_I,
									   		    const_SpeedPID_S_maxIntegral)
									   [| { share__, terminate } |] (
									   Read::D__(id__,
									   		    const_SpeedPID_S_P,
									   		    const_SpeedPID_S_I,
									   		    const_SpeedPID_S_maxIntegral)
									   [| { share__, terminate } |] (
									   UpdateIntegral::D__(id__,
									   		    const_SpeedPID_S_P,
									   		    const_SpeedPID_S_I,
									   		    const_SpeedPID_S_maxIntegral)
									   [| { share__, terminate } |] (
									   UpdateOutput::D__(id__,
									   		    const_SpeedPID_S_P,
									   		    const_SpeedPID_S_I,
									   		    const_SpeedPID_S_maxIntegral)
									   )
									   )
									   )
									 )
									 [[Read::interrupt <- x__ | x__ <- {|interrupt,snewError__.NID_Read.in|}]]
									 [[UpdateIntegral::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_UpdateIntegral|}]]
									 [[UpdateOutput::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_UpdateOutput|}]]
									 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
									 )
									  [[ share__ <- x__ | x__ <- {| share__,setR_currNewError |} ]] 
									 )
									 [| union(union(union(flowevts,transSync),{terminate}),{|share__
									 			,setR_currNewError
									 			|}) |]
									 ((i0::enter -> Transitions(id__,
									 		    const_SpeedPID_S_P,
									 		    const_SpeedPID_S_I,
									 		    const_SpeedPID_S_maxIntegral))
									  [[ share__ <- x__ | x__ <- {| share__ |} ]]
									  [[set_currNewError <- setR_currNewError]]
									 )
									)
									 [[setR_currNewError <- set_currNewError]]
									)
								)
								 \ hideSet)
								[[
									snewError__.x____ <- snewError,
									speedOutputE__.x____ <- speedOutputE
									| x____ <- NIDS
								]]
							)
							)
							 [| union(stateClockSync,{terminate}) |]
							 StateClocks(id__,
							 		          const_SpeedPID_S_P,
							 		          const_SpeedPID_S_I,
							 		          const_SpeedPID_S_maxIntegral)
							)\diff(stateClockSync,enteredSS))
							 [| {| interrupt |} |] SKIP)
						)
						)
					
					Behaviour(id__,
							    const_SpeedPID_S_P,
							    const_SpeedPID_S_I,
							    const_SpeedPID_S_maxIntegral) = 
						dbisim((let
							stateClockSync = {|get_CLID_UpdateIntegral,UpdateIntegral::entered,get_CLID_Read,Read::entered,get_CLID_UpdateOutput,UpdateOutput::entered|}
						 within
							(MachineBody(id__,
									    const_SpeedPID_S_P,
									    const_SpeedPID_S_I,
									    const_SpeedPID_S_maxIntegral) [| union(stateClockSync,{terminate}) |] StateClocks(id__,
									          const_SpeedPID_S_P,
									          const_SpeedPID_S_I,
									          const_SpeedPID_S_maxIntegral)) \ union(stateClockSync,enteredSS)
						)
						)
					
					IteratedBehaviour(id__,
							    const_SpeedPID_S_P,
							    const_SpeedPID_S_I,
							    const_SpeedPID_S_maxIntegral) = 
						dbisim((let
							stateClockSync = {|get_CLID_UpdateIntegral,UpdateIntegral::entered,get_CLID_Read,Read::entered,get_CLID_UpdateOutput,UpdateOutput::entered|}
						 within
							(dbisim(
								sbisim(
									dbisim(
										sbisim(
											dbisim(
												sbisim(
													MachineBody(id__,
															    const_SpeedPID_S_P,
															    const_SpeedPID_S_I,
															    const_SpeedPID_S_maxIntegral)
													[| {|get_CLID_UpdateOutput,UpdateOutput::entered,terminate|} |]
													dbisim(Clock_CLID_UpdateOutput(id__,0,
															          const_SpeedPID_S_P,
															          const_SpeedPID_S_I,
															          const_SpeedPID_S_maxIntegral))
												)\{|get_CLID_UpdateOutput|}
											)
											[| {|get_CLID_Read,Read::entered,terminate|} |]
											dbisim(Clock_CLID_Read(id__,0,
													          const_SpeedPID_S_P,
													          const_SpeedPID_S_I,
													          const_SpeedPID_S_maxIntegral))
										)\{|get_CLID_Read|}
									)
									[| {|get_CLID_UpdateIntegral,UpdateIntegral::entered,terminate|} |]
									dbisim(Clock_CLID_UpdateIntegral(id__,0,
											          const_SpeedPID_S_P,
											          const_SpeedPID_S_I,
											          const_SpeedPID_S_maxIntegral))
								)\{|get_CLID_UpdateIntegral|}
							)
							) \ union(stateClockSync,enteredSS)
						)
						)
					
					Stateful(id__,
							    const_SpeedPID_S_P,
							    const_SpeedPID_S_I,
							    const_SpeedPID_S_maxIntegral) = 
						((let
							getsetLocalChannels = {|get_currNewError,set_currNewError,
							get_currSpeedOutput,set_currSpeedOutput,
							get_speedIntegral,set_speedIntegral|}
							clockSync = {||}
						within
							(Behaviour(id__,
									    const_SpeedPID_S_P,
									    const_SpeedPID_S_I,
									    const_SpeedPID_S_maxIntegral) 
							 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
							 (varMemory(id__,
							 		    const_SpeedPID_S_P,
							 		    const_SpeedPID_S_I,
							 		    const_SpeedPID_S_maxIntegral) [| {terminate} |] Clocks(id__,
							 		          const_SpeedPID_S_P,
							 		          const_SpeedPID_S_I,
							 		          const_SpeedPID_S_maxIntegral))
						 	)\union(getsetLocalChannels,clockSync)
						)
						)
					
					IteratedStateful(id__,
							    const_SpeedPID_S_P,
							    const_SpeedPID_S_I,
							    const_SpeedPID_S_maxIntegral) =
						(dbisim(
							sbisim(
								dbisim(
									sbisim(
										dbisim(
											sbisim(
												IteratedBehaviour(id__,
														    const_SpeedPID_S_P,
														    const_SpeedPID_S_I,
														    const_SpeedPID_S_maxIntegral)
												[| {|get_speedIntegral,set_speedIntegral,terminate|} |]
												Memory_speedIntegral(0)
											)\{|get_speedIntegral,set_speedIntegral|}
										)
										[| {|get_currSpeedOutput,set_currSpeedOutput,terminate|} |]
										Memory_currSpeedOutput(0)
									)\{|get_currSpeedOutput,set_currSpeedOutput|}
								)
								[| {|get_currNewError,set_currNewError,terminate|} |]
								Memory_currNewError(0)
							)\{|get_currNewError,set_currNewError|}
						)
						)
					
					-- Visible counterparts
					MachineBody_VS_O(id__,
							    const_SpeedPID_S_P,
							    const_SpeedPID_S_I,
							    const_SpeedPID_S_maxIntegral) = 
						dbisim((
						let
							finalNodesEntered = {||}
						within
							(dbisim((dbisim((let
								-- IMPLEMENTATION NOTE:
								-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
								-- modules for defining the semantics of each node.
								enterSS = {|
								i0::enter,
								Read::enter,
								UpdateIntegral::enter,
								UpdateOutput::enter
								|}
								hideSet = union(enterSS,{|exit,exited,internal__|})
							within 
								((let
									-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
									-- because CSPM modules are used for the semantics of Node.
									flowevts = union(enterSS,{|exit,exited,interrupt|})
									transSync = {|internal__.NID_i0,internal__.NID_UpdateIntegral,internal__.NID_UpdateOutput,snewError__.NID_Read.in|}
								within
									((
									 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
									   i0::VS_O__(id__,
									   		    const_SpeedPID_S_P,
									   		    const_SpeedPID_S_I,
									   		    const_SpeedPID_S_maxIntegral)
									   [| { share__, terminate } |] (
									   Read::VS_O__(id__,
									   		    const_SpeedPID_S_P,
									   		    const_SpeedPID_S_I,
									   		    const_SpeedPID_S_maxIntegral)
									   [| { share__, terminate } |] (
									   UpdateIntegral::VS_O__(id__,
									   		    const_SpeedPID_S_P,
									   		    const_SpeedPID_S_I,
									   		    const_SpeedPID_S_maxIntegral)
									   [| { share__, terminate } |] (
									   UpdateOutput::VS_O__(id__,
									   		    const_SpeedPID_S_P,
									   		    const_SpeedPID_S_I,
									   		    const_SpeedPID_S_maxIntegral)
									   )
									   )
									   )
									 )
									 [[Read::interrupt <- x__ | x__ <- {|interrupt,snewError__.NID_Read.in|}]]
									 [[UpdateIntegral::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_UpdateIntegral|}]]
									 [[UpdateOutput::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_UpdateOutput|}]]
									 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
									 )
									  [[ share__ <- x__ | x__ <- {| share__,setR_currNewError |} ]] 
									 )
									 [| union(union(union(flowevts,transSync),{terminate}),{|share__
									 			,setR_currNewError
									 			|}) |]
									 ((i0::enter -> Transitions(id__,
									 		    const_SpeedPID_S_P,
									 		    const_SpeedPID_S_I,
									 		    const_SpeedPID_S_maxIntegral))
									  [[ share__ <- x__ | x__ <- {| share__ |} ]]
									  [[set_currNewError <- setR_currNewError]]
									 )
									)
									 [[setR_currNewError <- set_currNewError]]
									)
								)
								 \ hideSet)
								[[
									snewError__.x____ <- snewError,
									speedOutputE__.x____ <- speedOutputE
									| x____ <- NIDS
								]]
							)
							)
							 [| union(stateClockSync,{terminate}) |]
							 StateClocks(id__,
							 		          const_SpeedPID_S_P,
							 		          const_SpeedPID_S_I,
							 		          const_SpeedPID_S_maxIntegral)
							)\diff(stateClockSync,enteredSS))
							 [| {| interrupt |} |] SKIP)
						)
						)
					
					Behaviour_VS_O(id__,
							    const_SpeedPID_S_P,
							    const_SpeedPID_S_I,
							    const_SpeedPID_S_maxIntegral) = 
						dbisim((let
							stateClockSync = {|get_CLID_UpdateIntegral,UpdateIntegral::entered,get_CLID_Read,Read::entered,get_CLID_UpdateOutput,UpdateOutput::entered|}
						 within
							(MachineBody_VS_O(id__,
									    const_SpeedPID_S_P,
									    const_SpeedPID_S_I,
									    const_SpeedPID_S_maxIntegral) [| union(stateClockSync,{terminate}) |] StateClocks(id__,
									          const_SpeedPID_S_P,
									          const_SpeedPID_S_I,
									          const_SpeedPID_S_maxIntegral)) \ diff(union(stateClockSync,enteredSS),enteredSS)
						)
						)
					
					IteratedBehaviour_VS_O(id__,
							    const_SpeedPID_S_P,
							    const_SpeedPID_S_I,
							    const_SpeedPID_S_maxIntegral) = 
						dbisim((let
							stateClockSync = {|get_CLID_UpdateIntegral,UpdateIntegral::entered,get_CLID_Read,Read::entered,get_CLID_UpdateOutput,UpdateOutput::entered|}
						 within
							(dbisim(
								sbisim(
									dbisim(
										sbisim(
											dbisim(
												sbisim(
													MachineBody_VS_O(id__,
															    const_SpeedPID_S_P,
															    const_SpeedPID_S_I,
															    const_SpeedPID_S_maxIntegral)
													[| {|get_CLID_UpdateOutput,UpdateOutput::entered,terminate|} |]
													dbisim(Clock_CLID_UpdateOutput(id__,0,
															          const_SpeedPID_S_P,
															          const_SpeedPID_S_I,
															          const_SpeedPID_S_maxIntegral))
												)\{|get_CLID_UpdateOutput|}
											)
											[| {|get_CLID_Read,Read::entered,terminate|} |]
											dbisim(Clock_CLID_Read(id__,0,
													          const_SpeedPID_S_P,
													          const_SpeedPID_S_I,
													          const_SpeedPID_S_maxIntegral))
										)\{|get_CLID_Read|}
									)
									[| {|get_CLID_UpdateIntegral,UpdateIntegral::entered,terminate|} |]
									dbisim(Clock_CLID_UpdateIntegral(id__,0,
											          const_SpeedPID_S_P,
											          const_SpeedPID_S_I,
											          const_SpeedPID_S_maxIntegral))
								)\{|get_CLID_UpdateIntegral|}
							)
							) \ diff(union(stateClockSync,enteredSS),enteredSS)
						)
						)
					
					Stateful_VS_O(id__,
							    const_SpeedPID_S_P,
							    const_SpeedPID_S_I,
							    const_SpeedPID_S_maxIntegral) = 
						dbisim((let
							getsetLocalChannels = {|get_currNewError,set_currNewError,
							get_currSpeedOutput,set_currSpeedOutput,
							get_speedIntegral,set_speedIntegral|}
							clockSync = {||}
						within
							(Behaviour_VS_O(id__,
									    const_SpeedPID_S_P,
									    const_SpeedPID_S_I,
									    const_SpeedPID_S_maxIntegral) 
							 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
							 (varMemory(id__,
							 		    const_SpeedPID_S_P,
							 		    const_SpeedPID_S_I,
							 		    const_SpeedPID_S_maxIntegral) [| {terminate} |] Clocks(id__,
							 		          const_SpeedPID_S_P,
							 		          const_SpeedPID_S_I,
							 		          const_SpeedPID_S_maxIntegral))
						 	)\union(getsetLocalChannels,clockSync)
						)
						)
					
					IteratedStateful_VS_O(id__,
							    const_SpeedPID_S_P,
							    const_SpeedPID_S_I,
							    const_SpeedPID_S_maxIntegral) =
						(dbisim(
							sbisim(
								dbisim(
									sbisim(
										dbisim(
											sbisim(
												IteratedBehaviour_VS_O(id__,
														    const_SpeedPID_S_P,
														    const_SpeedPID_S_I,
														    const_SpeedPID_S_maxIntegral)
												[| {|get_speedIntegral,set_speedIntegral,terminate|} |]
												Memory_speedIntegral(0)
											)\{|get_speedIntegral,set_speedIntegral|}
										)
										[| {|get_currSpeedOutput,set_currSpeedOutput,terminate|} |]
										Memory_currSpeedOutput(0)
									)\{|get_currSpeedOutput,set_currSpeedOutput|}
								)
								[| {|get_currNewError,set_currNewError,terminate|} |]
								Memory_currNewError(0)
							)\{|get_currNewError,set_currNewError|}
						)
						)
					
					-- END
					
					-- Memory
					-- Memory variables
					Memory_currNewError(currNewError) =
						get_currNewError!currNewError -> Memory_currNewError(currNewError)
						[]
						set_currNewError?x__ -> Memory_currNewError(x__)
						[]
						terminate -> SKIP
					Memory_currSpeedOutput(currSpeedOutput) =
						get_currSpeedOutput!currSpeedOutput -> Memory_currSpeedOutput(currSpeedOutput)
						[]
						set_currSpeedOutput?x__ -> Memory_currSpeedOutput(x__)
						[]
						terminate -> SKIP
					Memory_speedIntegral(speedIntegral) =
						get_speedIntegral!speedIntegral -> Memory_speedIntegral(speedIntegral)
						[]
						set_speedIntegral?x__ -> Memory_speedIntegral(x__)
						[]
						terminate -> SKIP
					
					-- varMemory process
					varMemory(id__,
							    const_SpeedPID_S_P,
							    const_SpeedPID_S_I,
							    const_SpeedPID_S_maxIntegral) = Memory_currNewError(0)
					[| { terminate } |] (
					Memory_currSpeedOutput(0)
					[| { terminate } |] (
					Memory_speedIntegral(0)
					)
					)
					
					getsetLocalChannels = {|get_currNewError,set_currNewError,get_currSpeedOutput,set_currSpeedOutput,get_speedIntegral,set_speedIntegral|}
					
					-- Definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
					FVS__(id__,
							    const_SpeedPID_S_P,
							    const_SpeedPID_S_I,
							    const_SpeedPID_S_maxIntegral) = STM_VS_O(id__,
							    const_SpeedPID_S_P,
							    const_SpeedPID_S_I,
							    const_SpeedPID_S_maxIntegral) \ localClockResets
					D__(id__,
							    const_SpeedPID_S_P,
							    const_SpeedPID_S_I,
							    const_SpeedPID_S_maxIntegral) = timed_priority(STM(id__,
							    const_SpeedPID_S_P,
							    const_SpeedPID_S_I,
							    const_SpeedPID_S_maxIntegral) \ union(internal_events,localClockResets))
					O__(id__,
							    const_SpeedPID_S_P,
							    const_SpeedPID_S_I,
							    const_SpeedPID_S_maxIntegral) = dbisim(D__(id__,
							    const_SpeedPID_S_P,
							    const_SpeedPID_S_I,
							    const_SpeedPID_S_maxIntegral))
					VS__(id__,
							    const_SpeedPID_S_P,
							    const_SpeedPID_S_I,
							    const_SpeedPID_S_maxIntegral) = FVS__(id__,
							    const_SpeedPID_S_P,
							    const_SpeedPID_S_I,
							    const_SpeedPID_S_maxIntegral)
					VS_O__(id__,
							    const_SpeedPID_S_P,
							    const_SpeedPID_S_I,
							    const_SpeedPID_S_maxIntegral) = dbisim(FVS__(id__,
							    const_SpeedPID_S_P,
							    const_SpeedPID_S_I,
							    const_SpeedPID_S_maxIntegral))
					HEXT__(id__,
							    const_SpeedPID_S_P,
							    const_SpeedPID_S_I,
							    const_SpeedPID_S_maxIntegral) = O__(id__,
							    const_SpeedPID_S_P,
							    const_SpeedPID_S_I,
							    const_SpeedPID_S_maxIntegral) [|shared_variable_events|] SKIP
					FVS_C__(id__,
							    const_SpeedPID_S_P,
							    const_SpeedPID_S_I,
							    const_SpeedPID_S_maxIntegral) = dbisim(timed_priority(STM(id__,
							    const_SpeedPID_S_P,
							    const_SpeedPID_S_I,
							    const_SpeedPID_S_maxIntegral) \ internal_events))
					HUP__(id__,
							    const_SpeedPID_S_P,
							    const_SpeedPID_S_I,
							    const_SpeedPID_S_maxIntegral) = timed_priority(O__(id__,
							    const_SpeedPID_S_P,
							    const_SpeedPID_S_I,
							    const_SpeedPID_S_maxIntegral) [|{share__}|] SKIP)
					
					-- Clocks
					
					Clocks(id__,
							          const_SpeedPID_S_P,
							          const_SpeedPID_S_I,
							          const_SpeedPID_S_maxIntegral) = terminate -> SKIP
					
					clockSync = {||}
					
					Clock_CLID_UpdateIntegral(id__,x__,
							          const_SpeedPID_S_P,
							          const_SpeedPID_S_I,
							          const_SpeedPID_S_maxIntegral) = 
						TimeOut_1(
							UpdateIntegral::entered -> Clock_CLID_UpdateIntegral(id__,0,
									          const_SpeedPID_S_P,
									          const_SpeedPID_S_I,
									          const_SpeedPID_S_maxIntegral)
							[]
							get_CLID_UpdateIntegral!x__ -> Clock_CLID_UpdateIntegral(id__,x__,
									          const_SpeedPID_S_P,
									          const_SpeedPID_S_I,
									          const_SpeedPID_S_maxIntegral)
							[]
							terminate -> SKIP,Clock_CLID_UpdateIntegral(id__,clock_type_plus(x__,1,CLID_UpdateIntegral_clock_type(id__,
									          const_SpeedPID_S_P,
									          const_SpeedPID_S_I,
									          const_SpeedPID_S_maxIntegral)),
									          const_SpeedPID_S_P,
									          const_SpeedPID_S_I,
									          const_SpeedPID_S_maxIntegral))
					Clock_CLID_Read(id__,x__,
							          const_SpeedPID_S_P,
							          const_SpeedPID_S_I,
							          const_SpeedPID_S_maxIntegral) = 
						TimeOut_1(
							Read::entered -> Clock_CLID_Read(id__,0,
									          const_SpeedPID_S_P,
									          const_SpeedPID_S_I,
									          const_SpeedPID_S_maxIntegral)
							[]
							get_CLID_Read!x__ -> Clock_CLID_Read(id__,x__,
									          const_SpeedPID_S_P,
									          const_SpeedPID_S_I,
									          const_SpeedPID_S_maxIntegral)
							[]
							terminate -> SKIP,Clock_CLID_Read(id__,clock_type_plus(x__,1,CLID_Read_clock_type(id__,
									          const_SpeedPID_S_P,
									          const_SpeedPID_S_I,
									          const_SpeedPID_S_maxIntegral)),
									          const_SpeedPID_S_P,
									          const_SpeedPID_S_I,
									          const_SpeedPID_S_maxIntegral))
					Clock_CLID_UpdateOutput(id__,x__,
							          const_SpeedPID_S_P,
							          const_SpeedPID_S_I,
							          const_SpeedPID_S_maxIntegral) = 
						TimeOut_1(
							UpdateOutput::entered -> Clock_CLID_UpdateOutput(id__,0,
									          const_SpeedPID_S_P,
									          const_SpeedPID_S_I,
									          const_SpeedPID_S_maxIntegral)
							[]
							get_CLID_UpdateOutput!x__ -> Clock_CLID_UpdateOutput(id__,x__,
									          const_SpeedPID_S_P,
									          const_SpeedPID_S_I,
									          const_SpeedPID_S_maxIntegral)
							[]
							terminate -> SKIP,Clock_CLID_UpdateOutput(id__,clock_type_plus(x__,1,CLID_UpdateOutput_clock_type(id__,
									          const_SpeedPID_S_P,
									          const_SpeedPID_S_I,
									          const_SpeedPID_S_maxIntegral)),
									          const_SpeedPID_S_P,
									          const_SpeedPID_S_I,
									          const_SpeedPID_S_maxIntegral))
					
					StateClocks(id__,
							          const_SpeedPID_S_P,
							          const_SpeedPID_S_I,
							          const_SpeedPID_S_maxIntegral) = dbisim(Clock_CLID_UpdateIntegral(id__,0,
							          const_SpeedPID_S_P,
							          const_SpeedPID_S_I,
							          const_SpeedPID_S_maxIntegral))
					[| { terminate } |] (
					dbisim(Clock_CLID_Read(id__,0,
							          const_SpeedPID_S_P,
							          const_SpeedPID_S_I,
							          const_SpeedPID_S_maxIntegral))
					[| { terminate } |] (
					dbisim(Clock_CLID_UpdateOutput(id__,0,
							          const_SpeedPID_S_P,
							          const_SpeedPID_S_I,
							          const_SpeedPID_S_maxIntegral))
					)
					)
					
					stateClockSync = {|get_CLID_UpdateIntegral,UpdateIntegral::entered,get_CLID_Read,Read::entered,get_CLID_UpdateOutput,UpdateOutput::entered|}
					
					-- Shared memory
					-- Shared memory variables
					
					-- sharedVarMemory process
					sharedVarMemory(id__,
							    const_SpeedPID_S_P,
							    const_SpeedPID_S_I,
							    const_SpeedPID_S_maxIntegral) = terminate -> SKIP
					
					sharedVarSync = {||}
					
					sharedVarHide = {||}
					}
			endmodule
			module stm_ref3
			exports
				transparent diamond
				transparent sbisim
				transparent dbisim
				transparent chase
			
				-- Transition identifiers
				-- declaring identifiers of transitions
				datatype NIDS = 
				              NID_i0|
				              NID_Read|
				              NID_UpdateOutput
				
				channel internal__ : NIDS
				
				-- Flow channels		
				channel interrupt
				channel exited
				channel exit
				channel terminate
				
				-- Variable channels
				channel get_currRotationOut, set_currRotationOut, setL_currRotationOut, setR_currRotationOut: core_real
				channel get_currDiff, set_currDiff, setL_currDiff, setR_currDiff: core_real
				
				-- Shared variable channels
				
				-- Local variable channels for defined operations that are required by the state machine
				
				-- Declaring state machine events
				channel rdiff__: NIDS.InOut.core_real
				channel rdiff: InOut.core_real
				channel rotationOutputE__: NIDS.InOut.core_real
				channel rotationOutputE: InOut.core_real
				
				-- Declaring call and ret events for undefined operations
				
				enterSS = {|
				i0::enter,
				Read::enter,
				UpdateOutput::enter
				|}
				
				enteredSS = 	{|
				Read::entered,
				UpdateOutput::entered
				|}
				
				internal_events = union(enteredSS,union(enterSS,{|interrupt,exited|}))
				
				shared_variable_events = {|
				|}
				
				-- channel set with all visible events
				sem__events = {|
					terminate
				,	rdiff,
					rotationOutputE
					|}
				
				channel clockReset, clockResetL, clockResetR 
				
				localClockResets = {||}
				
				
				channel get_CLID_UpdateOutput : core_clock_type 
				channel get_CLID_Read : core_clock_type 
				--channel increment__
				
				CLID_UpdateOutput_clock_type(id__,
						          const_RotationPID_S_D) = 
					let
						max = (clock_type_max(Union({
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_Read_clock_type(id__,
						          const_RotationPID_S_D) = 
					let
						max = (clock_type_max(Union({
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				
			
					-- Nodes --
					-- declaring all nodes
					
					----------------------------------------------------------------------
					-- Initial: i0
					module i0
					exports
					
						channel enter, interrupt
						
						Timed(OneStep) {
							D__(id__,
									    const_RotationPID_S_D) = 
								dbisim(let
									Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
									
									Termination = terminate -> SKIP
									
									Active 		= share__choice(interrupt -> SKIP) ; Inactive
								within
									Inactive [| {terminate} |> SKIP)
							
							VS_O__(id__,
									    const_RotationPID_S_D) = D__(id__,
									    const_RotationPID_S_D)
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: Read
					module Read
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_RotationPID_S_D) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_RotationPID_S_D) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_RotationPID_S_D) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: UpdateOutput
					module UpdateOutput
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_RotationPID_S_D) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(share__choice(get_currDiff?currDiff -> true & (share__choice(set_currRotationOut!Mult(const_RotationPID_S_D, currDiff, core_real) -> SKIP)))) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_RotationPID_S_D) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(share__choice(get_currDiff?currDiff -> true & (share__choice(set_currRotationOut!Mult(const_RotationPID_S_D, currDiff, core_real) -> SKIP)))) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_RotationPID_S_D) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					-- END of Nodes --
					
					Timed(OneStep) {
					-- Operation calls --
					-- Only the undefined operations are declared here.
					-- If the state machine is in isolation, all required operations will be undefined.
					-- If it is in the context of a controller, the required operations not provided by the
					-- controller will be declared here, and the defined operations will be defined in the
					-- context of the Controller module, and therefore within scope of the state machine module.
					
					-- END of Operation calls --
				
					-- STM processes
					STM(id__,
							    const_RotationPID_S_D) = prioritise(-- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
					( 
						(
							(
								(IteratedStateful(id__,
										    const_RotationPID_S_D) \ {terminate} ; share__choice(terminate -> SKIP))
							 	[[ share__ <- x__ | x__ <- {||} ]]
							)
						[| {share__} |]
						SKIP
						)
						[| union(sharedVarSync,{terminate}) |]
						dbisim(sharedVarMemory(id__,
								    const_RotationPID_S_D))
					)\sharedVarHide
					,<{terminate},{tock}>)
					
					STM_VS_O(id__,
							    const_RotationPID_S_D) = prioritise(-- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
					( 
						(
							(
								(IteratedStateful_VS_O(id__,
										    const_RotationPID_S_D) \ {terminate} ; share__choice(terminate -> SKIP))
							 	[[ share__ <- x__ | x__ <- {||} ]]
							)
						[| {share__} |]
						SKIP
						)
						[| union(sharedVarSync,{terminate}) |]
						dbisim(sharedVarMemory(id__,
								    const_RotationPID_S_D))
					)\sharedVarHide
					,<{terminate},{tock}>)
					
					-- Transitions
					Transitions(id__,
							    const_RotationPID_S_D) = ((let
						Trans = TimeOut_1(
							 (share__ -> SKIP
							 [] dbisim((true)&(internal__!NID_i0 -> SKIP ;  ((SKIP ; Read::enter -> SKIP))))
							 [] dbisim((true)&(rdiff__!NID_Read.in?currDiff:{currDiff|currDiff <- core_real, true} -> share__choice(set_currDiff!currDiff -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; UpdateOutput::enter -> SKIP)))
							 [] dbisim((true)&(internal__!NID_UpdateOutput -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(get_currRotationOut?currRotationOut -> true&(share__choice(rotationOutputE.out!currRotationOut -> SKIP))) ; Read::enter -> SKIP)))
							 []
							 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
							 []
							 terminate -> SKIP
							 )
						,SKIP);Trans
					within
						Trans [|{terminate}|> SKIP
					)
					)
					
					-- Stateful
					-- RULE: Stateful(stm:StateMachineBody) : CSPProcess
					
					-- Named process definitions
					MachineBody(id__,
							    const_RotationPID_S_D) = 
						dbisim((
						let
							finalNodesEntered = {||}
						within
							(dbisim((dbisim((let
								-- IMPLEMENTATION NOTE:
								-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
								-- modules for defining the semantics of each node.
								enterSS = {|
								i0::enter,
								Read::enter,
								UpdateOutput::enter
								|}
								hideSet = union(enterSS,{|exit,exited,internal__|})
							within 
								((let
									-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
									-- because CSPM modules are used for the semantics of Node.
									flowevts = union(enterSS,{|exit,exited,interrupt|})
									transSync = {|internal__.NID_i0,rdiff__.NID_Read.in,internal__.NID_UpdateOutput|}
								within
									((
									 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
									   i0::D__(id__,
									   		    const_RotationPID_S_D)
									   [| { share__, terminate } |] (
									   Read::D__(id__,
									   		    const_RotationPID_S_D)
									   [| { share__, terminate } |] (
									   UpdateOutput::D__(id__,
									   		    const_RotationPID_S_D)
									   )
									   )
									 )
									 [[Read::interrupt <- x__ | x__ <- {|interrupt,rdiff__.NID_Read.in|}]]
									 [[UpdateOutput::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_UpdateOutput|}]]
									 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
									 )
									  [[ share__ <- x__ | x__ <- {| share__,setR_currDiff |} ]] 
									 )
									 [| union(union(union(flowevts,transSync),{terminate}),{|share__
									 			,setR_currDiff
									 			|}) |]
									 ((i0::enter -> Transitions(id__,
									 		    const_RotationPID_S_D))
									  [[ share__ <- x__ | x__ <- {| share__ |} ]]
									  [[set_currDiff <- setR_currDiff]]
									 )
									)
									 [[setR_currDiff <- set_currDiff]]
									)
								)
								 \ hideSet)
								[[
									rdiff__.x____ <- rdiff,
									rotationOutputE__.x____ <- rotationOutputE
									| x____ <- NIDS
								]]
							)
							)
							 [| union(stateClockSync,{terminate}) |]
							 StateClocks(id__,
							 		          const_RotationPID_S_D)
							)\diff(stateClockSync,enteredSS))
							 [| {| interrupt |} |] SKIP)
						)
						)
					
					Behaviour(id__,
							    const_RotationPID_S_D) = 
						dbisim((let
							stateClockSync = {|get_CLID_UpdateOutput,UpdateOutput::entered,get_CLID_Read,Read::entered|}
						 within
							(MachineBody(id__,
									    const_RotationPID_S_D) [| union(stateClockSync,{terminate}) |] StateClocks(id__,
									          const_RotationPID_S_D)) \ union(stateClockSync,enteredSS)
						)
						)
					
					IteratedBehaviour(id__,
							    const_RotationPID_S_D) = 
						dbisim((let
							stateClockSync = {|get_CLID_UpdateOutput,UpdateOutput::entered,get_CLID_Read,Read::entered|}
						 within
							(dbisim(
								sbisim(
									dbisim(
										sbisim(
											MachineBody(id__,
													    const_RotationPID_S_D)
											[| {|get_CLID_Read,Read::entered,terminate|} |]
											dbisim(Clock_CLID_Read(id__,0,
													          const_RotationPID_S_D))
										)\{|get_CLID_Read|}
									)
									[| {|get_CLID_UpdateOutput,UpdateOutput::entered,terminate|} |]
									dbisim(Clock_CLID_UpdateOutput(id__,0,
											          const_RotationPID_S_D))
								)\{|get_CLID_UpdateOutput|}
							)
							) \ union(stateClockSync,enteredSS)
						)
						)
					
					Stateful(id__,
							    const_RotationPID_S_D) = 
						((let
							getsetLocalChannels = {|get_currRotationOut,set_currRotationOut,
							get_currDiff,set_currDiff|}
							clockSync = {||}
						within
							(Behaviour(id__,
									    const_RotationPID_S_D) 
							 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
							 (varMemory(id__,
							 		    const_RotationPID_S_D) [| {terminate} |] Clocks(id__,
							 		          const_RotationPID_S_D))
						 	)\union(getsetLocalChannels,clockSync)
						)
						)
					
					IteratedStateful(id__,
							    const_RotationPID_S_D) =
						(dbisim(
							sbisim(
								dbisim(
									sbisim(
										IteratedBehaviour(id__,
												    const_RotationPID_S_D)
										[| {|get_currDiff,set_currDiff,terminate|} |]
										Memory_currDiff(0)
									)\{|get_currDiff,set_currDiff|}
								)
								[| {|get_currRotationOut,set_currRotationOut,terminate|} |]
								Memory_currRotationOut(0)
							)\{|get_currRotationOut,set_currRotationOut|}
						)
						)
					
					-- Visible counterparts
					MachineBody_VS_O(id__,
							    const_RotationPID_S_D) = 
						dbisim((
						let
							finalNodesEntered = {||}
						within
							(dbisim((dbisim((let
								-- IMPLEMENTATION NOTE:
								-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
								-- modules for defining the semantics of each node.
								enterSS = {|
								i0::enter,
								Read::enter,
								UpdateOutput::enter
								|}
								hideSet = union(enterSS,{|exit,exited,internal__|})
							within 
								((let
									-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
									-- because CSPM modules are used for the semantics of Node.
									flowevts = union(enterSS,{|exit,exited,interrupt|})
									transSync = {|internal__.NID_i0,rdiff__.NID_Read.in,internal__.NID_UpdateOutput|}
								within
									((
									 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
									   i0::VS_O__(id__,
									   		    const_RotationPID_S_D)
									   [| { share__, terminate } |] (
									   Read::VS_O__(id__,
									   		    const_RotationPID_S_D)
									   [| { share__, terminate } |] (
									   UpdateOutput::VS_O__(id__,
									   		    const_RotationPID_S_D)
									   )
									   )
									 )
									 [[Read::interrupt <- x__ | x__ <- {|interrupt,rdiff__.NID_Read.in|}]]
									 [[UpdateOutput::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_UpdateOutput|}]]
									 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
									 )
									  [[ share__ <- x__ | x__ <- {| share__,setR_currDiff |} ]] 
									 )
									 [| union(union(union(flowevts,transSync),{terminate}),{|share__
									 			,setR_currDiff
									 			|}) |]
									 ((i0::enter -> Transitions(id__,
									 		    const_RotationPID_S_D))
									  [[ share__ <- x__ | x__ <- {| share__ |} ]]
									  [[set_currDiff <- setR_currDiff]]
									 )
									)
									 [[setR_currDiff <- set_currDiff]]
									)
								)
								 \ hideSet)
								[[
									rdiff__.x____ <- rdiff,
									rotationOutputE__.x____ <- rotationOutputE
									| x____ <- NIDS
								]]
							)
							)
							 [| union(stateClockSync,{terminate}) |]
							 StateClocks(id__,
							 		          const_RotationPID_S_D)
							)\diff(stateClockSync,enteredSS))
							 [| {| interrupt |} |] SKIP)
						)
						)
					
					Behaviour_VS_O(id__,
							    const_RotationPID_S_D) = 
						dbisim((let
							stateClockSync = {|get_CLID_UpdateOutput,UpdateOutput::entered,get_CLID_Read,Read::entered|}
						 within
							(MachineBody_VS_O(id__,
									    const_RotationPID_S_D) [| union(stateClockSync,{terminate}) |] StateClocks(id__,
									          const_RotationPID_S_D)) \ diff(union(stateClockSync,enteredSS),enteredSS)
						)
						)
					
					IteratedBehaviour_VS_O(id__,
							    const_RotationPID_S_D) = 
						dbisim((let
							stateClockSync = {|get_CLID_UpdateOutput,UpdateOutput::entered,get_CLID_Read,Read::entered|}
						 within
							(dbisim(
								sbisim(
									dbisim(
										sbisim(
											MachineBody_VS_O(id__,
													    const_RotationPID_S_D)
											[| {|get_CLID_Read,Read::entered,terminate|} |]
											dbisim(Clock_CLID_Read(id__,0,
													          const_RotationPID_S_D))
										)\{|get_CLID_Read|}
									)
									[| {|get_CLID_UpdateOutput,UpdateOutput::entered,terminate|} |]
									dbisim(Clock_CLID_UpdateOutput(id__,0,
											          const_RotationPID_S_D))
								)\{|get_CLID_UpdateOutput|}
							)
							) \ diff(union(stateClockSync,enteredSS),enteredSS)
						)
						)
					
					Stateful_VS_O(id__,
							    const_RotationPID_S_D) = 
						dbisim((let
							getsetLocalChannels = {|get_currRotationOut,set_currRotationOut,
							get_currDiff,set_currDiff|}
							clockSync = {||}
						within
							(Behaviour_VS_O(id__,
									    const_RotationPID_S_D) 
							 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
							 (varMemory(id__,
							 		    const_RotationPID_S_D) [| {terminate} |] Clocks(id__,
							 		          const_RotationPID_S_D))
						 	)\union(getsetLocalChannels,clockSync)
						)
						)
					
					IteratedStateful_VS_O(id__,
							    const_RotationPID_S_D) =
						(dbisim(
							sbisim(
								dbisim(
									sbisim(
										IteratedBehaviour_VS_O(id__,
												    const_RotationPID_S_D)
										[| {|get_currDiff,set_currDiff,terminate|} |]
										Memory_currDiff(0)
									)\{|get_currDiff,set_currDiff|}
								)
								[| {|get_currRotationOut,set_currRotationOut,terminate|} |]
								Memory_currRotationOut(0)
							)\{|get_currRotationOut,set_currRotationOut|}
						)
						)
					
					-- END
					
					-- Memory
					-- Memory variables
					Memory_currRotationOut(currRotationOut) =
						get_currRotationOut!currRotationOut -> Memory_currRotationOut(currRotationOut)
						[]
						set_currRotationOut?x__ -> Memory_currRotationOut(x__)
						[]
						terminate -> SKIP
					Memory_currDiff(currDiff) =
						get_currDiff!currDiff -> Memory_currDiff(currDiff)
						[]
						set_currDiff?x__ -> Memory_currDiff(x__)
						[]
						terminate -> SKIP
					
					-- varMemory process
					varMemory(id__,
							    const_RotationPID_S_D) = Memory_currRotationOut(0)
					[| { terminate } |] (
					Memory_currDiff(0)
					)
					
					getsetLocalChannels = {|get_currRotationOut,set_currRotationOut,get_currDiff,set_currDiff|}
					
					-- Definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
					FVS__(id__,
							    const_RotationPID_S_D) = STM_VS_O(id__,
							    const_RotationPID_S_D) \ localClockResets
					D__(id__,
							    const_RotationPID_S_D) = timed_priority(STM(id__,
							    const_RotationPID_S_D) \ union(internal_events,localClockResets))
					O__(id__,
							    const_RotationPID_S_D) = dbisim(D__(id__,
							    const_RotationPID_S_D))
					VS__(id__,
							    const_RotationPID_S_D) = FVS__(id__,
							    const_RotationPID_S_D)
					VS_O__(id__,
							    const_RotationPID_S_D) = dbisim(FVS__(id__,
							    const_RotationPID_S_D))
					HEXT__(id__,
							    const_RotationPID_S_D) = O__(id__,
							    const_RotationPID_S_D) [|shared_variable_events|] SKIP
					FVS_C__(id__,
							    const_RotationPID_S_D) = dbisim(timed_priority(STM(id__,
							    const_RotationPID_S_D) \ internal_events))
					HUP__(id__,
							    const_RotationPID_S_D) = timed_priority(O__(id__,
							    const_RotationPID_S_D) [|{share__}|] SKIP)
					
					-- Clocks
					
					Clocks(id__,
							          const_RotationPID_S_D) = terminate -> SKIP
					
					clockSync = {||}
					
					Clock_CLID_UpdateOutput(id__,x__,
							          const_RotationPID_S_D) = 
						TimeOut_1(
							UpdateOutput::entered -> Clock_CLID_UpdateOutput(id__,0,
									          const_RotationPID_S_D)
							[]
							get_CLID_UpdateOutput!x__ -> Clock_CLID_UpdateOutput(id__,x__,
									          const_RotationPID_S_D)
							[]
							terminate -> SKIP,Clock_CLID_UpdateOutput(id__,clock_type_plus(x__,1,CLID_UpdateOutput_clock_type(id__,
									          const_RotationPID_S_D)),
									          const_RotationPID_S_D))
					Clock_CLID_Read(id__,x__,
							          const_RotationPID_S_D) = 
						TimeOut_1(
							Read::entered -> Clock_CLID_Read(id__,0,
									          const_RotationPID_S_D)
							[]
							get_CLID_Read!x__ -> Clock_CLID_Read(id__,x__,
									          const_RotationPID_S_D)
							[]
							terminate -> SKIP,Clock_CLID_Read(id__,clock_type_plus(x__,1,CLID_Read_clock_type(id__,
									          const_RotationPID_S_D)),
									          const_RotationPID_S_D))
					
					StateClocks(id__,
							          const_RotationPID_S_D) = dbisim(Clock_CLID_UpdateOutput(id__,0,
							          const_RotationPID_S_D))
					[| { terminate } |] (
					dbisim(Clock_CLID_Read(id__,0,
							          const_RotationPID_S_D))
					)
					
					stateClockSync = {|get_CLID_UpdateOutput,UpdateOutput::entered,get_CLID_Read,Read::entered|}
					
					-- Shared memory
					-- Shared memory variables
					
					-- sharedVarMemory process
					sharedVarMemory(id__,
							    const_RotationPID_S_D) = terminate -> SKIP
					
					sharedVarSync = {||}
					
					sharedVarHide = {||}
					}
			endmodule
			
			Timed(OneStep) {
					-- undefined operations
					CALL__setLeftMotorSpeed(id__,
							    param_speed) 	= setLeftMotorSpeedCall.param_speed -> SKIP
					CALL__enableInterrupts(id__) 	= enableInterruptsCall -> SKIP
					CALL__setRightMotorSpeed(id__,
							    param_speed) 	= setRightMotorSpeedCall.param_speed -> SKIP
					CALL__disableInterrupts(id__) 	= disableInterruptsCall -> SKIP
					
					-- declaring controller memory
					Memory(id__) = SKIP
					
					D__(id__,
							    const_Segway_P2_SegwayController_stm_ref0_maxAngle,
							    const_Segway_P2_SegwayController_stm_ref0_loopTime,
							    const_Segway_P2_SegwayController_stm_ref0_startupDelay,
							    const_Segway_P2_SegwayController_stm_ref0_speedUpdate,
							    const_Segway_P2_SegwayController_stm_ref0_rotationUpdate,
							    const_Segway_P2_SegwayController_stm_ref0_motorBudget,
							    const_Segway_P2_SegwayController_stm_ref0_angleBudget,
							    const_Segway_P2_SegwayController_stm_ref0_speedBudget,
							    const_Segway_P2_SegwayController_stm_ref0_rotationBudget,
							    const_Segway_P2_SegwayController_stm_ref1_P,
							    const_Segway_P2_SegwayController_stm_ref1_D,
							    const_Segway_P2_SegwayController_stm_ref2_P,
							    const_Segway_P2_SegwayController_stm_ref2_I,
							    const_Segway_P2_SegwayController_stm_ref2_maxIntegral,
							    const_Segway_P2_SegwayController_stm_ref3_D) = prioritise(	((
							(
								let
									const_BalanceSTM_P2_maxAngle = const_Segway_P2_SegwayController_stm_ref0_maxAngle
									const_BalanceSTM_P2_loopTime = const_Segway_P2_SegwayController_stm_ref0_loopTime
									const_BalanceSTM_P2_startupDelay = const_Segway_P2_SegwayController_stm_ref0_startupDelay
									const_BalanceSTM_P2_speedUpdate = const_Segway_P2_SegwayController_stm_ref0_speedUpdate
									const_BalanceSTM_P2_rotationUpdate = const_Segway_P2_SegwayController_stm_ref0_rotationUpdate
									const_BalanceSTM_P2_motorBudget = const_Segway_P2_SegwayController_stm_ref0_motorBudget
									const_BalanceSTM_P2_angleBudget = const_Segway_P2_SegwayController_stm_ref0_angleBudget
									const_BalanceSTM_P2_speedBudget = const_Segway_P2_SegwayController_stm_ref0_speedBudget
									const_BalanceSTM_P2_rotationBudget = const_Segway_P2_SegwayController_stm_ref0_rotationBudget
								within 
								stm_ref0::D__(id__,
										    const_BalanceSTM_P2_maxAngle,
										    const_BalanceSTM_P2_loopTime,
										    const_BalanceSTM_P2_startupDelay,
										    const_BalanceSTM_P2_speedUpdate,
										    const_BalanceSTM_P2_rotationUpdate,
										    const_BalanceSTM_P2_motorBudget,
										    const_BalanceSTM_P2_angleBudget,
										    const_BalanceSTM_P2_speedBudget,
										    const_BalanceSTM_P2_rotationBudget)[[
									stm_ref0::terminate <- terminate,
									stm_ref0::leftMotorVelocity <- leftMotorVelocity,
									stm_ref0::rightMotorVelocity <- rightMotorVelocity,
									stm_ref0::angle <- angle,
									stm_ref0::gyroX <- gyroX,
									stm_ref0::gyroY <- gyroY,
									stm_ref0::gyroZ <- gyroZ,
									stm_ref0::angleOutputE.in <- stm_ref1::angleOutputE.out,
									stm_ref0::angleOutputE.out <- stm_ref1::angleOutputE.in,
									stm_ref0::speedOutputE.in <- stm_ref2::speedOutputE.out,
									stm_ref0::speedOutputE.out <- stm_ref2::speedOutputE.in,
									stm_ref0::rotationOutputE.in <- stm_ref3::rotationOutputE.out,
									stm_ref0::rotationOutputE.out <- stm_ref3::rotationOutputE.in,
									stm_ref0::setLeftMotorSpeedCall <- setLeftMotorSpeedCall,
									stm_ref0::enableInterruptsCall <- enableInterruptsCall,
									stm_ref0::setRightMotorSpeedCall <- setRightMotorSpeedCall,
									stm_ref0::disableInterruptsCall <- disableInterruptsCall
								]]
							)
								[|{|terminate, stm_ref1::angleOutputE, stm_ref0::anewError, stm_ref0::adiff, stm_ref2::speedOutputE, stm_ref0::snewError, stm_ref3::rotationOutputE, stm_ref0::rdiff|}|]
							(
								(
									let
										const_AnglePID_S_P = const_Segway_P2_SegwayController_stm_ref1_P
										const_AnglePID_S_D = const_Segway_P2_SegwayController_stm_ref1_D
									within 
									stm_ref1::D__(id__,
											    const_AnglePID_S_P,
											    const_AnglePID_S_D)[[
										stm_ref1::terminate <- terminate,
										stm_ref1::anewError.in <- stm_ref0::anewError.out,
										stm_ref1::anewError.out <- stm_ref0::anewError.in,
										stm_ref1::adiff.in <- stm_ref0::adiff.out,
										stm_ref1::adiff.out <- stm_ref0::adiff.in
									]]
								)
									[|{|terminate|}|]
								(
									(
										let
											const_SpeedPID_S_P = const_Segway_P2_SegwayController_stm_ref2_P
											const_SpeedPID_S_I = const_Segway_P2_SegwayController_stm_ref2_I
											const_SpeedPID_S_maxIntegral = const_Segway_P2_SegwayController_stm_ref2_maxIntegral
										within 
										stm_ref2::D__(id__,
												    const_SpeedPID_S_P,
												    const_SpeedPID_S_I,
												    const_SpeedPID_S_maxIntegral)[[
											stm_ref2::terminate <- terminate,
											stm_ref2::snewError.in <- stm_ref0::snewError.out,
											stm_ref2::snewError.out <- stm_ref0::snewError.in
										]]
									)
										[|{|terminate|}|]
									(
										let
											const_RotationPID_S_D = const_Segway_P2_SegwayController_stm_ref3_D
										within 
										stm_ref3::D__(id__,
												    const_RotationPID_S_D)[[
											stm_ref3::terminate <- terminate,
											stm_ref3::rdiff.in <- stm_ref0::rdiff.out,
											stm_ref3::rdiff.out <- stm_ref0::rdiff.in
										]]
									)
								)
								\diff(
									{|terminate|},
									{|terminate|}
								)
							)
							\diff(
								{|terminate|},
								{|terminate|}
							)
						)
						\diff(
							{|terminate, stm_ref1::angleOutputE, stm_ref0::anewError, stm_ref0::adiff, stm_ref2::speedOutputE, stm_ref0::snewError, stm_ref3::rotationOutputE, stm_ref0::rdiff|},
							{|terminate|}
						)
							[|
								union(
									{|
									|},
									{|
									|}
								)
							|]
						Memory(id__)
					)
					\ union(
						{|
						|},
						{|
						|}
					)
					[|{|terminate|}|>SKIP
					,<union(visibleMemoryEvents,{terminate}),{tock}>)
					
					-- VS version
					VS__(id__,
							    const_Segway_P2_SegwayController_stm_ref0_maxAngle,
							    const_Segway_P2_SegwayController_stm_ref0_loopTime,
							    const_Segway_P2_SegwayController_stm_ref0_startupDelay,
							    const_Segway_P2_SegwayController_stm_ref0_speedUpdate,
							    const_Segway_P2_SegwayController_stm_ref0_rotationUpdate,
							    const_Segway_P2_SegwayController_stm_ref0_motorBudget,
							    const_Segway_P2_SegwayController_stm_ref0_angleBudget,
							    const_Segway_P2_SegwayController_stm_ref0_speedBudget,
							    const_Segway_P2_SegwayController_stm_ref0_rotationBudget,
							    const_Segway_P2_SegwayController_stm_ref1_P,
							    const_Segway_P2_SegwayController_stm_ref1_D,
							    const_Segway_P2_SegwayController_stm_ref2_P,
							    const_Segway_P2_SegwayController_stm_ref2_I,
							    const_Segway_P2_SegwayController_stm_ref2_maxIntegral,
							    const_Segway_P2_SegwayController_stm_ref3_D) = prioritise(	((
							(
								let
									const_BalanceSTM_P2_maxAngle = const_Segway_P2_SegwayController_stm_ref0_maxAngle
									const_BalanceSTM_P2_loopTime = const_Segway_P2_SegwayController_stm_ref0_loopTime
									const_BalanceSTM_P2_startupDelay = const_Segway_P2_SegwayController_stm_ref0_startupDelay
									const_BalanceSTM_P2_speedUpdate = const_Segway_P2_SegwayController_stm_ref0_speedUpdate
									const_BalanceSTM_P2_rotationUpdate = const_Segway_P2_SegwayController_stm_ref0_rotationUpdate
									const_BalanceSTM_P2_motorBudget = const_Segway_P2_SegwayController_stm_ref0_motorBudget
									const_BalanceSTM_P2_angleBudget = const_Segway_P2_SegwayController_stm_ref0_angleBudget
									const_BalanceSTM_P2_speedBudget = const_Segway_P2_SegwayController_stm_ref0_speedBudget
									const_BalanceSTM_P2_rotationBudget = const_Segway_P2_SegwayController_stm_ref0_rotationBudget
								within 
								stm_ref0::VS__(id__,
										    const_BalanceSTM_P2_maxAngle,
										    const_BalanceSTM_P2_loopTime,
										    const_BalanceSTM_P2_startupDelay,
										    const_BalanceSTM_P2_speedUpdate,
										    const_BalanceSTM_P2_rotationUpdate,
										    const_BalanceSTM_P2_motorBudget,
										    const_BalanceSTM_P2_angleBudget,
										    const_BalanceSTM_P2_speedBudget,
										    const_BalanceSTM_P2_rotationBudget)[[
									stm_ref0::terminate <- terminate,
									stm_ref0::leftMotorVelocity <- leftMotorVelocity,
									stm_ref0::rightMotorVelocity <- rightMotorVelocity,
									stm_ref0::angle <- angle,
									stm_ref0::gyroX <- gyroX,
									stm_ref0::gyroY <- gyroY,
									stm_ref0::gyroZ <- gyroZ,
									stm_ref0::angleOutputE.in <- stm_ref1::angleOutputE.out,
									stm_ref0::angleOutputE.out <- stm_ref1::angleOutputE.in,
									stm_ref0::speedOutputE.in <- stm_ref2::speedOutputE.out,
									stm_ref0::speedOutputE.out <- stm_ref2::speedOutputE.in,
									stm_ref0::rotationOutputE.in <- stm_ref3::rotationOutputE.out,
									stm_ref0::rotationOutputE.out <- stm_ref3::rotationOutputE.in,
									stm_ref0::setLeftMotorSpeedCall <- setLeftMotorSpeedCall,
									stm_ref0::enableInterruptsCall <- enableInterruptsCall,
									stm_ref0::setRightMotorSpeedCall <- setRightMotorSpeedCall,
									stm_ref0::disableInterruptsCall <- disableInterruptsCall
								]]
							)
								[|{|terminate, stm_ref1::angleOutputE, stm_ref0::anewError, stm_ref0::adiff, stm_ref2::speedOutputE, stm_ref0::snewError, stm_ref3::rotationOutputE, stm_ref0::rdiff|}|]
							(
								(
									let
										const_AnglePID_S_P = const_Segway_P2_SegwayController_stm_ref1_P
										const_AnglePID_S_D = const_Segway_P2_SegwayController_stm_ref1_D
									within 
									stm_ref1::VS__(id__,
											    const_AnglePID_S_P,
											    const_AnglePID_S_D)[[
										stm_ref1::terminate <- terminate,
										stm_ref1::anewError.in <- stm_ref0::anewError.out,
										stm_ref1::anewError.out <- stm_ref0::anewError.in,
										stm_ref1::adiff.in <- stm_ref0::adiff.out,
										stm_ref1::adiff.out <- stm_ref0::adiff.in
									]]
								)
									[|{|terminate|}|]
								(
									(
										let
											const_SpeedPID_S_P = const_Segway_P2_SegwayController_stm_ref2_P
											const_SpeedPID_S_I = const_Segway_P2_SegwayController_stm_ref2_I
											const_SpeedPID_S_maxIntegral = const_Segway_P2_SegwayController_stm_ref2_maxIntegral
										within 
										stm_ref2::VS__(id__,
												    const_SpeedPID_S_P,
												    const_SpeedPID_S_I,
												    const_SpeedPID_S_maxIntegral)[[
											stm_ref2::terminate <- terminate,
											stm_ref2::snewError.in <- stm_ref0::snewError.out,
											stm_ref2::snewError.out <- stm_ref0::snewError.in
										]]
									)
										[|{|terminate|}|]
									(
										let
											const_RotationPID_S_D = const_Segway_P2_SegwayController_stm_ref3_D
										within 
										stm_ref3::VS__(id__,
												    const_RotationPID_S_D)[[
											stm_ref3::terminate <- terminate,
											stm_ref3::rdiff.in <- stm_ref0::rdiff.out,
											stm_ref3::rdiff.out <- stm_ref0::rdiff.in
										]]
									)
								)
								\diff(
									{|terminate|},
									{|terminate|}
								)
							)
							\diff(
								{|terminate|},
								{|terminate|}
							)
						)
						\diff(
							{|terminate, stm_ref1::angleOutputE, stm_ref0::anewError, stm_ref0::adiff, stm_ref2::speedOutputE, stm_ref0::snewError, stm_ref3::rotationOutputE, stm_ref0::rdiff|},
							{|terminate|}
						)
							[|
								union(
									{|
									|},
									{|
									|}
								)
							|]
						Memory(id__)
					)
					\ union(
						{|
						|},
						{|
						|}
					)
					[|{|terminate|}|>SKIP
					,<union(visibleMemoryEvents,{terminate}),{tock}>)
				
					-- O version (optimised) THESE TWO PROCESSES SHOULD BE KEPT IN SYNC WITH THE ABOVE TWO
					O__(id__,
							    const_Segway_P2_SegwayController_stm_ref0_maxAngle,
							    const_Segway_P2_SegwayController_stm_ref0_loopTime,
							    const_Segway_P2_SegwayController_stm_ref0_startupDelay,
							    const_Segway_P2_SegwayController_stm_ref0_speedUpdate,
							    const_Segway_P2_SegwayController_stm_ref0_rotationUpdate,
							    const_Segway_P2_SegwayController_stm_ref0_motorBudget,
							    const_Segway_P2_SegwayController_stm_ref0_angleBudget,
							    const_Segway_P2_SegwayController_stm_ref0_speedBudget,
							    const_Segway_P2_SegwayController_stm_ref0_rotationBudget,
							    const_Segway_P2_SegwayController_stm_ref1_P,
							    const_Segway_P2_SegwayController_stm_ref1_D,
							    const_Segway_P2_SegwayController_stm_ref2_P,
							    const_Segway_P2_SegwayController_stm_ref2_I,
							    const_Segway_P2_SegwayController_stm_ref2_maxIntegral,
							    const_Segway_P2_SegwayController_stm_ref3_D) = dbisim(prioritise(	((
							(
								let
									const_BalanceSTM_P2_maxAngle = const_Segway_P2_SegwayController_stm_ref0_maxAngle
									const_BalanceSTM_P2_loopTime = const_Segway_P2_SegwayController_stm_ref0_loopTime
									const_BalanceSTM_P2_startupDelay = const_Segway_P2_SegwayController_stm_ref0_startupDelay
									const_BalanceSTM_P2_speedUpdate = const_Segway_P2_SegwayController_stm_ref0_speedUpdate
									const_BalanceSTM_P2_rotationUpdate = const_Segway_P2_SegwayController_stm_ref0_rotationUpdate
									const_BalanceSTM_P2_motorBudget = const_Segway_P2_SegwayController_stm_ref0_motorBudget
									const_BalanceSTM_P2_angleBudget = const_Segway_P2_SegwayController_stm_ref0_angleBudget
									const_BalanceSTM_P2_speedBudget = const_Segway_P2_SegwayController_stm_ref0_speedBudget
									const_BalanceSTM_P2_rotationBudget = const_Segway_P2_SegwayController_stm_ref0_rotationBudget
								within 
								stm_ref0::O__(id__,
										    const_BalanceSTM_P2_maxAngle,
										    const_BalanceSTM_P2_loopTime,
										    const_BalanceSTM_P2_startupDelay,
										    const_BalanceSTM_P2_speedUpdate,
										    const_BalanceSTM_P2_rotationUpdate,
										    const_BalanceSTM_P2_motorBudget,
										    const_BalanceSTM_P2_angleBudget,
										    const_BalanceSTM_P2_speedBudget,
										    const_BalanceSTM_P2_rotationBudget)[[
									stm_ref0::terminate <- terminate,
									stm_ref0::leftMotorVelocity <- leftMotorVelocity,
									stm_ref0::rightMotorVelocity <- rightMotorVelocity,
									stm_ref0::angle <- angle,
									stm_ref0::gyroX <- gyroX,
									stm_ref0::gyroY <- gyroY,
									stm_ref0::gyroZ <- gyroZ,
									stm_ref0::angleOutputE.in <- stm_ref1::angleOutputE.out,
									stm_ref0::angleOutputE.out <- stm_ref1::angleOutputE.in,
									stm_ref0::speedOutputE.in <- stm_ref2::speedOutputE.out,
									stm_ref0::speedOutputE.out <- stm_ref2::speedOutputE.in,
									stm_ref0::rotationOutputE.in <- stm_ref3::rotationOutputE.out,
									stm_ref0::rotationOutputE.out <- stm_ref3::rotationOutputE.in,
									stm_ref0::setLeftMotorSpeedCall <- setLeftMotorSpeedCall,
									stm_ref0::enableInterruptsCall <- enableInterruptsCall,
									stm_ref0::setRightMotorSpeedCall <- setRightMotorSpeedCall,
									stm_ref0::disableInterruptsCall <- disableInterruptsCall
								]]
							)
								[|{|terminate, stm_ref1::angleOutputE, stm_ref0::anewError, stm_ref0::adiff, stm_ref2::speedOutputE, stm_ref0::snewError, stm_ref3::rotationOutputE, stm_ref0::rdiff|}|]
							(
								(
									let
										const_AnglePID_S_P = const_Segway_P2_SegwayController_stm_ref1_P
										const_AnglePID_S_D = const_Segway_P2_SegwayController_stm_ref1_D
									within 
									stm_ref1::O__(id__,
											    const_AnglePID_S_P,
											    const_AnglePID_S_D)[[
										stm_ref1::terminate <- terminate,
										stm_ref1::anewError.in <- stm_ref0::anewError.out,
										stm_ref1::anewError.out <- stm_ref0::anewError.in,
										stm_ref1::adiff.in <- stm_ref0::adiff.out,
										stm_ref1::adiff.out <- stm_ref0::adiff.in
									]]
								)
									[|{|terminate|}|]
								(
									(
										let
											const_SpeedPID_S_P = const_Segway_P2_SegwayController_stm_ref2_P
											const_SpeedPID_S_I = const_Segway_P2_SegwayController_stm_ref2_I
											const_SpeedPID_S_maxIntegral = const_Segway_P2_SegwayController_stm_ref2_maxIntegral
										within 
										stm_ref2::O__(id__,
												    const_SpeedPID_S_P,
												    const_SpeedPID_S_I,
												    const_SpeedPID_S_maxIntegral)[[
											stm_ref2::terminate <- terminate,
											stm_ref2::snewError.in <- stm_ref0::snewError.out,
											stm_ref2::snewError.out <- stm_ref0::snewError.in
										]]
									)
										[|{|terminate|}|]
									(
										let
											const_RotationPID_S_D = const_Segway_P2_SegwayController_stm_ref3_D
										within 
										stm_ref3::O__(id__,
												    const_RotationPID_S_D)[[
											stm_ref3::terminate <- terminate,
											stm_ref3::rdiff.in <- stm_ref0::rdiff.out,
											stm_ref3::rdiff.out <- stm_ref0::rdiff.in
										]]
									)
								)
								\diff(
									{|terminate|},
									{|terminate|}
								)
							)
							\diff(
								{|terminate|},
								{|terminate|}
							)
						)
						\diff(
							{|terminate, stm_ref1::angleOutputE, stm_ref0::anewError, stm_ref0::adiff, stm_ref2::speedOutputE, stm_ref0::snewError, stm_ref3::rotationOutputE, stm_ref0::rdiff|},
							{|terminate|}
						)
							[|
								union(
									{|
									|},
									{|
									|}
								)
							|]
						dbisim(Memory(id__))
					)
					\ union(
						{|
						|},
						{|
						|}
					)
					[|{|terminate|}|>SKIP
					,<union(visibleMemoryEvents,{terminate}),{tock}>))
									
					-- VS_O version
					VS_O__(id__,
							    const_Segway_P2_SegwayController_stm_ref0_maxAngle,
							    const_Segway_P2_SegwayController_stm_ref0_loopTime,
							    const_Segway_P2_SegwayController_stm_ref0_startupDelay,
							    const_Segway_P2_SegwayController_stm_ref0_speedUpdate,
							    const_Segway_P2_SegwayController_stm_ref0_rotationUpdate,
							    const_Segway_P2_SegwayController_stm_ref0_motorBudget,
							    const_Segway_P2_SegwayController_stm_ref0_angleBudget,
							    const_Segway_P2_SegwayController_stm_ref0_speedBudget,
							    const_Segway_P2_SegwayController_stm_ref0_rotationBudget,
							    const_Segway_P2_SegwayController_stm_ref1_P,
							    const_Segway_P2_SegwayController_stm_ref1_D,
							    const_Segway_P2_SegwayController_stm_ref2_P,
							    const_Segway_P2_SegwayController_stm_ref2_I,
							    const_Segway_P2_SegwayController_stm_ref2_maxIntegral,
							    const_Segway_P2_SegwayController_stm_ref3_D) = dbisim(prioritise(	((
							(
								let
									const_BalanceSTM_P2_maxAngle = const_Segway_P2_SegwayController_stm_ref0_maxAngle
									const_BalanceSTM_P2_loopTime = const_Segway_P2_SegwayController_stm_ref0_loopTime
									const_BalanceSTM_P2_startupDelay = const_Segway_P2_SegwayController_stm_ref0_startupDelay
									const_BalanceSTM_P2_speedUpdate = const_Segway_P2_SegwayController_stm_ref0_speedUpdate
									const_BalanceSTM_P2_rotationUpdate = const_Segway_P2_SegwayController_stm_ref0_rotationUpdate
									const_BalanceSTM_P2_motorBudget = const_Segway_P2_SegwayController_stm_ref0_motorBudget
									const_BalanceSTM_P2_angleBudget = const_Segway_P2_SegwayController_stm_ref0_angleBudget
									const_BalanceSTM_P2_speedBudget = const_Segway_P2_SegwayController_stm_ref0_speedBudget
									const_BalanceSTM_P2_rotationBudget = const_Segway_P2_SegwayController_stm_ref0_rotationBudget
								within 
								stm_ref0::VS_O__(id__,
										    const_BalanceSTM_P2_maxAngle,
										    const_BalanceSTM_P2_loopTime,
										    const_BalanceSTM_P2_startupDelay,
										    const_BalanceSTM_P2_speedUpdate,
										    const_BalanceSTM_P2_rotationUpdate,
										    const_BalanceSTM_P2_motorBudget,
										    const_BalanceSTM_P2_angleBudget,
										    const_BalanceSTM_P2_speedBudget,
										    const_BalanceSTM_P2_rotationBudget)[[
									stm_ref0::terminate <- terminate,
									stm_ref0::leftMotorVelocity <- leftMotorVelocity,
									stm_ref0::rightMotorVelocity <- rightMotorVelocity,
									stm_ref0::angle <- angle,
									stm_ref0::gyroX <- gyroX,
									stm_ref0::gyroY <- gyroY,
									stm_ref0::gyroZ <- gyroZ,
									stm_ref0::angleOutputE.in <- stm_ref1::angleOutputE.out,
									stm_ref0::angleOutputE.out <- stm_ref1::angleOutputE.in,
									stm_ref0::speedOutputE.in <- stm_ref2::speedOutputE.out,
									stm_ref0::speedOutputE.out <- stm_ref2::speedOutputE.in,
									stm_ref0::rotationOutputE.in <- stm_ref3::rotationOutputE.out,
									stm_ref0::rotationOutputE.out <- stm_ref3::rotationOutputE.in,
									stm_ref0::setLeftMotorSpeedCall <- setLeftMotorSpeedCall,
									stm_ref0::enableInterruptsCall <- enableInterruptsCall,
									stm_ref0::setRightMotorSpeedCall <- setRightMotorSpeedCall,
									stm_ref0::disableInterruptsCall <- disableInterruptsCall
								]]
							)
								[|{|terminate, stm_ref1::angleOutputE, stm_ref0::anewError, stm_ref0::adiff, stm_ref2::speedOutputE, stm_ref0::snewError, stm_ref3::rotationOutputE, stm_ref0::rdiff|}|]
							(
								(
									let
										const_AnglePID_S_P = const_Segway_P2_SegwayController_stm_ref1_P
										const_AnglePID_S_D = const_Segway_P2_SegwayController_stm_ref1_D
									within 
									stm_ref1::VS_O__(id__,
											    const_AnglePID_S_P,
											    const_AnglePID_S_D)[[
										stm_ref1::terminate <- terminate,
										stm_ref1::anewError.in <- stm_ref0::anewError.out,
										stm_ref1::anewError.out <- stm_ref0::anewError.in,
										stm_ref1::adiff.in <- stm_ref0::adiff.out,
										stm_ref1::adiff.out <- stm_ref0::adiff.in
									]]
								)
									[|{|terminate|}|]
								(
									(
										let
											const_SpeedPID_S_P = const_Segway_P2_SegwayController_stm_ref2_P
											const_SpeedPID_S_I = const_Segway_P2_SegwayController_stm_ref2_I
											const_SpeedPID_S_maxIntegral = const_Segway_P2_SegwayController_stm_ref2_maxIntegral
										within 
										stm_ref2::VS_O__(id__,
												    const_SpeedPID_S_P,
												    const_SpeedPID_S_I,
												    const_SpeedPID_S_maxIntegral)[[
											stm_ref2::terminate <- terminate,
											stm_ref2::snewError.in <- stm_ref0::snewError.out,
											stm_ref2::snewError.out <- stm_ref0::snewError.in
										]]
									)
										[|{|terminate|}|]
									(
										let
											const_RotationPID_S_D = const_Segway_P2_SegwayController_stm_ref3_D
										within 
										stm_ref3::VS_O__(id__,
												    const_RotationPID_S_D)[[
											stm_ref3::terminate <- terminate,
											stm_ref3::rdiff.in <- stm_ref0::rdiff.out,
											stm_ref3::rdiff.out <- stm_ref0::rdiff.in
										]]
									)
								)
								\diff(
									{|terminate|},
									{|terminate|}
								)
							)
							\diff(
								{|terminate|},
								{|terminate|}
							)
						)
						\diff(
							{|terminate, stm_ref1::angleOutputE, stm_ref0::anewError, stm_ref0::adiff, stm_ref2::speedOutputE, stm_ref0::snewError, stm_ref3::rotationOutputE, stm_ref0::rdiff|},
							{|terminate|}
						)
							[|
								union(
									{|
									|},
									{|
									|}
								)
							|]
						dbisim(Memory(id__))
					)
					\ union(
						{|
						|},
						{|
						|}
					)
					[|{|terminate|}|>SKIP
					,<union(visibleMemoryEvents,{terminate}),{tock}>))
				
					HEXT(id__,
							    const_Segway_P2_SegwayController_stm_ref0_maxAngle,
							    const_Segway_P2_SegwayController_stm_ref0_loopTime,
							    const_Segway_P2_SegwayController_stm_ref0_startupDelay,
							    const_Segway_P2_SegwayController_stm_ref0_speedUpdate,
							    const_Segway_P2_SegwayController_stm_ref0_rotationUpdate,
							    const_Segway_P2_SegwayController_stm_ref0_motorBudget,
							    const_Segway_P2_SegwayController_stm_ref0_angleBudget,
							    const_Segway_P2_SegwayController_stm_ref0_speedBudget,
							    const_Segway_P2_SegwayController_stm_ref0_rotationBudget,
							    const_Segway_P2_SegwayController_stm_ref1_P,
							    const_Segway_P2_SegwayController_stm_ref1_D,
							    const_Segway_P2_SegwayController_stm_ref2_P,
							    const_Segway_P2_SegwayController_stm_ref2_I,
							    const_Segway_P2_SegwayController_stm_ref2_maxIntegral,
							    const_Segway_P2_SegwayController_stm_ref3_D) = O__(id__,
							    const_Segway_P2_SegwayController_stm_ref0_maxAngle,
							    const_Segway_P2_SegwayController_stm_ref0_loopTime,
							    const_Segway_P2_SegwayController_stm_ref0_startupDelay,
							    const_Segway_P2_SegwayController_stm_ref0_speedUpdate,
							    const_Segway_P2_SegwayController_stm_ref0_rotationUpdate,
							    const_Segway_P2_SegwayController_stm_ref0_motorBudget,
							    const_Segway_P2_SegwayController_stm_ref0_angleBudget,
							    const_Segway_P2_SegwayController_stm_ref0_speedBudget,
							    const_Segway_P2_SegwayController_stm_ref0_rotationBudget,
							    const_Segway_P2_SegwayController_stm_ref1_P,
							    const_Segway_P2_SegwayController_stm_ref1_D,
							    const_Segway_P2_SegwayController_stm_ref2_P,
							    const_Segway_P2_SegwayController_stm_ref2_I,
							    const_Segway_P2_SegwayController_stm_ref2_maxIntegral,
							    const_Segway_P2_SegwayController_stm_ref3_D) [|shared_variable_events|] SKIP			
			}
	
		endmodule
	
	Timed(OneStep) {
		visibleMemoryEvents = {||}
		
		-- declaring module memory
		Memory(id__) = SKIP
		
		D__(id__,
				    const_Segway_P2_SegwayController_stm_ref0_maxAngle,
				    const_Segway_P2_SegwayController_stm_ref0_loopTime,
				    const_Segway_P2_SegwayController_stm_ref0_startupDelay,
				    const_Segway_P2_SegwayController_stm_ref0_speedUpdate,
				    const_Segway_P2_SegwayController_stm_ref0_rotationUpdate,
				    const_Segway_P2_SegwayController_stm_ref0_motorBudget,
				    const_Segway_P2_SegwayController_stm_ref0_angleBudget,
				    const_Segway_P2_SegwayController_stm_ref0_speedBudget,
				    const_Segway_P2_SegwayController_stm_ref0_rotationBudget,
				    const_Segway_P2_SegwayController_stm_ref1_P,
				    const_Segway_P2_SegwayController_stm_ref1_D,
				    const_Segway_P2_SegwayController_stm_ref2_P,
				    const_Segway_P2_SegwayController_stm_ref2_I,
				    const_Segway_P2_SegwayController_stm_ref2_maxIntegral,
				    const_Segway_P2_SegwayController_stm_ref3_D) = prioritise(	(
				(
					(SKIP)
						[|{||}|]
					(
						(
							SegwayController::D__(id__,
									    const_Segway_P2_SegwayController_stm_ref0_maxAngle,
									    const_Segway_P2_SegwayController_stm_ref0_loopTime,
									    const_Segway_P2_SegwayController_stm_ref0_startupDelay,
									    const_Segway_P2_SegwayController_stm_ref0_speedUpdate,
									    const_Segway_P2_SegwayController_stm_ref0_rotationUpdate,
									    const_Segway_P2_SegwayController_stm_ref0_motorBudget,
									    const_Segway_P2_SegwayController_stm_ref0_angleBudget,
									    const_Segway_P2_SegwayController_stm_ref0_speedBudget,
									    const_Segway_P2_SegwayController_stm_ref0_rotationBudget,
									    const_Segway_P2_SegwayController_stm_ref1_P,
									    const_Segway_P2_SegwayController_stm_ref1_D,
									    const_Segway_P2_SegwayController_stm_ref2_P,
									    const_Segway_P2_SegwayController_stm_ref2_I,
									    const_Segway_P2_SegwayController_stm_ref2_maxIntegral,
									    const_Segway_P2_SegwayController_stm_ref3_D)[[
								SegwayController::terminate <- terminate,
								SegwayController::angle <- angle,
								SegwayController::gyroX <- gyroX,
								SegwayController::gyroY <- gyroY,
								SegwayController::gyroZ <- gyroZ,
								SegwayController::leftMotorVelocity <- leftMotorVelocity,
								SegwayController::rightMotorVelocity <- rightMotorVelocity,
								SegwayController::setLeftMotorSpeedCall <- setLeftMotorSpeedCall,
								SegwayController::enableInterruptsCall <- enableInterruptsCall,
								SegwayController::setRightMotorSpeedCall <- setRightMotorSpeedCall,
								SegwayController::disableInterruptsCall <- disableInterruptsCall
							]]
						)
							[|
								union(
									{|
									|},
									{|
									|}
								)
							|]
						Memory(id__)
					)
				)
				\ Union({
					{|
					|},
					{|
					|},
					{|
					|}
				})
				[|{|terminate|}|>SKIP
			)
			\{|terminate|}
		,<visibleMemoryEvents,{tock}>)
		
		-- visible state equivalent
		
		VS__(id__,
				    const_Segway_P2_SegwayController_stm_ref0_maxAngle,
				    const_Segway_P2_SegwayController_stm_ref0_loopTime,
				    const_Segway_P2_SegwayController_stm_ref0_startupDelay,
				    const_Segway_P2_SegwayController_stm_ref0_speedUpdate,
				    const_Segway_P2_SegwayController_stm_ref0_rotationUpdate,
				    const_Segway_P2_SegwayController_stm_ref0_motorBudget,
				    const_Segway_P2_SegwayController_stm_ref0_angleBudget,
				    const_Segway_P2_SegwayController_stm_ref0_speedBudget,
				    const_Segway_P2_SegwayController_stm_ref0_rotationBudget,
				    const_Segway_P2_SegwayController_stm_ref1_P,
				    const_Segway_P2_SegwayController_stm_ref1_D,
				    const_Segway_P2_SegwayController_stm_ref2_P,
				    const_Segway_P2_SegwayController_stm_ref2_I,
				    const_Segway_P2_SegwayController_stm_ref2_maxIntegral,
				    const_Segway_P2_SegwayController_stm_ref3_D) = prioritise(	(
				(
					(SKIP)
						[|{||}|]
					(
						(
							SegwayController::VS__(id__,
									    const_Segway_P2_SegwayController_stm_ref0_maxAngle,
									    const_Segway_P2_SegwayController_stm_ref0_loopTime,
									    const_Segway_P2_SegwayController_stm_ref0_startupDelay,
									    const_Segway_P2_SegwayController_stm_ref0_speedUpdate,
									    const_Segway_P2_SegwayController_stm_ref0_rotationUpdate,
									    const_Segway_P2_SegwayController_stm_ref0_motorBudget,
									    const_Segway_P2_SegwayController_stm_ref0_angleBudget,
									    const_Segway_P2_SegwayController_stm_ref0_speedBudget,
									    const_Segway_P2_SegwayController_stm_ref0_rotationBudget,
									    const_Segway_P2_SegwayController_stm_ref1_P,
									    const_Segway_P2_SegwayController_stm_ref1_D,
									    const_Segway_P2_SegwayController_stm_ref2_P,
									    const_Segway_P2_SegwayController_stm_ref2_I,
									    const_Segway_P2_SegwayController_stm_ref2_maxIntegral,
									    const_Segway_P2_SegwayController_stm_ref3_D)[[
								SegwayController::terminate <- terminate,
								SegwayController::angle <- angle,
								SegwayController::gyroX <- gyroX,
								SegwayController::gyroY <- gyroY,
								SegwayController::gyroZ <- gyroZ,
								SegwayController::leftMotorVelocity <- leftMotorVelocity,
								SegwayController::rightMotorVelocity <- rightMotorVelocity,
								SegwayController::setLeftMotorSpeedCall <- setLeftMotorSpeedCall,
								SegwayController::enableInterruptsCall <- enableInterruptsCall,
								SegwayController::setRightMotorSpeedCall <- setRightMotorSpeedCall,
								SegwayController::disableInterruptsCall <- disableInterruptsCall
							]]
						)
							[|
								union(
									{|
									|},
									{|
									|}
								)
							|]
						Memory(id__)
					)
				)
				\ Union({
					{|
					|},
					{|
					|},
					{|
					|}
				})
				[|{|terminate|}|>SKIP
			)
			\{|terminate|}
		,<visibleMemoryEvents,{tock}>)
		
		-- O version (optimised)
		
		O__(id__,
				    const_Segway_P2_SegwayController_stm_ref0_maxAngle,
				    const_Segway_P2_SegwayController_stm_ref0_loopTime,
				    const_Segway_P2_SegwayController_stm_ref0_startupDelay,
				    const_Segway_P2_SegwayController_stm_ref0_speedUpdate,
				    const_Segway_P2_SegwayController_stm_ref0_rotationUpdate,
				    const_Segway_P2_SegwayController_stm_ref0_motorBudget,
				    const_Segway_P2_SegwayController_stm_ref0_angleBudget,
				    const_Segway_P2_SegwayController_stm_ref0_speedBudget,
				    const_Segway_P2_SegwayController_stm_ref0_rotationBudget,
				    const_Segway_P2_SegwayController_stm_ref1_P,
				    const_Segway_P2_SegwayController_stm_ref1_D,
				    const_Segway_P2_SegwayController_stm_ref2_P,
				    const_Segway_P2_SegwayController_stm_ref2_I,
				    const_Segway_P2_SegwayController_stm_ref2_maxIntegral,
				    const_Segway_P2_SegwayController_stm_ref3_D) = dbisim(prioritise(	(
				(
					(SKIP)
						[|{||}|]
					(
						(
							SegwayController::O__(id__,
									    const_Segway_P2_SegwayController_stm_ref0_maxAngle,
									    const_Segway_P2_SegwayController_stm_ref0_loopTime,
									    const_Segway_P2_SegwayController_stm_ref0_startupDelay,
									    const_Segway_P2_SegwayController_stm_ref0_speedUpdate,
									    const_Segway_P2_SegwayController_stm_ref0_rotationUpdate,
									    const_Segway_P2_SegwayController_stm_ref0_motorBudget,
									    const_Segway_P2_SegwayController_stm_ref0_angleBudget,
									    const_Segway_P2_SegwayController_stm_ref0_speedBudget,
									    const_Segway_P2_SegwayController_stm_ref0_rotationBudget,
									    const_Segway_P2_SegwayController_stm_ref1_P,
									    const_Segway_P2_SegwayController_stm_ref1_D,
									    const_Segway_P2_SegwayController_stm_ref2_P,
									    const_Segway_P2_SegwayController_stm_ref2_I,
									    const_Segway_P2_SegwayController_stm_ref2_maxIntegral,
									    const_Segway_P2_SegwayController_stm_ref3_D)[[
								SegwayController::terminate <- terminate,
								SegwayController::angle <- angle,
								SegwayController::gyroX <- gyroX,
								SegwayController::gyroY <- gyroY,
								SegwayController::gyroZ <- gyroZ,
								SegwayController::leftMotorVelocity <- leftMotorVelocity,
								SegwayController::rightMotorVelocity <- rightMotorVelocity,
								SegwayController::setLeftMotorSpeedCall <- setLeftMotorSpeedCall,
								SegwayController::enableInterruptsCall <- enableInterruptsCall,
								SegwayController::setRightMotorSpeedCall <- setRightMotorSpeedCall,
								SegwayController::disableInterruptsCall <- disableInterruptsCall
							]]
						)
							[|
								union(
									{|
									|},
									{|
									|}
								)
							|]
						dbisim(Memory(id__))
					)
				)
				\ Union({
					{|
					|},
					{|
					|},
					{|
					|}
				})
				[|{|terminate|}|>SKIP
			)
			\{|terminate|}
		,<visibleMemoryEvents,{tock}>))
		
		-- visible state optimised equivalent
		
		VS_O__(id__,
				    const_Segway_P2_SegwayController_stm_ref0_maxAngle,
				    const_Segway_P2_SegwayController_stm_ref0_loopTime,
				    const_Segway_P2_SegwayController_stm_ref0_startupDelay,
				    const_Segway_P2_SegwayController_stm_ref0_speedUpdate,
				    const_Segway_P2_SegwayController_stm_ref0_rotationUpdate,
				    const_Segway_P2_SegwayController_stm_ref0_motorBudget,
				    const_Segway_P2_SegwayController_stm_ref0_angleBudget,
				    const_Segway_P2_SegwayController_stm_ref0_speedBudget,
				    const_Segway_P2_SegwayController_stm_ref0_rotationBudget,
				    const_Segway_P2_SegwayController_stm_ref1_P,
				    const_Segway_P2_SegwayController_stm_ref1_D,
				    const_Segway_P2_SegwayController_stm_ref2_P,
				    const_Segway_P2_SegwayController_stm_ref2_I,
				    const_Segway_P2_SegwayController_stm_ref2_maxIntegral,
				    const_Segway_P2_SegwayController_stm_ref3_D) = dbisim(prioritise(	(
				(
					(SKIP)
						[|{||}|]
					(
						(
							SegwayController::VS_O__(id__,
									    const_Segway_P2_SegwayController_stm_ref0_maxAngle,
									    const_Segway_P2_SegwayController_stm_ref0_loopTime,
									    const_Segway_P2_SegwayController_stm_ref0_startupDelay,
									    const_Segway_P2_SegwayController_stm_ref0_speedUpdate,
									    const_Segway_P2_SegwayController_stm_ref0_rotationUpdate,
									    const_Segway_P2_SegwayController_stm_ref0_motorBudget,
									    const_Segway_P2_SegwayController_stm_ref0_angleBudget,
									    const_Segway_P2_SegwayController_stm_ref0_speedBudget,
									    const_Segway_P2_SegwayController_stm_ref0_rotationBudget,
									    const_Segway_P2_SegwayController_stm_ref1_P,
									    const_Segway_P2_SegwayController_stm_ref1_D,
									    const_Segway_P2_SegwayController_stm_ref2_P,
									    const_Segway_P2_SegwayController_stm_ref2_I,
									    const_Segway_P2_SegwayController_stm_ref2_maxIntegral,
									    const_Segway_P2_SegwayController_stm_ref3_D)[[
								SegwayController::terminate <- terminate,
								SegwayController::angle <- angle,
								SegwayController::gyroX <- gyroX,
								SegwayController::gyroY <- gyroY,
								SegwayController::gyroZ <- gyroZ,
								SegwayController::leftMotorVelocity <- leftMotorVelocity,
								SegwayController::rightMotorVelocity <- rightMotorVelocity,
								SegwayController::setLeftMotorSpeedCall <- setLeftMotorSpeedCall,
								SegwayController::enableInterruptsCall <- enableInterruptsCall,
								SegwayController::setRightMotorSpeedCall <- setRightMotorSpeedCall,
								SegwayController::disableInterruptsCall <- disableInterruptsCall
							]]
						)
							[|
								union(
									{|
									|},
									{|
									|}
								)
							|]
						dbisim(Memory(id__))
					)
				)
				\ Union({
					{|
					|},
					{|
					|},
					{|
					|}
				})
				[|{|terminate|}|>SKIP
			)
			\{|terminate|}
		,<visibleMemoryEvents,{tock}>))
		
		-- O version (optimised) with visible assignments
		
		AS_O__(id__,
				    const_Segway_P2_SegwayController_stm_ref0_maxAngle,
				    const_Segway_P2_SegwayController_stm_ref0_loopTime,
				    const_Segway_P2_SegwayController_stm_ref0_startupDelay,
				    const_Segway_P2_SegwayController_stm_ref0_speedUpdate,
				    const_Segway_P2_SegwayController_stm_ref0_rotationUpdate,
				    const_Segway_P2_SegwayController_stm_ref0_motorBudget,
				    const_Segway_P2_SegwayController_stm_ref0_angleBudget,
				    const_Segway_P2_SegwayController_stm_ref0_speedBudget,
				    const_Segway_P2_SegwayController_stm_ref0_rotationBudget,
				    const_Segway_P2_SegwayController_stm_ref1_P,
				    const_Segway_P2_SegwayController_stm_ref1_D,
				    const_Segway_P2_SegwayController_stm_ref2_P,
				    const_Segway_P2_SegwayController_stm_ref2_I,
				    const_Segway_P2_SegwayController_stm_ref2_maxIntegral,
				    const_Segway_P2_SegwayController_stm_ref3_D) = dbisim(	(
				(
					(SKIP)
						[|{||}|]
					(
						(
							SegwayController::O__(id__,
									    const_Segway_P2_SegwayController_stm_ref0_maxAngle,
									    const_Segway_P2_SegwayController_stm_ref0_loopTime,
									    const_Segway_P2_SegwayController_stm_ref0_startupDelay,
									    const_Segway_P2_SegwayController_stm_ref0_speedUpdate,
									    const_Segway_P2_SegwayController_stm_ref0_rotationUpdate,
									    const_Segway_P2_SegwayController_stm_ref0_motorBudget,
									    const_Segway_P2_SegwayController_stm_ref0_angleBudget,
									    const_Segway_P2_SegwayController_stm_ref0_speedBudget,
									    const_Segway_P2_SegwayController_stm_ref0_rotationBudget,
									    const_Segway_P2_SegwayController_stm_ref1_P,
									    const_Segway_P2_SegwayController_stm_ref1_D,
									    const_Segway_P2_SegwayController_stm_ref2_P,
									    const_Segway_P2_SegwayController_stm_ref2_I,
									    const_Segway_P2_SegwayController_stm_ref2_maxIntegral,
									    const_Segway_P2_SegwayController_stm_ref3_D)[[
								SegwayController::terminate <- terminate,
								SegwayController::angle <- angle,
								SegwayController::gyroX <- gyroX,
								SegwayController::gyroY <- gyroY,
								SegwayController::gyroZ <- gyroZ,
								SegwayController::leftMotorVelocity <- leftMotorVelocity,
								SegwayController::rightMotorVelocity <- rightMotorVelocity,
								SegwayController::setLeftMotorSpeedCall <- setLeftMotorSpeedCall,
								SegwayController::enableInterruptsCall <- enableInterruptsCall,
								SegwayController::setRightMotorSpeedCall <- setRightMotorSpeedCall,
								SegwayController::disableInterruptsCall <- disableInterruptsCall
							]]
						)
							[|
								union(
									{|
									|},
									{|
									|}
								)
							|]
						dbisim(Memory(id__))
					)
				)
				\ Union({
					{|
					|},
					{|
					|},
					{|
					|}
				})
				[|{|terminate|}|>SKIP
			)
			\{|terminate|}
		)
	}
	
endmodule
