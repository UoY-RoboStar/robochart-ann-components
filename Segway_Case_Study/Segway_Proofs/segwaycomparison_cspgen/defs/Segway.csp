
--
-- RoboChart generator version 3.0.0.202306261132
-- Automatically generated on 22-08-2023 01:53:01
--
-- Iterated compression status: true
-- Assertions compression status: false
--

module Segway
	exports
	
	transparent diamond
	transparent sbisim
	transparent dbisim
	transparent chase
	
	-- declaring channels
	-- declaring robotic platform events
	channel leftMotorVelocity: InOut.core_real
	channel rightMotorVelocity: InOut.core_real
	channel angle: InOut.core_real
	channel gyroX: InOut.core_real
	channel gyroY: InOut.core_real
	channel gyroZ: InOut.core_real
	
	channel setLeftMotorSpeedCall: core_real
	channel setRightMotorSpeedCall: core_real
	channel enableInterruptsCall
	channel disableInterruptsCall
	
	-- declaring module termination channel
	channel terminate
	
	-- declaring robotic platform variables
	
	-- channel set with all visible events
	sem__events = {|
		leftMotorVelocity,
		rightMotorVelocity,
		angle,
		gyroX,
		gyroY,
		gyroZ
	,	setLeftMotorSpeedCall,
		setRightMotorSpeedCall,
		enableInterruptsCall,
		disableInterruptsCall
	|}
	
	-- declaring controller
		module SegwayController
			shared_variable_events = {|
			|}
			
		exports
			transparent diamond
			transparent sbisim
			transparent dbisim
			transparent chase
	
			-- declaring controller events
			channel leftMotorVelocity: InOut.core_real
			channel rightMotorVelocity: InOut.core_real
			channel angle: InOut.core_real
			channel gyroX: InOut.core_real
			channel gyroY: InOut.core_real
			channel gyroZ: InOut.core_real
			
			
			
			-- declaring call and ret events for undefined operations
			channel setLeftMotorSpeedCall: core_real
			channel enableInterruptsCall
			channel setRightMotorSpeedCall: core_real
			channel disableInterruptsCall
			
			-- declaring controller termination channel
			channel terminate
			
			-- channel set with all visible events
			sem__events = {|
				terminate
			,	leftMotorVelocity,
				rightMotorVelocity,
				angle,
				gyroX,
				gyroY,
				gyroZ
			,	setLeftMotorSpeedCall,
				enableInterruptsCall,
				setRightMotorSpeedCall,
				disableInterruptsCall
			|}
	
			-- defined operations
			-- compileOperationDef
			module OP_AnglePID
			exports
				transparent diamond
				transparent sbisim
				transparent dbisim
				transparent chase
				
				-- Transition identifiers
				-- declaring identifiers of transitions
				datatype NIDS = 
				              NID_i0|
				              NID_UpdateOutput|
				              NID_f0
				
				channel internal__ : NIDS
				
				-- Flow channels		
				channel interrupt
				channel exited
				channel exit
				channel terminate
				
				-- Variable channels
				channel get_angleOutput, set_angleOutput, setL_angleOutput, setR_angleOutput: core_real
				
				-- Shared variable channels
				channel set_EXT_angleOutput: core_real
				
				-- Local variable channels for defined operations that are required by the state machine
				
				-- Declaring state machine events
				
				-- Declaring call and ret events for undefined operations
				
				enterSS = {|
				i0::enter,
				UpdateOutput::enter,
				f0::enter
				|}
				
				enteredSS = 	{|
				UpdateOutput::entered,
				f0::entered
				|}
				
				internal_events = union(enteredSS,union(enterSS,{|interrupt,exited|}))
				
				shared_variable_events = {|
					set_EXT_angleOutput
				|}
				
				-- channel set with all visible events
				sem__events = {|
					terminate
				,	set_EXT_angleOutput, set_angleOutput
					, share__
					|}
				
				-- Nodes --
				-- declaring all nodes
				
				----------------------------------------------------------------------
				-- Initial: i0
				module i0
				exports
				
					channel enter, interrupt
					
					D__(id__,
								param_newError,
								param_diff,
							    const_AnglePID_P,
							    const_AnglePID_D) = 
						dbisim(let
							Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
							
							Termination = terminate -> SKIP
							
							Active 		= share__choice(interrupt -> SKIP) ; Inactive
						within
							Inactive [| {terminate} |> SKIP)
					
					VS_O__(id__,
								param_newError,
								param_diff,
							    const_AnglePID_P,
							    const_AnglePID_D) = D__(id__,
								param_newError,
								param_diff,
							    const_AnglePID_P,
							    const_AnglePID_D)
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: UpdateOutput
				module UpdateOutput
				
				enterSS = {}
				
				enteredSS = {}
				
				exports
				
					--  Declarations
					
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
									
					
					--	Nodes
					-- declaring all nodes
					
					
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__,
								param_newError,
								param_diff,
							    const_AnglePID_P,
							    const_AnglePID_D) = 
					dbisim(let
						-- IMPLEMENTATION NOTE: 
						-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
						-- however FDR struggles with that form in certain cases. So we use the exception operator
						-- instead to 'terminate'.
						
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= share__choice(true & (share__choice(set_angleOutput!Plus(Mult(param_newError, const_AnglePID_P, core_real), Mult(param_diff, const_AnglePID_D, core_real), core_real) -> SKIP))) ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__,
								param_newError,
								param_diff,
							    const_AnglePID_P,
							    const_AnglePID_D) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= share__choice(true & (share__choice(set_angleOutput!Plus(Mult(param_newError, const_AnglePID_P, core_real), Mult(param_diff, const_AnglePID_D, core_real), core_real) -> SKIP))) ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
					
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- Final state: f0
				module f0
				
				exports
				
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
					--	Rule: behaviours(Node)
					D__(id__,
								param_newError,
								param_diff,
							    const_AnglePID_P,
							    const_AnglePID_D) = 
						dbisim(let
							Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Entering
							
							Entering 	= entered -> SKIP ; Active
							Active		= share__choice(terminate -> SKIP [] interrupt -> SKIP) ; Interrupted
							Interrupted	= share__choice(exit -> exited -> Inactive)
						within
							Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__,
								param_newError,
								param_diff,
							    const_AnglePID_P,
							    const_AnglePID_D) = D__(id__,
								param_newError,
								param_diff,
							    const_AnglePID_P,
							    const_AnglePID_D)
				
				endmodule
				----------------------------------------------------------------------
				
				-- END of Nodes --
				
				-- Operation calls --
				-- Only the undefined operations are declared here.
				-- If the state machine is in isolation, all required operations will be undefined.
				-- If it is in the context of a controller, the required operations not provided by the
				-- controller will be declared here, and the defined operations will be defined in the
				-- context of the Controller module, and therefore within scope of the state machine module.
				
				-- END of Operation calls --
				
				-- STM processes
				STM(id__,
							param_newError,
							param_diff,
						    const_AnglePID_P,
						    const_AnglePID_D) = -- RULE: [[stm:OperationDef]]_STM^nops : CSPProcess
				Stateful(id__,
							param_newError,
							param_diff,
						    const_AnglePID_P,
						    const_AnglePID_D) \ {terminate}
				
				STM_VS_O(id__,
							param_newError,
							param_diff,
						    const_AnglePID_P,
						    const_AnglePID_D) = -- RULE: [[stm:OperationDef]]_STM^nops : CSPProcess
				Stateful(id__,
							param_newError,
							param_diff,
						    const_AnglePID_P,
						    const_AnglePID_D) \ {terminate}
				
				-- Transitions
				Transitions(id__,
							param_newError,
							param_diff,
						    const_AnglePID_P,
						    const_AnglePID_D) = ((let
					Trans = (
						((share__ -> SKIP
						 [] dbisim((true)&(internal__!NID_i0 -> SKIP ;  ((SKIP ; UpdateOutput::enter -> SKIP))))
						 	 [] dbisim((true)&(internal__!NID_UpdateOutput -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; f0::enter -> SKIP)))
						 ) ; Trans)
						 []
						 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
						 []
						 terminate -> SKIP
					)
				within
					Trans
				)
				)
				
				-- Stateful
				-- RULE: Stateful(stm:StateMachineBody) : CSPProcess
				
				-- Named process definitions
				MachineBody(id__,
							param_newError,
							param_diff,
						    const_AnglePID_P,
						    const_AnglePID_D) = 
					dbisim((
					let
						finalNodesEntered = {|f0::entered|}
					within
						((let
							-- IMPLEMENTATION NOTE:
							-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
							-- modules for defining the semantics of each node.
							enterSS = {|
							i0::enter,
							UpdateOutput::enter,
							f0::enter
							|}
							hideSet = union(enterSS,{|exit,exited,internal__|})
						within 
							((let
								-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
								-- because CSPM modules are used for the semantics of Node.
								flowevts = union(enterSS,{|exit,exited,interrupt|})
								transSync = {|internal__.NID_i0,internal__.NID_UpdateOutput|}
							within
								((
								 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
								   i0::D__(id__,
								   			param_newError,
								   			param_diff,
								   		    const_AnglePID_P,
								   		    const_AnglePID_D)
								   [| { share__, terminate } |] (
								   UpdateOutput::D__(id__,
								   			param_newError,
								   			param_diff,
								   		    const_AnglePID_P,
								   		    const_AnglePID_D)
								   [| { share__, terminate } |] (
								   f0::D__(id__,
								   			param_newError,
								   			param_diff,
								   		    const_AnglePID_P,
								   		    const_AnglePID_D)
								   )
								   )
								 )
								 [[UpdateOutput::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_UpdateOutput|}]]
								 [[f0::interrupt <- x__ | x__ <- {|interrupt|}]]
								 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
								 )
								  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
								 )
								 [| union(union(union(flowevts,transSync),{terminate}),{|share__
								|}) |]
								 ((i0::enter -> Transitions(id__,
								 			param_newError,
								 			param_diff,
								 		    const_AnglePID_P,
								 		    const_AnglePID_D))
								  [[ share__ <- x__ | x__ <- {| share__ |} ]]
								 )
								)
								)
							)
							 \ hideSet)
						)
						 [| {| interrupt |} |] SKIP)
					)
					)
				
				Behaviour(id__,
							param_newError,
							param_diff,
						    const_AnglePID_P,
						    const_AnglePID_D) = 
					dbisim((MachineBody(id__,
								param_newError,
								param_diff,
							    const_AnglePID_P,
							    const_AnglePID_D)\ enteredSS)
					)
				
				
				Stateful(id__,
							param_newError,
							param_diff,
						    const_AnglePID_P,
						    const_AnglePID_D) = 
					((
						(Behaviour(id__,
									param_newError,
									param_diff,
								    const_AnglePID_P,
								    const_AnglePID_D) [| union(getsetLocalChannels,{terminate}) |] varMemory(id__,
									param_newError,
									param_diff,
								    const_AnglePID_P,
								    const_AnglePID_D))
					 	\getsetLocalChannels
					)
					)
				
				
				-- Visible counterparts
				MachineBody_VS_O(id__,
							param_newError,
							param_diff,
						    const_AnglePID_P,
						    const_AnglePID_D) = 
					dbisim((
					let
						finalNodesEntered = {|f0::entered|}
					within
						((let
							-- IMPLEMENTATION NOTE:
							-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
							-- modules for defining the semantics of each node.
							enterSS = {|
							i0::enter,
							UpdateOutput::enter,
							f0::enter
							|}
							hideSet = union(enterSS,{|exit,exited,internal__|})
						within 
							((let
								-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
								-- because CSPM modules are used for the semantics of Node.
								flowevts = union(enterSS,{|exit,exited,interrupt|})
								transSync = {|internal__.NID_i0,internal__.NID_UpdateOutput|}
							within
								((
								 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
								   i0::VS_O__(id__,
								   			param_newError,
								   			param_diff,
								   		    const_AnglePID_P,
								   		    const_AnglePID_D)
								   [| { share__, terminate } |] (
								   UpdateOutput::VS_O__(id__,
								   			param_newError,
								   			param_diff,
								   		    const_AnglePID_P,
								   		    const_AnglePID_D)
								   [| { share__, terminate } |] (
								   f0::VS_O__(id__,
								   			param_newError,
								   			param_diff,
								   		    const_AnglePID_P,
								   		    const_AnglePID_D)
								   )
								   )
								 )
								 [[UpdateOutput::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_UpdateOutput|}]]
								 [[f0::interrupt <- x__ | x__ <- {|interrupt|}]]
								 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
								 )
								  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
								 )
								 [| union(union(union(flowevts,transSync),{terminate}),{|share__
								|}) |]
								 ((i0::enter -> Transitions(id__,
								 			param_newError,
								 			param_diff,
								 		    const_AnglePID_P,
								 		    const_AnglePID_D))
								  [[ share__ <- x__ | x__ <- {| share__ |} ]]
								 )
								)
								)
							)
							 \ hideSet)
						)
						 [| {| interrupt |} |] SKIP)
					)
					)
				
				Behaviour_VS_O(id__,
							param_newError,
							param_diff,
						    const_AnglePID_P,
						    const_AnglePID_D) = 
					dbisim((MachineBody_VS_O(id__,
								param_newError,
								param_diff,
							    const_AnglePID_P,
							    const_AnglePID_D))
					)
				
				
				Stateful_VS_O(id__,
							param_newError,
							param_diff,
						    const_AnglePID_P,
						    const_AnglePID_D) = 
					dbisim((
						(Behaviour_VS_O(id__,
									param_newError,
									param_diff,
								    const_AnglePID_P,
								    const_AnglePID_D) [| union(getsetLocalChannels,{terminate}) |] varMemory(id__,
									param_newError,
									param_diff,
								    const_AnglePID_P,
								    const_AnglePID_D))
					 	\getsetLocalChannels
					)
					)
				
				
				-- END
				
				-- Memory
				-- Memory variables
				
				-- varMemory process
				varMemory(id__,
							param_newError,
							param_diff,
						    const_AnglePID_P,
						    const_AnglePID_D) = terminate -> SKIP
				
				getsetLocalChannels = {||}
				
				-- Definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
				FVS__(id__,
							param_newError,
							param_diff,
						    const_AnglePID_P,
						    const_AnglePID_D) = STM_VS_O(id__,
							param_newError,
							param_diff,
						    const_AnglePID_P,
						    const_AnglePID_D)
				
				D__(id__,
							param_newError,
							param_diff,
						    const_AnglePID_P,
						    const_AnglePID_D) = STM(id__,
							param_newError,
							param_diff,
						    const_AnglePID_P,
						    const_AnglePID_D) \ internal_events
				O__(id__,
							param_newError,
							param_diff,
						    const_AnglePID_P,
						    const_AnglePID_D) = sbisim(diamond(D__(id__,
							param_newError,
							param_diff,
						    const_AnglePID_P,
						    const_AnglePID_D)))
				VS__(id__,
							param_newError,
							param_diff,
						    const_AnglePID_P,
						    const_AnglePID_D) = FVS__(id__,
							param_newError,
							param_diff,
						    const_AnglePID_P,
						    const_AnglePID_D)
				VS_O__(id__,
							param_newError,
							param_diff,
						    const_AnglePID_P,
						    const_AnglePID_D) = sbisim(diamond(FVS__(id__,
							param_newError,
							param_diff,
						    const_AnglePID_P,
						    const_AnglePID_D)))
				HEXT__(id__,
							param_newError,
							param_diff,
						    const_AnglePID_P,
						    const_AnglePID_D) = O__(id__,
							param_newError,
							param_diff,
						    const_AnglePID_P,
						    const_AnglePID_D) [|shared_variable_events|] SKIP
				HUP__(id__,
							param_newError,
							param_diff,
						    const_AnglePID_P,
						    const_AnglePID_D) = O__(id__,
							param_newError,
							param_diff,
						    const_AnglePID_P,
						    const_AnglePID_D) [|{share__}|] SKIP
						endmodule
			-- compileOperationDef
			module OP_SpeedPID
			exports
				transparent diamond
				transparent sbisim
				transparent dbisim
				transparent chase
				
				-- Transition identifiers
				-- declaring identifiers of transitions
				datatype NIDS = 
				              NID_i0|
				              NID_UpdateIntegral|
				              NID_UpdateOutput|
				              NID_f0
				
				channel internal__ : NIDS
				
				-- Flow channels		
				channel interrupt
				channel exited
				channel exit
				channel terminate
				
				-- Variable channels
				channel get_speedIntegral, set_speedIntegral, setL_speedIntegral, setR_speedIntegral: core_real
				channel get_speedOutput, set_speedOutput, setL_speedOutput, setR_speedOutput: core_real
				
				-- Shared variable channels
				channel set_EXT_speedIntegral: core_real
				channel set_EXT_speedOutput: core_real
				
				-- Local variable channels for defined operations that are required by the state machine
				
				-- Declaring state machine events
				
				-- Declaring call and ret events for undefined operations
				
				enterSS = {|
				i0::enter,
				UpdateIntegral::enter,
				UpdateOutput::enter,
				f0::enter
				|}
				
				enteredSS = 	{|
				UpdateIntegral::entered,
				UpdateOutput::entered,
				f0::entered
				|}
				
				internal_events = union(enteredSS,union(enterSS,{|interrupt,exited|}))
				
				shared_variable_events = {|
					set_EXT_speedIntegral,
					set_EXT_speedOutput
				|}
				
				-- channel set with all visible events
				sem__events = {|
					terminate
				,	set_EXT_speedIntegral, set_speedIntegral,
					set_EXT_speedOutput, set_speedOutput
					, share__
					|}
				
				-- Nodes --
				-- declaring all nodes
				
				----------------------------------------------------------------------
				-- Initial: i0
				module i0
				exports
				
					channel enter, interrupt
					
					D__(id__,
								param_newError,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral) = 
						dbisim(let
							Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
							
							Termination = terminate -> SKIP
							
							Active 		= share__choice(interrupt -> SKIP) ; Inactive
						within
							Inactive [| {terminate} |> SKIP)
					
					VS_O__(id__,
								param_newError,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral) = D__(id__,
								param_newError,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral)
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: UpdateIntegral
				module UpdateIntegral
				
				enterSS = {}
				
				enteredSS = {}
				
				exports
				
					--  Declarations
					
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
									
					
					--	Nodes
					-- declaring all nodes
					
					
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__,
								param_newError,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral) = 
					dbisim(let
						-- IMPLEMENTATION NOTE: 
						-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
						-- however FDR struggles with that form in certain cases. So we use the exception operator
						-- instead to 'terminate'.
						
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= share__choice(share__choice(get_speedIntegral?speedIntegral -> true & (share__choice(set_speedIntegral!Plus(speedIntegral, param_newError, core_real) -> SKIP))));share__choice(share__choice(get_speedIntegral?speedIntegral -> true & (share__choice(set_speedIntegral!(if (speedIntegral>const_SpeedPID_maxIntegral) then const_SpeedPID_maxIntegral else (if (speedIntegral<Neg(const_SpeedPID_maxIntegral, core_real)) then Neg(const_SpeedPID_maxIntegral, core_real) else speedIntegral)) -> SKIP)))) ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__,
								param_newError,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= share__choice(share__choice(get_speedIntegral?speedIntegral -> true & (share__choice(set_speedIntegral!Plus(speedIntegral, param_newError, core_real) -> SKIP))));share__choice(share__choice(get_speedIntegral?speedIntegral -> true & (share__choice(set_speedIntegral!(if (speedIntegral>const_SpeedPID_maxIntegral) then const_SpeedPID_maxIntegral else (if (speedIntegral<Neg(const_SpeedPID_maxIntegral, core_real)) then Neg(const_SpeedPID_maxIntegral, core_real) else speedIntegral)) -> SKIP)))) ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
					
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: UpdateOutput
				module UpdateOutput
				
				enterSS = {}
				
				enteredSS = {}
				
				exports
				
					--  Declarations
					
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
									
					
					--	Nodes
					-- declaring all nodes
					
					
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__,
								param_newError,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral) = 
					dbisim(let
						-- IMPLEMENTATION NOTE: 
						-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
						-- however FDR struggles with that form in certain cases. So we use the exception operator
						-- instead to 'terminate'.
						
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= share__choice(share__choice(get_speedIntegral?speedIntegral -> true & (share__choice(set_speedOutput!Plus(Mult(param_newError, const_SpeedPID_P, core_real), Mult(speedIntegral, const_SpeedPID_I, core_real), core_real) -> SKIP)))) ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__,
								param_newError,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= share__choice(share__choice(get_speedIntegral?speedIntegral -> true & (share__choice(set_speedOutput!Plus(Mult(param_newError, const_SpeedPID_P, core_real), Mult(speedIntegral, const_SpeedPID_I, core_real), core_real) -> SKIP)))) ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
					
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- Final state: f0
				module f0
				
				exports
				
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
					--	Rule: behaviours(Node)
					D__(id__,
								param_newError,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral) = 
						dbisim(let
							Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Entering
							
							Entering 	= entered -> SKIP ; Active
							Active		= share__choice(terminate -> SKIP [] interrupt -> SKIP) ; Interrupted
							Interrupted	= share__choice(exit -> exited -> Inactive)
						within
							Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__,
								param_newError,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral) = D__(id__,
								param_newError,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral)
				
				endmodule
				----------------------------------------------------------------------
				
				-- END of Nodes --
				
				-- Operation calls --
				-- Only the undefined operations are declared here.
				-- If the state machine is in isolation, all required operations will be undefined.
				-- If it is in the context of a controller, the required operations not provided by the
				-- controller will be declared here, and the defined operations will be defined in the
				-- context of the Controller module, and therefore within scope of the state machine module.
				
				-- END of Operation calls --
				
				-- STM processes
				STM(id__,
							param_newError,
						    const_SpeedPID_P,
						    const_SpeedPID_I,
						    const_SpeedPID_maxIntegral) = -- RULE: [[stm:OperationDef]]_STM^nops : CSPProcess
				Stateful(id__,
							param_newError,
						    const_SpeedPID_P,
						    const_SpeedPID_I,
						    const_SpeedPID_maxIntegral) \ {terminate}
				
				STM_VS_O(id__,
							param_newError,
						    const_SpeedPID_P,
						    const_SpeedPID_I,
						    const_SpeedPID_maxIntegral) = -- RULE: [[stm:OperationDef]]_STM^nops : CSPProcess
				Stateful(id__,
							param_newError,
						    const_SpeedPID_P,
						    const_SpeedPID_I,
						    const_SpeedPID_maxIntegral) \ {terminate}
				
				-- Transitions
				Transitions(id__,
							param_newError,
						    const_SpeedPID_P,
						    const_SpeedPID_I,
						    const_SpeedPID_maxIntegral) = ((let
					Trans = (
						((share__ -> SKIP
						 [] dbisim((true)&(internal__!NID_i0 -> SKIP ;  ((SKIP ; UpdateIntegral::enter -> SKIP))))
						 	 [] dbisim((true)&(internal__!NID_UpdateIntegral -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; UpdateOutput::enter -> SKIP)))
						 	 [] dbisim((true)&(internal__!NID_UpdateOutput -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; f0::enter -> SKIP)))
						 ) ; Trans)
						 []
						 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
						 []
						 terminate -> SKIP
					)
				within
					Trans
				)
				)
				
				-- Stateful
				-- RULE: Stateful(stm:StateMachineBody) : CSPProcess
				
				-- Named process definitions
				MachineBody(id__,
							param_newError,
						    const_SpeedPID_P,
						    const_SpeedPID_I,
						    const_SpeedPID_maxIntegral) = 
					dbisim((
					let
						finalNodesEntered = {|f0::entered|}
					within
						((let
							-- IMPLEMENTATION NOTE:
							-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
							-- modules for defining the semantics of each node.
							enterSS = {|
							i0::enter,
							UpdateIntegral::enter,
							UpdateOutput::enter,
							f0::enter
							|}
							hideSet = union(enterSS,{|exit,exited,internal__|})
						within 
							((let
								-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
								-- because CSPM modules are used for the semantics of Node.
								flowevts = union(enterSS,{|exit,exited,interrupt|})
								transSync = {|internal__.NID_i0,internal__.NID_UpdateIntegral,internal__.NID_UpdateOutput|}
							within
								((
								 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
								   i0::D__(id__,
								   			param_newError,
								   		    const_SpeedPID_P,
								   		    const_SpeedPID_I,
								   		    const_SpeedPID_maxIntegral)
								   [| { share__, terminate } |] (
								   UpdateIntegral::D__(id__,
								   			param_newError,
								   		    const_SpeedPID_P,
								   		    const_SpeedPID_I,
								   		    const_SpeedPID_maxIntegral)
								   [| { share__, terminate } |] (
								   UpdateOutput::D__(id__,
								   			param_newError,
								   		    const_SpeedPID_P,
								   		    const_SpeedPID_I,
								   		    const_SpeedPID_maxIntegral)
								   [| { share__, terminate } |] (
								   f0::D__(id__,
								   			param_newError,
								   		    const_SpeedPID_P,
								   		    const_SpeedPID_I,
								   		    const_SpeedPID_maxIntegral)
								   )
								   )
								   )
								 )
								 [[UpdateIntegral::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_UpdateIntegral|}]]
								 [[UpdateOutput::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_UpdateOutput|}]]
								 [[f0::interrupt <- x__ | x__ <- {|interrupt|}]]
								 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
								 )
								  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
								 )
								 [| union(union(union(flowevts,transSync),{terminate}),{|share__
								|}) |]
								 ((i0::enter -> Transitions(id__,
								 			param_newError,
								 		    const_SpeedPID_P,
								 		    const_SpeedPID_I,
								 		    const_SpeedPID_maxIntegral))
								  [[ share__ <- x__ | x__ <- {| share__ |} ]]
								 )
								)
								)
							)
							 \ hideSet)
						)
						 [| {| interrupt |} |] SKIP)
					)
					)
				
				Behaviour(id__,
							param_newError,
						    const_SpeedPID_P,
						    const_SpeedPID_I,
						    const_SpeedPID_maxIntegral) = 
					dbisim((MachineBody(id__,
								param_newError,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral)\ enteredSS)
					)
				
				
				Stateful(id__,
							param_newError,
						    const_SpeedPID_P,
						    const_SpeedPID_I,
						    const_SpeedPID_maxIntegral) = 
					((
						(Behaviour(id__,
									param_newError,
								    const_SpeedPID_P,
								    const_SpeedPID_I,
								    const_SpeedPID_maxIntegral) [| union(getsetLocalChannels,{terminate}) |] varMemory(id__,
									param_newError,
								    const_SpeedPID_P,
								    const_SpeedPID_I,
								    const_SpeedPID_maxIntegral))
					 	\getsetLocalChannels
					)
					)
				
				
				-- Visible counterparts
				MachineBody_VS_O(id__,
							param_newError,
						    const_SpeedPID_P,
						    const_SpeedPID_I,
						    const_SpeedPID_maxIntegral) = 
					dbisim((
					let
						finalNodesEntered = {|f0::entered|}
					within
						((let
							-- IMPLEMENTATION NOTE:
							-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
							-- modules for defining the semantics of each node.
							enterSS = {|
							i0::enter,
							UpdateIntegral::enter,
							UpdateOutput::enter,
							f0::enter
							|}
							hideSet = union(enterSS,{|exit,exited,internal__|})
						within 
							((let
								-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
								-- because CSPM modules are used for the semantics of Node.
								flowevts = union(enterSS,{|exit,exited,interrupt|})
								transSync = {|internal__.NID_i0,internal__.NID_UpdateIntegral,internal__.NID_UpdateOutput|}
							within
								((
								 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
								   i0::VS_O__(id__,
								   			param_newError,
								   		    const_SpeedPID_P,
								   		    const_SpeedPID_I,
								   		    const_SpeedPID_maxIntegral)
								   [| { share__, terminate } |] (
								   UpdateIntegral::VS_O__(id__,
								   			param_newError,
								   		    const_SpeedPID_P,
								   		    const_SpeedPID_I,
								   		    const_SpeedPID_maxIntegral)
								   [| { share__, terminate } |] (
								   UpdateOutput::VS_O__(id__,
								   			param_newError,
								   		    const_SpeedPID_P,
								   		    const_SpeedPID_I,
								   		    const_SpeedPID_maxIntegral)
								   [| { share__, terminate } |] (
								   f0::VS_O__(id__,
								   			param_newError,
								   		    const_SpeedPID_P,
								   		    const_SpeedPID_I,
								   		    const_SpeedPID_maxIntegral)
								   )
								   )
								   )
								 )
								 [[UpdateIntegral::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_UpdateIntegral|}]]
								 [[UpdateOutput::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_UpdateOutput|}]]
								 [[f0::interrupt <- x__ | x__ <- {|interrupt|}]]
								 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
								 )
								  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
								 )
								 [| union(union(union(flowevts,transSync),{terminate}),{|share__
								|}) |]
								 ((i0::enter -> Transitions(id__,
								 			param_newError,
								 		    const_SpeedPID_P,
								 		    const_SpeedPID_I,
								 		    const_SpeedPID_maxIntegral))
								  [[ share__ <- x__ | x__ <- {| share__ |} ]]
								 )
								)
								)
							)
							 \ hideSet)
						)
						 [| {| interrupt |} |] SKIP)
					)
					)
				
				Behaviour_VS_O(id__,
							param_newError,
						    const_SpeedPID_P,
						    const_SpeedPID_I,
						    const_SpeedPID_maxIntegral) = 
					dbisim((MachineBody_VS_O(id__,
								param_newError,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral))
					)
				
				
				Stateful_VS_O(id__,
							param_newError,
						    const_SpeedPID_P,
						    const_SpeedPID_I,
						    const_SpeedPID_maxIntegral) = 
					dbisim((
						(Behaviour_VS_O(id__,
									param_newError,
								    const_SpeedPID_P,
								    const_SpeedPID_I,
								    const_SpeedPID_maxIntegral) [| union(getsetLocalChannels,{terminate}) |] varMemory(id__,
									param_newError,
								    const_SpeedPID_P,
								    const_SpeedPID_I,
								    const_SpeedPID_maxIntegral))
					 	\getsetLocalChannels
					)
					)
				
				
				-- END
				
				-- Memory
				-- Memory variables
				
				-- varMemory process
				varMemory(id__,
							param_newError,
						    const_SpeedPID_P,
						    const_SpeedPID_I,
						    const_SpeedPID_maxIntegral) = terminate -> SKIP
				
				getsetLocalChannels = {||}
				
				-- Definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
				FVS__(id__,
							param_newError,
						    const_SpeedPID_P,
						    const_SpeedPID_I,
						    const_SpeedPID_maxIntegral) = STM_VS_O(id__,
							param_newError,
						    const_SpeedPID_P,
						    const_SpeedPID_I,
						    const_SpeedPID_maxIntegral)
				
				D__(id__,
							param_newError,
						    const_SpeedPID_P,
						    const_SpeedPID_I,
						    const_SpeedPID_maxIntegral) = STM(id__,
							param_newError,
						    const_SpeedPID_P,
						    const_SpeedPID_I,
						    const_SpeedPID_maxIntegral) \ internal_events
				O__(id__,
							param_newError,
						    const_SpeedPID_P,
						    const_SpeedPID_I,
						    const_SpeedPID_maxIntegral) = sbisim(diamond(D__(id__,
							param_newError,
						    const_SpeedPID_P,
						    const_SpeedPID_I,
						    const_SpeedPID_maxIntegral)))
				VS__(id__,
							param_newError,
						    const_SpeedPID_P,
						    const_SpeedPID_I,
						    const_SpeedPID_maxIntegral) = FVS__(id__,
							param_newError,
						    const_SpeedPID_P,
						    const_SpeedPID_I,
						    const_SpeedPID_maxIntegral)
				VS_O__(id__,
							param_newError,
						    const_SpeedPID_P,
						    const_SpeedPID_I,
						    const_SpeedPID_maxIntegral) = sbisim(diamond(FVS__(id__,
							param_newError,
						    const_SpeedPID_P,
						    const_SpeedPID_I,
						    const_SpeedPID_maxIntegral)))
				HEXT__(id__,
							param_newError,
						    const_SpeedPID_P,
						    const_SpeedPID_I,
						    const_SpeedPID_maxIntegral) = O__(id__,
							param_newError,
						    const_SpeedPID_P,
						    const_SpeedPID_I,
						    const_SpeedPID_maxIntegral) [|shared_variable_events|] SKIP
				HUP__(id__,
							param_newError,
						    const_SpeedPID_P,
						    const_SpeedPID_I,
						    const_SpeedPID_maxIntegral) = O__(id__,
							param_newError,
						    const_SpeedPID_P,
						    const_SpeedPID_I,
						    const_SpeedPID_maxIntegral) [|{share__}|] SKIP
						endmodule
			-- compileOperationDef
			module OP_RotationPID
			exports
				transparent diamond
				transparent sbisim
				transparent dbisim
				transparent chase
				
				-- Transition identifiers
				-- declaring identifiers of transitions
				datatype NIDS = 
				              NID_i0|
				              NID_f0
				
				channel internal__ : NIDS
				
				-- Flow channels		
				channel interrupt
				channel exited
				channel exit
				channel terminate
				
				-- Variable channels
				channel get_rotationOutput, set_rotationOutput, setL_rotationOutput, setR_rotationOutput: core_real
				
				-- Shared variable channels
				channel set_EXT_rotationOutput: core_real
				
				-- Local variable channels for defined operations that are required by the state machine
				
				-- Declaring state machine events
				
				-- Declaring call and ret events for undefined operations
				
				enterSS = {|
				i0::enter,
				f0::enter
				|}
				
				enteredSS = 	{|
				f0::entered
				|}
				
				internal_events = union(enteredSS,union(enterSS,{|interrupt,exited|}))
				
				shared_variable_events = {|
					set_EXT_rotationOutput
				|}
				
				-- channel set with all visible events
				sem__events = {|
					terminate
				,	set_EXT_rotationOutput, set_rotationOutput
					, share__
					|}
				
				-- Nodes --
				-- declaring all nodes
				
				----------------------------------------------------------------------
				-- Initial: i0
				module i0
				exports
				
					channel enter, interrupt
					
					D__(id__,
								param_diff,
							    const_RotationPID_D) = 
						dbisim(let
							Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
							
							Termination = terminate -> SKIP
							
							Active 		= share__choice(interrupt -> SKIP) ; Inactive
						within
							Inactive [| {terminate} |> SKIP)
					
					VS_O__(id__,
								param_diff,
							    const_RotationPID_D) = D__(id__,
								param_diff,
							    const_RotationPID_D)
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- Final state: f0
				module f0
				
				exports
				
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
					--	Rule: behaviours(Node)
					D__(id__,
								param_diff,
							    const_RotationPID_D) = 
						dbisim(let
							Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Entering
							
							Entering 	= entered -> SKIP ; Active
							Active		= share__choice(terminate -> SKIP [] interrupt -> SKIP) ; Interrupted
							Interrupted	= share__choice(exit -> exited -> Inactive)
						within
							Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__,
								param_diff,
							    const_RotationPID_D) = D__(id__,
								param_diff,
							    const_RotationPID_D)
				
				endmodule
				----------------------------------------------------------------------
				
				-- END of Nodes --
				
				-- Operation calls --
				-- Only the undefined operations are declared here.
				-- If the state machine is in isolation, all required operations will be undefined.
				-- If it is in the context of a controller, the required operations not provided by the
				-- controller will be declared here, and the defined operations will be defined in the
				-- context of the Controller module, and therefore within scope of the state machine module.
				
				-- END of Operation calls --
				
				-- STM processes
				STM(id__,
							param_diff,
						    const_RotationPID_D) = -- RULE: [[stm:OperationDef]]_STM^nops : CSPProcess
				Stateful(id__,
							param_diff,
						    const_RotationPID_D) \ {terminate}
				
				STM_VS_O(id__,
							param_diff,
						    const_RotationPID_D) = -- RULE: [[stm:OperationDef]]_STM^nops : CSPProcess
				Stateful(id__,
							param_diff,
						    const_RotationPID_D) \ {terminate}
				
				-- Transitions
				Transitions(id__,
							param_diff,
						    const_RotationPID_D) = ((let
					Trans = (
						((share__ -> SKIP
						 [] dbisim((true)&(internal__!NID_i0 -> SKIP ;  ((share__choice(true & (share__choice(set_rotationOutput!Mult(const_RotationPID_D, param_diff, core_real) -> SKIP))) ; f0::enter -> SKIP))))
						 ) ; Trans)
						 []
						 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
						 []
						 terminate -> SKIP
					)
				within
					Trans
				)
				)
				
				-- Stateful
				-- RULE: Stateful(stm:StateMachineBody) : CSPProcess
				
				-- Named process definitions
				MachineBody(id__,
							param_diff,
						    const_RotationPID_D) = 
					dbisim((
					let
						finalNodesEntered = {|f0::entered|}
					within
						((let
							-- IMPLEMENTATION NOTE:
							-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
							-- modules for defining the semantics of each node.
							enterSS = {|
							i0::enter,
							f0::enter
							|}
							hideSet = union(enterSS,{|exit,exited,internal__|})
						within 
							((let
								-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
								-- because CSPM modules are used for the semantics of Node.
								flowevts = union(enterSS,{|exit,exited,interrupt|})
								transSync = {|internal__.NID_i0|}
							within
								((
								 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
								   i0::D__(id__,
								   			param_diff,
								   		    const_RotationPID_D)
								   [| { share__, terminate } |] (
								   f0::D__(id__,
								   			param_diff,
								   		    const_RotationPID_D)
								   )
								 )
								 [[f0::interrupt <- x__ | x__ <- {|interrupt|}]]
								 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
								 )
								  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
								 )
								 [| union(union(union(flowevts,transSync),{terminate}),{|share__
								|}) |]
								 ((i0::enter -> Transitions(id__,
								 			param_diff,
								 		    const_RotationPID_D))
								  [[ share__ <- x__ | x__ <- {| share__ |} ]]
								 )
								)
								)
							)
							 \ hideSet)
						)
						 [| {| interrupt |} |] SKIP)
					)
					)
				
				Behaviour(id__,
							param_diff,
						    const_RotationPID_D) = 
					dbisim((MachineBody(id__,
								param_diff,
							    const_RotationPID_D)\ enteredSS)
					)
				
				
				Stateful(id__,
							param_diff,
						    const_RotationPID_D) = 
					((
						(Behaviour(id__,
									param_diff,
								    const_RotationPID_D) [| union(getsetLocalChannels,{terminate}) |] varMemory(id__,
									param_diff,
								    const_RotationPID_D))
					 	\getsetLocalChannels
					)
					)
				
				
				-- Visible counterparts
				MachineBody_VS_O(id__,
							param_diff,
						    const_RotationPID_D) = 
					dbisim((
					let
						finalNodesEntered = {|f0::entered|}
					within
						((let
							-- IMPLEMENTATION NOTE:
							-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
							-- modules for defining the semantics of each node.
							enterSS = {|
							i0::enter,
							f0::enter
							|}
							hideSet = union(enterSS,{|exit,exited,internal__|})
						within 
							((let
								-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
								-- because CSPM modules are used for the semantics of Node.
								flowevts = union(enterSS,{|exit,exited,interrupt|})
								transSync = {|internal__.NID_i0|}
							within
								((
								 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
								   i0::VS_O__(id__,
								   			param_diff,
								   		    const_RotationPID_D)
								   [| { share__, terminate } |] (
								   f0::VS_O__(id__,
								   			param_diff,
								   		    const_RotationPID_D)
								   )
								 )
								 [[f0::interrupt <- x__ | x__ <- {|interrupt|}]]
								 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
								 )
								  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
								 )
								 [| union(union(union(flowevts,transSync),{terminate}),{|share__
								|}) |]
								 ((i0::enter -> Transitions(id__,
								 			param_diff,
								 		    const_RotationPID_D))
								  [[ share__ <- x__ | x__ <- {| share__ |} ]]
								 )
								)
								)
							)
							 \ hideSet)
						)
						 [| {| interrupt |} |] SKIP)
					)
					)
				
				Behaviour_VS_O(id__,
							param_diff,
						    const_RotationPID_D) = 
					dbisim((MachineBody_VS_O(id__,
								param_diff,
							    const_RotationPID_D))
					)
				
				
				Stateful_VS_O(id__,
							param_diff,
						    const_RotationPID_D) = 
					dbisim((
						(Behaviour_VS_O(id__,
									param_diff,
								    const_RotationPID_D) [| union(getsetLocalChannels,{terminate}) |] varMemory(id__,
									param_diff,
								    const_RotationPID_D))
					 	\getsetLocalChannels
					)
					)
				
				
				-- END
				
				-- Memory
				-- Memory variables
				
				-- varMemory process
				varMemory(id__,
							param_diff,
						    const_RotationPID_D) = terminate -> SKIP
				
				getsetLocalChannels = {||}
				
				-- Definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
				FVS__(id__,
							param_diff,
						    const_RotationPID_D) = STM_VS_O(id__,
							param_diff,
						    const_RotationPID_D)
				
				D__(id__,
							param_diff,
						    const_RotationPID_D) = STM(id__,
							param_diff,
						    const_RotationPID_D) \ internal_events
				O__(id__,
							param_diff,
						    const_RotationPID_D) = sbisim(diamond(D__(id__,
							param_diff,
						    const_RotationPID_D)))
				VS__(id__,
							param_diff,
						    const_RotationPID_D) = FVS__(id__,
							param_diff,
						    const_RotationPID_D)
				VS_O__(id__,
							param_diff,
						    const_RotationPID_D) = sbisim(diamond(FVS__(id__,
							param_diff,
						    const_RotationPID_D)))
				HEXT__(id__,
							param_diff,
						    const_RotationPID_D) = O__(id__,
							param_diff,
						    const_RotationPID_D) [|shared_variable_events|] SKIP
				HUP__(id__,
							param_diff,
						    const_RotationPID_D) = O__(id__,
							param_diff,
						    const_RotationPID_D) [|{share__}|] SKIP
						endmodule
		
			-- declaring machines
			module stm_ref0
			exports
				transparent diamond
				transparent sbisim
				transparent dbisim
				transparent chase
			
				-- Transition identifiers
				-- declaring identifiers of transitions
				datatype NIDS = 
				              NID_i0|
				              NID_CalculateAngle|
				              NID_CalculateSpeed|
				              NID_CalculateRotation|
				              NID_SetMotors|
				              NID_j0|
				              NID_j1|
				              NID_j2|
				              NID_StopMotors|
				              NID_WaitForNextIteration|
				              NID_Initialisation|
				              NID_j3
				
				channel internal__ : NIDS
				
				-- Flow channels		
				channel interrupt
				channel exited
				channel exit
				channel terminate
				
				-- Variable channels
				channel get_currAngle, set_currAngle, setL_currAngle, setR_currAngle: core_real
				channel get_currGyroX, set_currGyroX, setL_currGyroX, setR_currGyroX: core_real
				channel get_currGyroY, set_currGyroY, setL_currGyroY, setR_currGyroY: core_real
				channel get_currGyroZ, set_currGyroZ, setL_currGyroZ, setR_currGyroZ: core_real
				channel get_currLeftVel, set_currLeftVel, setL_currLeftVel, setR_currLeftVel: core_real
				channel get_currRightVel, set_currRightVel, setL_currRightVel, setR_currRightVel: core_real
				channel get_speedCount, set_speedCount, setL_speedCount, setR_speedCount: core_nat
				channel get_rotationCount, set_rotationCount, setL_rotationCount, setR_rotationCount: core_nat
				channel get_angleOutput, set_angleOutput, setL_angleOutput, setR_angleOutput: core_real
				channel get_speedIntegral, set_speedIntegral, setL_speedIntegral, setR_speedIntegral: core_real
				channel get_speedOutput, set_speedOutput, setL_speedOutput, setR_speedOutput: core_real
				channel get_rotationOutput, set_rotationOutput, setL_rotationOutput, setR_rotationOutput: core_real
				
				-- Shared variable channels
				
				-- Local variable channels for defined operations that are required by the state machine
				
				-- Declaring state machine events
				channel leftMotorVelocity__: NIDS.InOut.core_real
				channel leftMotorVelocity: InOut.core_real
				channel rightMotorVelocity__: NIDS.InOut.core_real
				channel rightMotorVelocity: InOut.core_real
				channel angle__: NIDS.InOut.core_real
				channel angle: InOut.core_real
				channel gyroX__: NIDS.InOut.core_real
				channel gyroX: InOut.core_real
				channel gyroY__: NIDS.InOut.core_real
				channel gyroY: InOut.core_real
				channel gyroZ__: NIDS.InOut.core_real
				channel gyroZ: InOut.core_real
				
				-- Declaring call and ret events for undefined operations
				channel setLeftMotorSpeedCall: core_real
				channel enableInterruptsCall
				channel setRightMotorSpeedCall: core_real
				channel disableInterruptsCall
				
				enterSS = {|
				i0::enter,
				CalculateAngle::enter,
				CalculateSpeed::enter,
				CalculateRotation::enter,
				SetMotors::enter,
				j0::enter,
				j1::enter,
				j2::enter,
				StopMotors::enter,
				WaitForNextIteration::enter,
				Initialisation::enter,
				j3::enter
				|}
				
				enteredSS = 	{|
				CalculateAngle::entered,
				CalculateSpeed::entered,
				CalculateRotation::entered,
				SetMotors::entered,
				StopMotors::entered,
				WaitForNextIteration::entered,
				Initialisation::entered
				|}
				
				internal_events = union(enteredSS,union(enterSS,{|interrupt,exited|}))
				
				shared_variable_events = {|
				|}
				
				-- channel set with all visible events
				sem__events = {|
					terminate
				,	leftMotorVelocity,
					rightMotorVelocity,
					angle,
					gyroX,
					gyroY,
					gyroZ
				,	setLeftMotorSpeedCall,
					enableInterruptsCall,
					setRightMotorSpeedCall,
					disableInterruptsCall
					|}
			
				-- Nodes --
				-- declaring all nodes
				
				----------------------------------------------------------------------
				-- Initial: i0
				module i0
				exports
				
					channel enter, interrupt
					
					D__(id__,
							    const_BalanceSTM_maxAngle,
							    const_BalanceSTM_loopTime,
							    const_BalanceSTM_startupDelay,
							    const_BalanceSTM_speedUpdate,
							    const_BalanceSTM_rotationUpdate,
							    const_BalanceSTM_angleBudget,
							    const_BalanceSTM_speedBudget,
							    const_BalanceSTM_rotationBudget,
							    const_BalanceSTM_motorBudget,
							    const_AnglePID_P,
							    const_AnglePID_D,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral,
							    const_RotationPID_D) = 
						dbisim(let
							Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
							
							Termination = terminate -> SKIP
							
							Active 		= share__choice(interrupt -> SKIP) ; Inactive
						within
							Inactive [| {terminate} |> SKIP)
					
					VS_O__(id__,
							    const_BalanceSTM_maxAngle,
							    const_BalanceSTM_loopTime,
							    const_BalanceSTM_startupDelay,
							    const_BalanceSTM_speedUpdate,
							    const_BalanceSTM_rotationUpdate,
							    const_BalanceSTM_angleBudget,
							    const_BalanceSTM_speedBudget,
							    const_BalanceSTM_rotationBudget,
							    const_BalanceSTM_motorBudget,
							    const_AnglePID_P,
							    const_AnglePID_D,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral,
							    const_RotationPID_D) = D__(id__,
							    const_BalanceSTM_maxAngle,
							    const_BalanceSTM_loopTime,
							    const_BalanceSTM_startupDelay,
							    const_BalanceSTM_speedUpdate,
							    const_BalanceSTM_rotationUpdate,
							    const_BalanceSTM_angleBudget,
							    const_BalanceSTM_speedBudget,
							    const_BalanceSTM_rotationBudget,
							    const_BalanceSTM_motorBudget,
							    const_AnglePID_P,
							    const_AnglePID_D,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral,
							    const_RotationPID_D)
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: CalculateAngle
				module CalculateAngle
				
				enterSS = {}
				
				enteredSS = {}
				
				exports
				
					--  Declarations
					
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
									
					
					--	Nodes
					-- declaring all nodes
					
					
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__,
							    const_BalanceSTM_maxAngle,
							    const_BalanceSTM_loopTime,
							    const_BalanceSTM_startupDelay,
							    const_BalanceSTM_speedUpdate,
							    const_BalanceSTM_rotationUpdate,
							    const_BalanceSTM_angleBudget,
							    const_BalanceSTM_speedBudget,
							    const_BalanceSTM_rotationBudget,
							    const_BalanceSTM_motorBudget,
							    const_AnglePID_P,
							    const_AnglePID_D,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral,
							    const_RotationPID_D) = 
					dbisim(let
						-- IMPLEMENTATION NOTE: 
						-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
						-- however FDR struggles with that form in certain cases. So we use the exception operator
						-- instead to 'terminate'.
						
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= true&CALL__enableInterrupts(
									id__,
								    const_BalanceSTM_maxAngle,
								    const_BalanceSTM_loopTime,
								    const_BalanceSTM_startupDelay,
								    const_BalanceSTM_speedUpdate,
								    const_BalanceSTM_rotationUpdate,
								    const_BalanceSTM_angleBudget,
								    const_BalanceSTM_speedBudget,
								    const_BalanceSTM_rotationBudget,
								    const_BalanceSTM_motorBudget,
									const_AnglePID_P,
									const_AnglePID_D,
									const_SpeedPID_P,
									const_SpeedPID_I,
									const_SpeedPID_maxIntegral,
									const_RotationPID_D
								);true&(share__choice(angle.in?currAngle -> (SStop /\ set_currAngle!currAngle -> SKIP)));true&(share__choice(gyroX.in?currGyroX -> (SStop /\ set_currGyroX!currGyroX -> SKIP)));share__choice(get_currGyroX?currGyroX -> share__choice(get_currAngle?currAngle -> true&CALL__AnglePID(
									id__,
								    const_BalanceSTM_maxAngle,
								    const_BalanceSTM_loopTime,
								    const_BalanceSTM_startupDelay,
								    const_BalanceSTM_speedUpdate,
								    const_BalanceSTM_rotationUpdate,
								    const_BalanceSTM_angleBudget,
								    const_BalanceSTM_speedBudget,
								    const_BalanceSTM_rotationBudget,
								    const_BalanceSTM_motorBudget,
									currAngle,
									currGyroX, 
									const_AnglePID_P, 
									const_AnglePID_D,
									const_SpeedPID_P,
									const_SpeedPID_I,
									const_SpeedPID_maxIntegral,
									const_RotationPID_D
								)));SKIP ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__,
							    const_BalanceSTM_maxAngle,
							    const_BalanceSTM_loopTime,
							    const_BalanceSTM_startupDelay,
							    const_BalanceSTM_speedUpdate,
							    const_BalanceSTM_rotationUpdate,
							    const_BalanceSTM_angleBudget,
							    const_BalanceSTM_speedBudget,
							    const_BalanceSTM_rotationBudget,
							    const_BalanceSTM_motorBudget,
							    const_AnglePID_P,
							    const_AnglePID_D,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral,
							    const_RotationPID_D) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= true&CALL__enableInterrupts(
									id__,
								    const_BalanceSTM_maxAngle,
								    const_BalanceSTM_loopTime,
								    const_BalanceSTM_startupDelay,
								    const_BalanceSTM_speedUpdate,
								    const_BalanceSTM_rotationUpdate,
								    const_BalanceSTM_angleBudget,
								    const_BalanceSTM_speedBudget,
								    const_BalanceSTM_rotationBudget,
								    const_BalanceSTM_motorBudget,
									const_AnglePID_P,
									const_AnglePID_D,
									const_SpeedPID_P,
									const_SpeedPID_I,
									const_SpeedPID_maxIntegral,
									const_RotationPID_D
								);true&(share__choice(angle.in?currAngle -> (SStop /\ set_currAngle!currAngle -> SKIP)));true&(share__choice(gyroX.in?currGyroX -> (SStop /\ set_currGyroX!currGyroX -> SKIP)));share__choice(get_currGyroX?currGyroX -> share__choice(get_currAngle?currAngle -> true&CALL__AnglePID(
									id__,
								    const_BalanceSTM_maxAngle,
								    const_BalanceSTM_loopTime,
								    const_BalanceSTM_startupDelay,
								    const_BalanceSTM_speedUpdate,
								    const_BalanceSTM_rotationUpdate,
								    const_BalanceSTM_angleBudget,
								    const_BalanceSTM_speedBudget,
								    const_BalanceSTM_rotationBudget,
								    const_BalanceSTM_motorBudget,
									currAngle,
									currGyroX, 
									const_AnglePID_P, 
									const_AnglePID_D,
									const_SpeedPID_P,
									const_SpeedPID_I,
									const_SpeedPID_maxIntegral,
									const_RotationPID_D
								)));SKIP ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
					
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: CalculateSpeed
				module CalculateSpeed
				
				enterSS = {}
				
				enteredSS = {}
				
				exports
				
					--  Declarations
					
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
									
					
					--	Nodes
					-- declaring all nodes
					
					
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__,
							    const_BalanceSTM_maxAngle,
							    const_BalanceSTM_loopTime,
							    const_BalanceSTM_startupDelay,
							    const_BalanceSTM_speedUpdate,
							    const_BalanceSTM_rotationUpdate,
							    const_BalanceSTM_angleBudget,
							    const_BalanceSTM_speedBudget,
							    const_BalanceSTM_rotationBudget,
							    const_BalanceSTM_motorBudget,
							    const_AnglePID_P,
							    const_AnglePID_D,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral,
							    const_RotationPID_D) = 
					dbisim(let
						-- IMPLEMENTATION NOTE: 
						-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
						-- however FDR struggles with that form in certain cases. So we use the exception operator
						-- instead to 'terminate'.
						
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= true&(share__choice(leftMotorVelocity.in?currLeftVel -> (SStop /\ set_currLeftVel!currLeftVel -> SKIP)));true&(share__choice(rightMotorVelocity.in?currRightVel -> (SStop /\ set_currRightVel!currRightVel -> SKIP)));share__choice(get_currRightVel?currRightVel -> share__choice(get_currLeftVel?currLeftVel -> true&CALL__SpeedPID(
									id__,
								    const_BalanceSTM_maxAngle,
								    const_BalanceSTM_loopTime,
								    const_BalanceSTM_startupDelay,
								    const_BalanceSTM_speedUpdate,
								    const_BalanceSTM_rotationUpdate,
								    const_BalanceSTM_angleBudget,
								    const_BalanceSTM_speedBudget,
								    const_BalanceSTM_rotationBudget,
								    const_BalanceSTM_motorBudget,
									Plus(currLeftVel, currRightVel, core_real), 
									const_SpeedPID_P, 
									const_SpeedPID_I, 
									const_SpeedPID_maxIntegral,
									const_AnglePID_P,
									const_AnglePID_D,
									const_RotationPID_D
								)));share__choice(true & (share__choice(set_speedCount!0 -> SKIP)));SKIP ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__,
							    const_BalanceSTM_maxAngle,
							    const_BalanceSTM_loopTime,
							    const_BalanceSTM_startupDelay,
							    const_BalanceSTM_speedUpdate,
							    const_BalanceSTM_rotationUpdate,
							    const_BalanceSTM_angleBudget,
							    const_BalanceSTM_speedBudget,
							    const_BalanceSTM_rotationBudget,
							    const_BalanceSTM_motorBudget,
							    const_AnglePID_P,
							    const_AnglePID_D,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral,
							    const_RotationPID_D) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= true&(share__choice(leftMotorVelocity.in?currLeftVel -> (SStop /\ set_currLeftVel!currLeftVel -> SKIP)));true&(share__choice(rightMotorVelocity.in?currRightVel -> (SStop /\ set_currRightVel!currRightVel -> SKIP)));share__choice(get_currRightVel?currRightVel -> share__choice(get_currLeftVel?currLeftVel -> true&CALL__SpeedPID(
									id__,
								    const_BalanceSTM_maxAngle,
								    const_BalanceSTM_loopTime,
								    const_BalanceSTM_startupDelay,
								    const_BalanceSTM_speedUpdate,
								    const_BalanceSTM_rotationUpdate,
								    const_BalanceSTM_angleBudget,
								    const_BalanceSTM_speedBudget,
								    const_BalanceSTM_rotationBudget,
								    const_BalanceSTM_motorBudget,
									Plus(currLeftVel, currRightVel, core_real), 
									const_SpeedPID_P, 
									const_SpeedPID_I, 
									const_SpeedPID_maxIntegral,
									const_AnglePID_P,
									const_AnglePID_D,
									const_RotationPID_D
								)));share__choice(true & (share__choice(set_speedCount!0 -> SKIP)));SKIP ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
					
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: CalculateRotation
				module CalculateRotation
				
				enterSS = {}
				
				enteredSS = {}
				
				exports
				
					--  Declarations
					
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
									
					
					--	Nodes
					-- declaring all nodes
					
					
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__,
							    const_BalanceSTM_maxAngle,
							    const_BalanceSTM_loopTime,
							    const_BalanceSTM_startupDelay,
							    const_BalanceSTM_speedUpdate,
							    const_BalanceSTM_rotationUpdate,
							    const_BalanceSTM_angleBudget,
							    const_BalanceSTM_speedBudget,
							    const_BalanceSTM_rotationBudget,
							    const_BalanceSTM_motorBudget,
							    const_AnglePID_P,
							    const_AnglePID_D,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral,
							    const_RotationPID_D) = 
					dbisim(let
						-- IMPLEMENTATION NOTE: 
						-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
						-- however FDR struggles with that form in certain cases. So we use the exception operator
						-- instead to 'terminate'.
						
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= true&(share__choice(gyroZ.in?currGyroZ -> (SStop /\ set_currGyroZ!currGyroZ -> SKIP)));share__choice(get_currGyroZ?currGyroZ -> true&CALL__RotationPID(
									id__,
								    const_BalanceSTM_maxAngle,
								    const_BalanceSTM_loopTime,
								    const_BalanceSTM_startupDelay,
								    const_BalanceSTM_speedUpdate,
								    const_BalanceSTM_rotationUpdate,
								    const_BalanceSTM_angleBudget,
								    const_BalanceSTM_speedBudget,
								    const_BalanceSTM_rotationBudget,
								    const_BalanceSTM_motorBudget,
									currGyroZ, 
									const_RotationPID_D,
									const_AnglePID_P,
									const_AnglePID_D,
									const_SpeedPID_P,
									const_SpeedPID_I,
									const_SpeedPID_maxIntegral
								));share__choice(true & (share__choice(set_rotationCount!0 -> SKIP)));SKIP ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__,
							    const_BalanceSTM_maxAngle,
							    const_BalanceSTM_loopTime,
							    const_BalanceSTM_startupDelay,
							    const_BalanceSTM_speedUpdate,
							    const_BalanceSTM_rotationUpdate,
							    const_BalanceSTM_angleBudget,
							    const_BalanceSTM_speedBudget,
							    const_BalanceSTM_rotationBudget,
							    const_BalanceSTM_motorBudget,
							    const_AnglePID_P,
							    const_AnglePID_D,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral,
							    const_RotationPID_D) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= true&(share__choice(gyroZ.in?currGyroZ -> (SStop /\ set_currGyroZ!currGyroZ -> SKIP)));share__choice(get_currGyroZ?currGyroZ -> true&CALL__RotationPID(
									id__,
								    const_BalanceSTM_maxAngle,
								    const_BalanceSTM_loopTime,
								    const_BalanceSTM_startupDelay,
								    const_BalanceSTM_speedUpdate,
								    const_BalanceSTM_rotationUpdate,
								    const_BalanceSTM_angleBudget,
								    const_BalanceSTM_speedBudget,
								    const_BalanceSTM_rotationBudget,
								    const_BalanceSTM_motorBudget,
									currGyroZ, 
									const_RotationPID_D,
									const_AnglePID_P,
									const_AnglePID_D,
									const_SpeedPID_P,
									const_SpeedPID_I,
									const_SpeedPID_maxIntegral
								));share__choice(true & (share__choice(set_rotationCount!0 -> SKIP)));SKIP ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
					
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: SetMotors
				module SetMotors
				
				enterSS = {}
				
				enteredSS = {}
				
				exports
				
					--  Declarations
					
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
									
					
					--	Nodes
					-- declaring all nodes
					
					
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__,
							    const_BalanceSTM_maxAngle,
							    const_BalanceSTM_loopTime,
							    const_BalanceSTM_startupDelay,
							    const_BalanceSTM_speedUpdate,
							    const_BalanceSTM_rotationUpdate,
							    const_BalanceSTM_angleBudget,
							    const_BalanceSTM_speedBudget,
							    const_BalanceSTM_rotationBudget,
							    const_BalanceSTM_motorBudget,
							    const_AnglePID_P,
							    const_AnglePID_D,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral,
							    const_RotationPID_D) = 
					dbisim(let
						-- IMPLEMENTATION NOTE: 
						-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
						-- however FDR struggles with that form in certain cases. So we use the exception operator
						-- instead to 'terminate'.
						
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= share__choice(get_speedOutput?speedOutput -> share__choice(get_rotationOutput?rotationOutput -> share__choice(get_angleOutput?angleOutput -> true&CALL__setLeftMotorSpeed(
									id__,
								    const_BalanceSTM_maxAngle,
								    const_BalanceSTM_loopTime,
								    const_BalanceSTM_startupDelay,
								    const_BalanceSTM_speedUpdate,
								    const_BalanceSTM_rotationUpdate,
								    const_BalanceSTM_angleBudget,
								    const_BalanceSTM_speedBudget,
								    const_BalanceSTM_rotationBudget,
								    const_BalanceSTM_motorBudget,
									Minus(Plus(angleOutput, speedOutput, core_real), rotationOutput, core_real),
									const_AnglePID_P,
									const_AnglePID_D,
									const_SpeedPID_P,
									const_SpeedPID_I,
									const_SpeedPID_maxIntegral,
									const_RotationPID_D
								))));share__choice(get_speedOutput?speedOutput -> share__choice(get_rotationOutput?rotationOutput -> share__choice(get_angleOutput?angleOutput -> true&CALL__setRightMotorSpeed(
									id__,
								    const_BalanceSTM_maxAngle,
								    const_BalanceSTM_loopTime,
								    const_BalanceSTM_startupDelay,
								    const_BalanceSTM_speedUpdate,
								    const_BalanceSTM_rotationUpdate,
								    const_BalanceSTM_angleBudget,
								    const_BalanceSTM_speedBudget,
								    const_BalanceSTM_rotationBudget,
								    const_BalanceSTM_motorBudget,
									Plus(Plus(angleOutput, speedOutput, core_real), rotationOutput, core_real),
									const_AnglePID_P,
									const_AnglePID_D,
									const_SpeedPID_P,
									const_SpeedPID_I,
									const_SpeedPID_maxIntegral,
									const_RotationPID_D
								))));SKIP ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__,
							    const_BalanceSTM_maxAngle,
							    const_BalanceSTM_loopTime,
							    const_BalanceSTM_startupDelay,
							    const_BalanceSTM_speedUpdate,
							    const_BalanceSTM_rotationUpdate,
							    const_BalanceSTM_angleBudget,
							    const_BalanceSTM_speedBudget,
							    const_BalanceSTM_rotationBudget,
							    const_BalanceSTM_motorBudget,
							    const_AnglePID_P,
							    const_AnglePID_D,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral,
							    const_RotationPID_D) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= share__choice(get_speedOutput?speedOutput -> share__choice(get_rotationOutput?rotationOutput -> share__choice(get_angleOutput?angleOutput -> true&CALL__setLeftMotorSpeed(
									id__,
								    const_BalanceSTM_maxAngle,
								    const_BalanceSTM_loopTime,
								    const_BalanceSTM_startupDelay,
								    const_BalanceSTM_speedUpdate,
								    const_BalanceSTM_rotationUpdate,
								    const_BalanceSTM_angleBudget,
								    const_BalanceSTM_speedBudget,
								    const_BalanceSTM_rotationBudget,
								    const_BalanceSTM_motorBudget,
									Minus(Plus(angleOutput, speedOutput, core_real), rotationOutput, core_real),
									const_AnglePID_P,
									const_AnglePID_D,
									const_SpeedPID_P,
									const_SpeedPID_I,
									const_SpeedPID_maxIntegral,
									const_RotationPID_D
								))));share__choice(get_speedOutput?speedOutput -> share__choice(get_rotationOutput?rotationOutput -> share__choice(get_angleOutput?angleOutput -> true&CALL__setRightMotorSpeed(
									id__,
								    const_BalanceSTM_maxAngle,
								    const_BalanceSTM_loopTime,
								    const_BalanceSTM_startupDelay,
								    const_BalanceSTM_speedUpdate,
								    const_BalanceSTM_rotationUpdate,
								    const_BalanceSTM_angleBudget,
								    const_BalanceSTM_speedBudget,
								    const_BalanceSTM_rotationBudget,
								    const_BalanceSTM_motorBudget,
									Plus(Plus(angleOutput, speedOutput, core_real), rotationOutput, core_real),
									const_AnglePID_P,
									const_AnglePID_D,
									const_SpeedPID_P,
									const_SpeedPID_I,
									const_SpeedPID_maxIntegral,
									const_RotationPID_D
								))));SKIP ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
					
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- Junction: j0
				module j0
				exports
				
					channel enter, interrupt
					
					D__(id__,
							    const_BalanceSTM_maxAngle,
							    const_BalanceSTM_loopTime,
							    const_BalanceSTM_startupDelay,
							    const_BalanceSTM_speedUpdate,
							    const_BalanceSTM_rotationUpdate,
							    const_BalanceSTM_angleBudget,
							    const_BalanceSTM_speedBudget,
							    const_BalanceSTM_rotationBudget,
							    const_BalanceSTM_motorBudget,
							    const_AnglePID_P,
							    const_AnglePID_D,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral,
							    const_RotationPID_D) = 
						dbisim(let
							Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
							
							Active 		= share__choice(interrupt -> SKIP) ; Inactive
						within
							Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__,
							    const_BalanceSTM_maxAngle,
							    const_BalanceSTM_loopTime,
							    const_BalanceSTM_startupDelay,
							    const_BalanceSTM_speedUpdate,
							    const_BalanceSTM_rotationUpdate,
							    const_BalanceSTM_angleBudget,
							    const_BalanceSTM_speedBudget,
							    const_BalanceSTM_rotationBudget,
							    const_BalanceSTM_motorBudget,
							    const_AnglePID_P,
							    const_AnglePID_D,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral,
							    const_RotationPID_D) = D__(id__,
							    const_BalanceSTM_maxAngle,
							    const_BalanceSTM_loopTime,
							    const_BalanceSTM_startupDelay,
							    const_BalanceSTM_speedUpdate,
							    const_BalanceSTM_rotationUpdate,
							    const_BalanceSTM_angleBudget,
							    const_BalanceSTM_speedBudget,
							    const_BalanceSTM_rotationBudget,
							    const_BalanceSTM_motorBudget,
							    const_AnglePID_P,
							    const_AnglePID_D,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral,
							    const_RotationPID_D)
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- Junction: j1
				module j1
				exports
				
					channel enter, interrupt
					
					D__(id__,
							    const_BalanceSTM_maxAngle,
							    const_BalanceSTM_loopTime,
							    const_BalanceSTM_startupDelay,
							    const_BalanceSTM_speedUpdate,
							    const_BalanceSTM_rotationUpdate,
							    const_BalanceSTM_angleBudget,
							    const_BalanceSTM_speedBudget,
							    const_BalanceSTM_rotationBudget,
							    const_BalanceSTM_motorBudget,
							    const_AnglePID_P,
							    const_AnglePID_D,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral,
							    const_RotationPID_D) = 
						dbisim(let
							Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
							
							Active 		= share__choice(interrupt -> SKIP) ; Inactive
						within
							Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__,
							    const_BalanceSTM_maxAngle,
							    const_BalanceSTM_loopTime,
							    const_BalanceSTM_startupDelay,
							    const_BalanceSTM_speedUpdate,
							    const_BalanceSTM_rotationUpdate,
							    const_BalanceSTM_angleBudget,
							    const_BalanceSTM_speedBudget,
							    const_BalanceSTM_rotationBudget,
							    const_BalanceSTM_motorBudget,
							    const_AnglePID_P,
							    const_AnglePID_D,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral,
							    const_RotationPID_D) = D__(id__,
							    const_BalanceSTM_maxAngle,
							    const_BalanceSTM_loopTime,
							    const_BalanceSTM_startupDelay,
							    const_BalanceSTM_speedUpdate,
							    const_BalanceSTM_rotationUpdate,
							    const_BalanceSTM_angleBudget,
							    const_BalanceSTM_speedBudget,
							    const_BalanceSTM_rotationBudget,
							    const_BalanceSTM_motorBudget,
							    const_AnglePID_P,
							    const_AnglePID_D,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral,
							    const_RotationPID_D)
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- Junction: j2
				module j2
				exports
				
					channel enter, interrupt
					
					D__(id__,
							    const_BalanceSTM_maxAngle,
							    const_BalanceSTM_loopTime,
							    const_BalanceSTM_startupDelay,
							    const_BalanceSTM_speedUpdate,
							    const_BalanceSTM_rotationUpdate,
							    const_BalanceSTM_angleBudget,
							    const_BalanceSTM_speedBudget,
							    const_BalanceSTM_rotationBudget,
							    const_BalanceSTM_motorBudget,
							    const_AnglePID_P,
							    const_AnglePID_D,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral,
							    const_RotationPID_D) = 
						dbisim(let
							Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
							
							Active 		= share__choice(interrupt -> SKIP) ; Inactive
						within
							Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__,
							    const_BalanceSTM_maxAngle,
							    const_BalanceSTM_loopTime,
							    const_BalanceSTM_startupDelay,
							    const_BalanceSTM_speedUpdate,
							    const_BalanceSTM_rotationUpdate,
							    const_BalanceSTM_angleBudget,
							    const_BalanceSTM_speedBudget,
							    const_BalanceSTM_rotationBudget,
							    const_BalanceSTM_motorBudget,
							    const_AnglePID_P,
							    const_AnglePID_D,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral,
							    const_RotationPID_D) = D__(id__,
							    const_BalanceSTM_maxAngle,
							    const_BalanceSTM_loopTime,
							    const_BalanceSTM_startupDelay,
							    const_BalanceSTM_speedUpdate,
							    const_BalanceSTM_rotationUpdate,
							    const_BalanceSTM_angleBudget,
							    const_BalanceSTM_speedBudget,
							    const_BalanceSTM_rotationBudget,
							    const_BalanceSTM_motorBudget,
							    const_AnglePID_P,
							    const_AnglePID_D,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral,
							    const_RotationPID_D)
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: StopMotors
				module StopMotors
				
				enterSS = {}
				
				enteredSS = {}
				
				exports
				
					--  Declarations
					
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
									
					
					--	Nodes
					-- declaring all nodes
					
					
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__,
							    const_BalanceSTM_maxAngle,
							    const_BalanceSTM_loopTime,
							    const_BalanceSTM_startupDelay,
							    const_BalanceSTM_speedUpdate,
							    const_BalanceSTM_rotationUpdate,
							    const_BalanceSTM_angleBudget,
							    const_BalanceSTM_speedBudget,
							    const_BalanceSTM_rotationBudget,
							    const_BalanceSTM_motorBudget,
							    const_AnglePID_P,
							    const_AnglePID_D,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral,
							    const_RotationPID_D) = 
					dbisim(let
						-- IMPLEMENTATION NOTE: 
						-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
						-- however FDR struggles with that form in certain cases. So we use the exception operator
						-- instead to 'terminate'.
						
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= true&CALL__setLeftMotorSpeed(
									id__,
								    const_BalanceSTM_maxAngle,
								    const_BalanceSTM_loopTime,
								    const_BalanceSTM_startupDelay,
								    const_BalanceSTM_speedUpdate,
								    const_BalanceSTM_rotationUpdate,
								    const_BalanceSTM_angleBudget,
								    const_BalanceSTM_speedBudget,
								    const_BalanceSTM_rotationBudget,
								    const_BalanceSTM_motorBudget,
									0,
									const_AnglePID_P,
									const_AnglePID_D,
									const_SpeedPID_P,
									const_SpeedPID_I,
									const_SpeedPID_maxIntegral,
									const_RotationPID_D
								);true&CALL__setRightMotorSpeed(
									id__,
								    const_BalanceSTM_maxAngle,
								    const_BalanceSTM_loopTime,
								    const_BalanceSTM_startupDelay,
								    const_BalanceSTM_speedUpdate,
								    const_BalanceSTM_rotationUpdate,
								    const_BalanceSTM_angleBudget,
								    const_BalanceSTM_speedBudget,
								    const_BalanceSTM_rotationBudget,
								    const_BalanceSTM_motorBudget,
									0,
									const_AnglePID_P,
									const_AnglePID_D,
									const_SpeedPID_P,
									const_SpeedPID_I,
									const_SpeedPID_maxIntegral,
									const_RotationPID_D
								);SKIP ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__,
							    const_BalanceSTM_maxAngle,
							    const_BalanceSTM_loopTime,
							    const_BalanceSTM_startupDelay,
							    const_BalanceSTM_speedUpdate,
							    const_BalanceSTM_rotationUpdate,
							    const_BalanceSTM_angleBudget,
							    const_BalanceSTM_speedBudget,
							    const_BalanceSTM_rotationBudget,
							    const_BalanceSTM_motorBudget,
							    const_AnglePID_P,
							    const_AnglePID_D,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral,
							    const_RotationPID_D) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= true&CALL__setLeftMotorSpeed(
									id__,
								    const_BalanceSTM_maxAngle,
								    const_BalanceSTM_loopTime,
								    const_BalanceSTM_startupDelay,
								    const_BalanceSTM_speedUpdate,
								    const_BalanceSTM_rotationUpdate,
								    const_BalanceSTM_angleBudget,
								    const_BalanceSTM_speedBudget,
								    const_BalanceSTM_rotationBudget,
								    const_BalanceSTM_motorBudget,
									0,
									const_AnglePID_P,
									const_AnglePID_D,
									const_SpeedPID_P,
									const_SpeedPID_I,
									const_SpeedPID_maxIntegral,
									const_RotationPID_D
								);true&CALL__setRightMotorSpeed(
									id__,
								    const_BalanceSTM_maxAngle,
								    const_BalanceSTM_loopTime,
								    const_BalanceSTM_startupDelay,
								    const_BalanceSTM_speedUpdate,
								    const_BalanceSTM_rotationUpdate,
								    const_BalanceSTM_angleBudget,
								    const_BalanceSTM_speedBudget,
								    const_BalanceSTM_rotationBudget,
								    const_BalanceSTM_motorBudget,
									0,
									const_AnglePID_P,
									const_AnglePID_D,
									const_SpeedPID_P,
									const_SpeedPID_I,
									const_SpeedPID_maxIntegral,
									const_RotationPID_D
								);SKIP ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
					
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: WaitForNextIteration
				module WaitForNextIteration
				
				enterSS = {}
				
				enteredSS = {}
				
				exports
				
					--  Declarations
					
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
									
					
					--	Nodes
					-- declaring all nodes
					
					
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__,
							    const_BalanceSTM_maxAngle,
							    const_BalanceSTM_loopTime,
							    const_BalanceSTM_startupDelay,
							    const_BalanceSTM_speedUpdate,
							    const_BalanceSTM_rotationUpdate,
							    const_BalanceSTM_angleBudget,
							    const_BalanceSTM_speedBudget,
							    const_BalanceSTM_rotationBudget,
							    const_BalanceSTM_motorBudget,
							    const_AnglePID_P,
							    const_AnglePID_D,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral,
							    const_RotationPID_D) = 
					dbisim(let
						-- IMPLEMENTATION NOTE: 
						-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
						-- however FDR struggles with that form in certain cases. So we use the exception operator
						-- instead to 'terminate'.
						
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= SKIP ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__,
							    const_BalanceSTM_maxAngle,
							    const_BalanceSTM_loopTime,
							    const_BalanceSTM_startupDelay,
							    const_BalanceSTM_speedUpdate,
							    const_BalanceSTM_rotationUpdate,
							    const_BalanceSTM_angleBudget,
							    const_BalanceSTM_speedBudget,
							    const_BalanceSTM_rotationBudget,
							    const_BalanceSTM_motorBudget,
							    const_AnglePID_P,
							    const_AnglePID_D,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral,
							    const_RotationPID_D) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= SKIP ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
					
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: Initialisation
				module Initialisation
				
				enterSS = {}
				
				enteredSS = {}
				
				exports
				
					--  Declarations
					
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
									
					
					--	Nodes
					-- declaring all nodes
					
					
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__,
							    const_BalanceSTM_maxAngle,
							    const_BalanceSTM_loopTime,
							    const_BalanceSTM_startupDelay,
							    const_BalanceSTM_speedUpdate,
							    const_BalanceSTM_rotationUpdate,
							    const_BalanceSTM_angleBudget,
							    const_BalanceSTM_speedBudget,
							    const_BalanceSTM_rotationBudget,
							    const_BalanceSTM_motorBudget,
							    const_AnglePID_P,
							    const_AnglePID_D,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral,
							    const_RotationPID_D) = 
					dbisim(let
						-- IMPLEMENTATION NOTE: 
						-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
						-- however FDR struggles with that form in certain cases. So we use the exception operator
						-- instead to 'terminate'.
						
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= share__choice(true & (share__choice(set_speedCount!0 -> SKIP)));share__choice(true & (share__choice(set_rotationCount!0 -> SKIP)));SKIP;SKIP ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__,
							    const_BalanceSTM_maxAngle,
							    const_BalanceSTM_loopTime,
							    const_BalanceSTM_startupDelay,
							    const_BalanceSTM_speedUpdate,
							    const_BalanceSTM_rotationUpdate,
							    const_BalanceSTM_angleBudget,
							    const_BalanceSTM_speedBudget,
							    const_BalanceSTM_rotationBudget,
							    const_BalanceSTM_motorBudget,
							    const_AnglePID_P,
							    const_AnglePID_D,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral,
							    const_RotationPID_D) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= share__choice(true & (share__choice(set_speedCount!0 -> SKIP)));share__choice(true & (share__choice(set_rotationCount!0 -> SKIP)));SKIP;SKIP ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
					
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- Junction: j3
				module j3
				exports
				
					channel enter, interrupt
					
					D__(id__,
							    const_BalanceSTM_maxAngle,
							    const_BalanceSTM_loopTime,
							    const_BalanceSTM_startupDelay,
							    const_BalanceSTM_speedUpdate,
							    const_BalanceSTM_rotationUpdate,
							    const_BalanceSTM_angleBudget,
							    const_BalanceSTM_speedBudget,
							    const_BalanceSTM_rotationBudget,
							    const_BalanceSTM_motorBudget,
							    const_AnglePID_P,
							    const_AnglePID_D,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral,
							    const_RotationPID_D) = 
						dbisim(let
							Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
							
							Active 		= share__choice(interrupt -> SKIP) ; Inactive
						within
							Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__,
							    const_BalanceSTM_maxAngle,
							    const_BalanceSTM_loopTime,
							    const_BalanceSTM_startupDelay,
							    const_BalanceSTM_speedUpdate,
							    const_BalanceSTM_rotationUpdate,
							    const_BalanceSTM_angleBudget,
							    const_BalanceSTM_speedBudget,
							    const_BalanceSTM_rotationBudget,
							    const_BalanceSTM_motorBudget,
							    const_AnglePID_P,
							    const_AnglePID_D,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral,
							    const_RotationPID_D) = D__(id__,
							    const_BalanceSTM_maxAngle,
							    const_BalanceSTM_loopTime,
							    const_BalanceSTM_startupDelay,
							    const_BalanceSTM_speedUpdate,
							    const_BalanceSTM_rotationUpdate,
							    const_BalanceSTM_angleBudget,
							    const_BalanceSTM_speedBudget,
							    const_BalanceSTM_rotationBudget,
							    const_BalanceSTM_motorBudget,
							    const_AnglePID_P,
							    const_AnglePID_D,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral,
							    const_RotationPID_D)
				
				endmodule
				----------------------------------------------------------------------
				
				-- END of Nodes --
				
				-- Operation calls --
				-- Only the undefined operations are declared here.
				-- If the state machine is in isolation, all required operations will be undefined.
				-- If it is in the context of a controller, the required operations not provided by the
				-- controller will be declared here, and the defined operations will be defined in the
				-- context of the Controller module, and therefore within scope of the state machine module.
				CALL__setLeftMotorSpeed(id__,
						    const_BalanceSTM_maxAngle,
						    const_BalanceSTM_loopTime,
						    const_BalanceSTM_startupDelay,
						    const_BalanceSTM_speedUpdate,
						    const_BalanceSTM_rotationUpdate,
						    const_BalanceSTM_angleBudget,
						    const_BalanceSTM_speedBudget,
						    const_BalanceSTM_rotationBudget,
						    const_BalanceSTM_motorBudget,
							param_speed,
						    const_AnglePID_P,
						    const_AnglePID_D,
						    const_SpeedPID_P,
						    const_SpeedPID_I,
						    const_SpeedPID_maxIntegral,
						    const_RotationPID_D) 	= setLeftMotorSpeedCall.param_speed -> SKIP
				CALL__enableInterrupts(id__,
						    const_BalanceSTM_maxAngle,
						    const_BalanceSTM_loopTime,
						    const_BalanceSTM_startupDelay,
						    const_BalanceSTM_speedUpdate,
						    const_BalanceSTM_rotationUpdate,
						    const_BalanceSTM_angleBudget,
						    const_BalanceSTM_speedBudget,
						    const_BalanceSTM_rotationBudget,
						    const_BalanceSTM_motorBudget,
						    const_AnglePID_P,
						    const_AnglePID_D,
						    const_SpeedPID_P,
						    const_SpeedPID_I,
						    const_SpeedPID_maxIntegral,
						    const_RotationPID_D) 	= enableInterruptsCall -> SKIP
				CALL__setRightMotorSpeed(id__,
						    const_BalanceSTM_maxAngle,
						    const_BalanceSTM_loopTime,
						    const_BalanceSTM_startupDelay,
						    const_BalanceSTM_speedUpdate,
						    const_BalanceSTM_rotationUpdate,
						    const_BalanceSTM_angleBudget,
						    const_BalanceSTM_speedBudget,
						    const_BalanceSTM_rotationBudget,
						    const_BalanceSTM_motorBudget,
							param_speed,
						    const_AnglePID_P,
						    const_AnglePID_D,
						    const_SpeedPID_P,
						    const_SpeedPID_I,
						    const_SpeedPID_maxIntegral,
						    const_RotationPID_D) 	= setRightMotorSpeedCall.param_speed -> SKIP
				CALL__disableInterrupts(id__,
						    const_BalanceSTM_maxAngle,
						    const_BalanceSTM_loopTime,
						    const_BalanceSTM_startupDelay,
						    const_BalanceSTM_speedUpdate,
						    const_BalanceSTM_rotationUpdate,
						    const_BalanceSTM_angleBudget,
						    const_BalanceSTM_speedBudget,
						    const_BalanceSTM_rotationBudget,
						    const_BalanceSTM_motorBudget,
						    const_AnglePID_P,
						    const_AnglePID_D,
						    const_SpeedPID_P,
						    const_SpeedPID_I,
						    const_SpeedPID_maxIntegral,
						    const_RotationPID_D) 	= disableInterruptsCall -> SKIP
				
				CALL__AnglePID(id__,
						    const_BalanceSTM_maxAngle,
						    const_BalanceSTM_loopTime,
						    const_BalanceSTM_startupDelay,
						    const_BalanceSTM_speedUpdate,
						    const_BalanceSTM_rotationUpdate,
						    const_BalanceSTM_angleBudget,
						    const_BalanceSTM_speedBudget,
						    const_BalanceSTM_rotationBudget,
						    const_BalanceSTM_motorBudget,
							param_newError,
							param_diff,
						    const_AnglePID_P,
						    const_AnglePID_D,
						    const_SpeedPID_P,
						    const_SpeedPID_I,
						    const_SpeedPID_maxIntegral,
						    const_RotationPID_D) = (OP_AnglePID::O__(id__,
							param_newError,
							param_diff,
						    const_AnglePID_P,
						    const_AnglePID_D))
				[[
					OP_AnglePID::get_angleOutput <- get_angleOutput,
					OP_AnglePID::set_angleOutput <- set_angleOutput
				]]
				CALL__SpeedPID(id__,
						    const_BalanceSTM_maxAngle,
						    const_BalanceSTM_loopTime,
						    const_BalanceSTM_startupDelay,
						    const_BalanceSTM_speedUpdate,
						    const_BalanceSTM_rotationUpdate,
						    const_BalanceSTM_angleBudget,
						    const_BalanceSTM_speedBudget,
						    const_BalanceSTM_rotationBudget,
						    const_BalanceSTM_motorBudget,
							param_newError,
						    const_SpeedPID_P,
						    const_SpeedPID_I,
						    const_SpeedPID_maxIntegral,
						    const_AnglePID_P,
						    const_AnglePID_D,
						    const_RotationPID_D) = (OP_SpeedPID::O__(id__,
							param_newError,
						    const_SpeedPID_P,
						    const_SpeedPID_I,
						    const_SpeedPID_maxIntegral))
				[[
					OP_SpeedPID::get_speedIntegral <- get_speedIntegral,
					OP_SpeedPID::set_speedIntegral <- set_speedIntegral,
					OP_SpeedPID::get_speedOutput <- get_speedOutput,
					OP_SpeedPID::set_speedOutput <- set_speedOutput
				]]
				CALL__RotationPID(id__,
						    const_BalanceSTM_maxAngle,
						    const_BalanceSTM_loopTime,
						    const_BalanceSTM_startupDelay,
						    const_BalanceSTM_speedUpdate,
						    const_BalanceSTM_rotationUpdate,
						    const_BalanceSTM_angleBudget,
						    const_BalanceSTM_speedBudget,
						    const_BalanceSTM_rotationBudget,
						    const_BalanceSTM_motorBudget,
							param_diff,
						    const_RotationPID_D,
						    const_AnglePID_P,
						    const_AnglePID_D,
						    const_SpeedPID_P,
						    const_SpeedPID_I,
						    const_SpeedPID_maxIntegral) = (OP_RotationPID::O__(id__,
							param_diff,
						    const_RotationPID_D))
				[[
					OP_RotationPID::get_rotationOutput <- get_rotationOutput,
					OP_RotationPID::set_rotationOutput <- set_rotationOutput
				]]
				-- END of Operation calls --
				
				-- STM processes
				STM(id__,
						    const_BalanceSTM_maxAngle,
						    const_BalanceSTM_loopTime,
						    const_BalanceSTM_startupDelay,
						    const_BalanceSTM_speedUpdate,
						    const_BalanceSTM_rotationUpdate,
						    const_BalanceSTM_angleBudget,
						    const_BalanceSTM_speedBudget,
						    const_BalanceSTM_rotationBudget,
						    const_BalanceSTM_motorBudget,
						    const_AnglePID_P,
						    const_AnglePID_D,
						    const_SpeedPID_P,
						    const_SpeedPID_I,
						    const_SpeedPID_maxIntegral,
						    const_RotationPID_D) = -- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
				( 
					(
						(
							(IteratedStateful(id__,
									    const_BalanceSTM_maxAngle,
									    const_BalanceSTM_loopTime,
									    const_BalanceSTM_startupDelay,
									    const_BalanceSTM_speedUpdate,
									    const_BalanceSTM_rotationUpdate,
									    const_BalanceSTM_angleBudget,
									    const_BalanceSTM_speedBudget,
									    const_BalanceSTM_rotationBudget,
									    const_BalanceSTM_motorBudget,
									    const_AnglePID_P,
									    const_AnglePID_D,
									    const_SpeedPID_P,
									    const_SpeedPID_I,
									    const_SpeedPID_maxIntegral,
									    const_RotationPID_D) \ {terminate} ; share__choice(terminate -> SKIP))
						 	[[ share__ <- x__ | x__ <- {||} ]]
						)
					[| {share__} |]
					SKIP
					)
					[| union(sharedVarSync,{terminate}) |]
					dbisim(sharedVarMemory(id__,
							    const_BalanceSTM_maxAngle,
							    const_BalanceSTM_loopTime,
							    const_BalanceSTM_startupDelay,
							    const_BalanceSTM_speedUpdate,
							    const_BalanceSTM_rotationUpdate,
							    const_BalanceSTM_angleBudget,
							    const_BalanceSTM_speedBudget,
							    const_BalanceSTM_rotationBudget,
							    const_BalanceSTM_motorBudget,
							    const_AnglePID_P,
							    const_AnglePID_D,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral,
							    const_RotationPID_D))
				)\sharedVarHide
				
				STM_VS_O(id__,
						    const_BalanceSTM_maxAngle,
						    const_BalanceSTM_loopTime,
						    const_BalanceSTM_startupDelay,
						    const_BalanceSTM_speedUpdate,
						    const_BalanceSTM_rotationUpdate,
						    const_BalanceSTM_angleBudget,
						    const_BalanceSTM_speedBudget,
						    const_BalanceSTM_rotationBudget,
						    const_BalanceSTM_motorBudget,
						    const_AnglePID_P,
						    const_AnglePID_D,
						    const_SpeedPID_P,
						    const_SpeedPID_I,
						    const_SpeedPID_maxIntegral,
						    const_RotationPID_D) = -- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
				( 
					(
						(
							(IteratedStateful_VS_O(id__,
									    const_BalanceSTM_maxAngle,
									    const_BalanceSTM_loopTime,
									    const_BalanceSTM_startupDelay,
									    const_BalanceSTM_speedUpdate,
									    const_BalanceSTM_rotationUpdate,
									    const_BalanceSTM_angleBudget,
									    const_BalanceSTM_speedBudget,
									    const_BalanceSTM_rotationBudget,
									    const_BalanceSTM_motorBudget,
									    const_AnglePID_P,
									    const_AnglePID_D,
									    const_SpeedPID_P,
									    const_SpeedPID_I,
									    const_SpeedPID_maxIntegral,
									    const_RotationPID_D) \ {terminate} ; share__choice(terminate -> SKIP))
						 	[[ share__ <- x__ | x__ <- {||} ]]
						)
					[| {share__} |]
					SKIP
					)
					[| union(sharedVarSync,{terminate}) |]
					dbisim(sharedVarMemory(id__,
							    const_BalanceSTM_maxAngle,
							    const_BalanceSTM_loopTime,
							    const_BalanceSTM_startupDelay,
							    const_BalanceSTM_speedUpdate,
							    const_BalanceSTM_rotationUpdate,
							    const_BalanceSTM_angleBudget,
							    const_BalanceSTM_speedBudget,
							    const_BalanceSTM_rotationBudget,
							    const_BalanceSTM_motorBudget,
							    const_AnglePID_P,
							    const_AnglePID_D,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral,
							    const_RotationPID_D))
				)\sharedVarHide
				
				-- Transitions
				Transitions(id__,
						    const_BalanceSTM_maxAngle,
						    const_BalanceSTM_loopTime,
						    const_BalanceSTM_startupDelay,
						    const_BalanceSTM_speedUpdate,
						    const_BalanceSTM_rotationUpdate,
						    const_BalanceSTM_angleBudget,
						    const_BalanceSTM_speedBudget,
						    const_BalanceSTM_rotationBudget,
						    const_BalanceSTM_motorBudget,
						    const_AnglePID_P,
						    const_AnglePID_D,
						    const_SpeedPID_P,
						    const_SpeedPID_I,
						    const_SpeedPID_maxIntegral,
						    const_RotationPID_D) = ((let
					Trans = share__choice(get_speedCount?speedCount -> get_rotationCount?rotationCount -> get_currAngle?currAngle -> (
						((share__ -> SKIP
						 [] dbisim(((speedCount>=const_BalanceSTM_speedUpdate))&(internal__!NID_j0 -> SKIP ;  ((SKIP ; CalculateSpeed::enter -> SKIP))))
						 	 [] dbisim((true)&(internal__!NID_CalculateSpeed -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; j1::enter -> SKIP)))
						 	 [] dbisim((true)&(internal__!NID_CalculateAngle -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(share__choice(get_speedCount?speedCount -> true & (share__choice(set_speedCount!Plus(speedCount, 1, core_nat) -> SKIP)))) ; j0::enter -> SKIP)))
						 	 [] dbisim(((speedCount<const_BalanceSTM_speedUpdate))&(internal__!NID_j0 -> SKIP ;  ((SKIP ; j1::enter -> SKIP))))
						 	 [] dbisim((true)&(internal__!NID_CalculateRotation -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; j2::enter -> SKIP)))
						 	 [] dbisim((((currAngle<=const_BalanceSTM_maxAngle) and (currAngle>=Neg(const_BalanceSTM_maxAngle, core_real))))&(internal__!NID_j2 -> SKIP ;  ((SKIP ; SetMotors::enter -> SKIP))))
						 	 [] dbisim((((currAngle>const_BalanceSTM_maxAngle) or (currAngle<Neg(const_BalanceSTM_maxAngle, core_real))))&(internal__!NID_j2 -> SKIP ;  ((SKIP ; StopMotors::enter -> SKIP))))
						 	 [] dbisim((true)&(internal__!NID_WaitForNextIteration -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; true&CALL__disableInterrupts(
						 			id__,
						 		    const_BalanceSTM_maxAngle,
						 		    const_BalanceSTM_loopTime,
						 		    const_BalanceSTM_startupDelay,
						 		    const_BalanceSTM_speedUpdate,
						 		    const_BalanceSTM_rotationUpdate,
						 		    const_BalanceSTM_angleBudget,
						 		    const_BalanceSTM_speedBudget,
						 		    const_BalanceSTM_rotationBudget,
						 		    const_BalanceSTM_motorBudget,
						 			const_AnglePID_P,
						 			const_AnglePID_D,
						 			const_SpeedPID_P,
						 			const_SpeedPID_I,
						 			const_SpeedPID_maxIntegral,
						 			const_RotationPID_D
						 		) ; CalculateAngle::enter -> SKIP)))
						 	 [] dbisim((true)&(internal__!NID_StopMotors -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; WaitForNextIteration::enter -> SKIP)))
						 	 [] dbisim((true)&(internal__!NID_SetMotors -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; WaitForNextIteration::enter -> SKIP)))
						 	 [] dbisim((true)&(internal__!NID_i0 -> SKIP ;  ((SKIP ; Initialisation::enter -> SKIP))))
						 	 [] dbisim((true)&(internal__!NID_Initialisation -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; WaitForNextIteration::enter -> SKIP)))
						 	 [] dbisim((true)&(internal__!NID_j1 -> SKIP ;  ((share__choice(share__choice(get_rotationCount?rotationCount -> true & (share__choice(set_rotationCount!Plus(rotationCount, 1, core_nat) -> SKIP)))) ; j3::enter -> SKIP))))
						 	 [] dbisim(((rotationCount>=const_BalanceSTM_rotationUpdate))&(internal__!NID_j3 -> SKIP ;  ((SKIP ; CalculateRotation::enter -> SKIP))))
						 	 [] dbisim(((rotationCount<const_BalanceSTM_rotationUpdate))&(internal__!NID_j3 -> SKIP ;  ((SKIP ; j2::enter -> SKIP))))
						 ) ; Trans)
						 []
						 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
						 []
						 terminate -> SKIP
					)
					)
				within
					Trans
				)
				)
				
				-- Stateful
				-- RULE: Stateful(stm:StateMachineBody) : CSPProcess
				
				-- Named process definitions
				MachineBody(id__,
						    const_BalanceSTM_maxAngle,
						    const_BalanceSTM_loopTime,
						    const_BalanceSTM_startupDelay,
						    const_BalanceSTM_speedUpdate,
						    const_BalanceSTM_rotationUpdate,
						    const_BalanceSTM_angleBudget,
						    const_BalanceSTM_speedBudget,
						    const_BalanceSTM_rotationBudget,
						    const_BalanceSTM_motorBudget,
						    const_AnglePID_P,
						    const_AnglePID_D,
						    const_SpeedPID_P,
						    const_SpeedPID_I,
						    const_SpeedPID_maxIntegral,
						    const_RotationPID_D) = 
					dbisim((
					let
						finalNodesEntered = {||}
					within
						((let
							-- IMPLEMENTATION NOTE:
							-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
							-- modules for defining the semantics of each node.
							enterSS = {|
							i0::enter,
							CalculateAngle::enter,
							CalculateSpeed::enter,
							CalculateRotation::enter,
							SetMotors::enter,
							j0::enter,
							j1::enter,
							j2::enter,
							StopMotors::enter,
							WaitForNextIteration::enter,
							Initialisation::enter,
							j3::enter
							|}
							hideSet = union(enterSS,{|exit,exited,internal__|})
						within 
							((let
								-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
								-- because CSPM modules are used for the semantics of Node.
								flowevts = union(enterSS,{|exit,exited,interrupt|})
								transSync = {|internal__.NID_j0,internal__.NID_CalculateSpeed,internal__.NID_CalculateAngle,internal__.NID_j0,internal__.NID_CalculateRotation,internal__.NID_j2,internal__.NID_j2,internal__.NID_WaitForNextIteration,internal__.NID_StopMotors,internal__.NID_SetMotors,internal__.NID_i0,internal__.NID_Initialisation,internal__.NID_j1,internal__.NID_j3,internal__.NID_j3|}
							within
								((
								 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
								   i0::D__(id__,
								   		    const_BalanceSTM_maxAngle,
								   		    const_BalanceSTM_loopTime,
								   		    const_BalanceSTM_startupDelay,
								   		    const_BalanceSTM_speedUpdate,
								   		    const_BalanceSTM_rotationUpdate,
								   		    const_BalanceSTM_angleBudget,
								   		    const_BalanceSTM_speedBudget,
								   		    const_BalanceSTM_rotationBudget,
								   		    const_BalanceSTM_motorBudget,
								   		    const_AnglePID_P,
								   		    const_AnglePID_D,
								   		    const_SpeedPID_P,
								   		    const_SpeedPID_I,
								   		    const_SpeedPID_maxIntegral,
								   		    const_RotationPID_D)
								   [| { share__, terminate } |] (
								   CalculateAngle::D__(id__,
								   		    const_BalanceSTM_maxAngle,
								   		    const_BalanceSTM_loopTime,
								   		    const_BalanceSTM_startupDelay,
								   		    const_BalanceSTM_speedUpdate,
								   		    const_BalanceSTM_rotationUpdate,
								   		    const_BalanceSTM_angleBudget,
								   		    const_BalanceSTM_speedBudget,
								   		    const_BalanceSTM_rotationBudget,
								   		    const_BalanceSTM_motorBudget,
								   		    const_AnglePID_P,
								   		    const_AnglePID_D,
								   		    const_SpeedPID_P,
								   		    const_SpeedPID_I,
								   		    const_SpeedPID_maxIntegral,
								   		    const_RotationPID_D)
								   [| { share__, terminate } |] (
								   CalculateSpeed::D__(id__,
								   		    const_BalanceSTM_maxAngle,
								   		    const_BalanceSTM_loopTime,
								   		    const_BalanceSTM_startupDelay,
								   		    const_BalanceSTM_speedUpdate,
								   		    const_BalanceSTM_rotationUpdate,
								   		    const_BalanceSTM_angleBudget,
								   		    const_BalanceSTM_speedBudget,
								   		    const_BalanceSTM_rotationBudget,
								   		    const_BalanceSTM_motorBudget,
								   		    const_AnglePID_P,
								   		    const_AnglePID_D,
								   		    const_SpeedPID_P,
								   		    const_SpeedPID_I,
								   		    const_SpeedPID_maxIntegral,
								   		    const_RotationPID_D)
								   [| { share__, terminate } |] (
								   CalculateRotation::D__(id__,
								   		    const_BalanceSTM_maxAngle,
								   		    const_BalanceSTM_loopTime,
								   		    const_BalanceSTM_startupDelay,
								   		    const_BalanceSTM_speedUpdate,
								   		    const_BalanceSTM_rotationUpdate,
								   		    const_BalanceSTM_angleBudget,
								   		    const_BalanceSTM_speedBudget,
								   		    const_BalanceSTM_rotationBudget,
								   		    const_BalanceSTM_motorBudget,
								   		    const_AnglePID_P,
								   		    const_AnglePID_D,
								   		    const_SpeedPID_P,
								   		    const_SpeedPID_I,
								   		    const_SpeedPID_maxIntegral,
								   		    const_RotationPID_D)
								   [| { share__, terminate } |] (
								   SetMotors::D__(id__,
								   		    const_BalanceSTM_maxAngle,
								   		    const_BalanceSTM_loopTime,
								   		    const_BalanceSTM_startupDelay,
								   		    const_BalanceSTM_speedUpdate,
								   		    const_BalanceSTM_rotationUpdate,
								   		    const_BalanceSTM_angleBudget,
								   		    const_BalanceSTM_speedBudget,
								   		    const_BalanceSTM_rotationBudget,
								   		    const_BalanceSTM_motorBudget,
								   		    const_AnglePID_P,
								   		    const_AnglePID_D,
								   		    const_SpeedPID_P,
								   		    const_SpeedPID_I,
								   		    const_SpeedPID_maxIntegral,
								   		    const_RotationPID_D)
								   [| { share__, terminate } |] (
								   j0::D__(id__,
								   		    const_BalanceSTM_maxAngle,
								   		    const_BalanceSTM_loopTime,
								   		    const_BalanceSTM_startupDelay,
								   		    const_BalanceSTM_speedUpdate,
								   		    const_BalanceSTM_rotationUpdate,
								   		    const_BalanceSTM_angleBudget,
								   		    const_BalanceSTM_speedBudget,
								   		    const_BalanceSTM_rotationBudget,
								   		    const_BalanceSTM_motorBudget,
								   		    const_AnglePID_P,
								   		    const_AnglePID_D,
								   		    const_SpeedPID_P,
								   		    const_SpeedPID_I,
								   		    const_SpeedPID_maxIntegral,
								   		    const_RotationPID_D)
								   [| { share__, terminate } |] (
								   j1::D__(id__,
								   		    const_BalanceSTM_maxAngle,
								   		    const_BalanceSTM_loopTime,
								   		    const_BalanceSTM_startupDelay,
								   		    const_BalanceSTM_speedUpdate,
								   		    const_BalanceSTM_rotationUpdate,
								   		    const_BalanceSTM_angleBudget,
								   		    const_BalanceSTM_speedBudget,
								   		    const_BalanceSTM_rotationBudget,
								   		    const_BalanceSTM_motorBudget,
								   		    const_AnglePID_P,
								   		    const_AnglePID_D,
								   		    const_SpeedPID_P,
								   		    const_SpeedPID_I,
								   		    const_SpeedPID_maxIntegral,
								   		    const_RotationPID_D)
								   [| { share__, terminate } |] (
								   j2::D__(id__,
								   		    const_BalanceSTM_maxAngle,
								   		    const_BalanceSTM_loopTime,
								   		    const_BalanceSTM_startupDelay,
								   		    const_BalanceSTM_speedUpdate,
								   		    const_BalanceSTM_rotationUpdate,
								   		    const_BalanceSTM_angleBudget,
								   		    const_BalanceSTM_speedBudget,
								   		    const_BalanceSTM_rotationBudget,
								   		    const_BalanceSTM_motorBudget,
								   		    const_AnglePID_P,
								   		    const_AnglePID_D,
								   		    const_SpeedPID_P,
								   		    const_SpeedPID_I,
								   		    const_SpeedPID_maxIntegral,
								   		    const_RotationPID_D)
								   [| { share__, terminate } |] (
								   StopMotors::D__(id__,
								   		    const_BalanceSTM_maxAngle,
								   		    const_BalanceSTM_loopTime,
								   		    const_BalanceSTM_startupDelay,
								   		    const_BalanceSTM_speedUpdate,
								   		    const_BalanceSTM_rotationUpdate,
								   		    const_BalanceSTM_angleBudget,
								   		    const_BalanceSTM_speedBudget,
								   		    const_BalanceSTM_rotationBudget,
								   		    const_BalanceSTM_motorBudget,
								   		    const_AnglePID_P,
								   		    const_AnglePID_D,
								   		    const_SpeedPID_P,
								   		    const_SpeedPID_I,
								   		    const_SpeedPID_maxIntegral,
								   		    const_RotationPID_D)
								   [| { share__, terminate } |] (
								   WaitForNextIteration::D__(id__,
								   		    const_BalanceSTM_maxAngle,
								   		    const_BalanceSTM_loopTime,
								   		    const_BalanceSTM_startupDelay,
								   		    const_BalanceSTM_speedUpdate,
								   		    const_BalanceSTM_rotationUpdate,
								   		    const_BalanceSTM_angleBudget,
								   		    const_BalanceSTM_speedBudget,
								   		    const_BalanceSTM_rotationBudget,
								   		    const_BalanceSTM_motorBudget,
								   		    const_AnglePID_P,
								   		    const_AnglePID_D,
								   		    const_SpeedPID_P,
								   		    const_SpeedPID_I,
								   		    const_SpeedPID_maxIntegral,
								   		    const_RotationPID_D)
								   [| { share__, terminate } |] (
								   Initialisation::D__(id__,
								   		    const_BalanceSTM_maxAngle,
								   		    const_BalanceSTM_loopTime,
								   		    const_BalanceSTM_startupDelay,
								   		    const_BalanceSTM_speedUpdate,
								   		    const_BalanceSTM_rotationUpdate,
								   		    const_BalanceSTM_angleBudget,
								   		    const_BalanceSTM_speedBudget,
								   		    const_BalanceSTM_rotationBudget,
								   		    const_BalanceSTM_motorBudget,
								   		    const_AnglePID_P,
								   		    const_AnglePID_D,
								   		    const_SpeedPID_P,
								   		    const_SpeedPID_I,
								   		    const_SpeedPID_maxIntegral,
								   		    const_RotationPID_D)
								   [| { share__, terminate } |] (
								   j3::D__(id__,
								   		    const_BalanceSTM_maxAngle,
								   		    const_BalanceSTM_loopTime,
								   		    const_BalanceSTM_startupDelay,
								   		    const_BalanceSTM_speedUpdate,
								   		    const_BalanceSTM_rotationUpdate,
								   		    const_BalanceSTM_angleBudget,
								   		    const_BalanceSTM_speedBudget,
								   		    const_BalanceSTM_rotationBudget,
								   		    const_BalanceSTM_motorBudget,
								   		    const_AnglePID_P,
								   		    const_AnglePID_D,
								   		    const_SpeedPID_P,
								   		    const_SpeedPID_I,
								   		    const_SpeedPID_maxIntegral,
								   		    const_RotationPID_D)
								   )
								   )
								   )
								   )
								   )
								   )
								   )
								   )
								   )
								   )
								   )
								 )
								 [[CalculateAngle::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_CalculateAngle|}]]
								 [[CalculateSpeed::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_CalculateSpeed|}]]
								 [[CalculateRotation::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_CalculateRotation|}]]
								 [[SetMotors::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_SetMotors|}]]
								 [[StopMotors::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_StopMotors|}]]
								 [[WaitForNextIteration::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_WaitForNextIteration|}]]
								 [[Initialisation::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_Initialisation|}]]
								 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
								 [[j0::interrupt <- x__ | x__ <- {|internal__.NID_j0,internal__.NID_j0|}]]
								 [[j1::interrupt <- x__ | x__ <- {|internal__.NID_j1|}]]
								 [[j2::interrupt <- x__ | x__ <- {|internal__.NID_j2,internal__.NID_j2|}]]
								 [[j3::interrupt <- x__ | x__ <- {|internal__.NID_j3,internal__.NID_j3|}]]
								 )
								  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
								  [[set_speedCount <- setL_speedCount,set_rotationCount <- setL_rotationCount,set_currAngle <- setL_currAngle]]
								 )
								 [| union(union(union(flowevts,transSync),{terminate}),{|share__
								 			,setL_speedCount
								 			,setL_rotationCount
								 			,setL_currAngle
								|}) |]
								 ((i0::enter -> Transitions(id__,
								 		    const_BalanceSTM_maxAngle,
								 		    const_BalanceSTM_loopTime,
								 		    const_BalanceSTM_startupDelay,
								 		    const_BalanceSTM_speedUpdate,
								 		    const_BalanceSTM_rotationUpdate,
								 		    const_BalanceSTM_angleBudget,
								 		    const_BalanceSTM_speedBudget,
								 		    const_BalanceSTM_rotationBudget,
								 		    const_BalanceSTM_motorBudget,
								 		    const_AnglePID_P,
								 		    const_AnglePID_D,
								 		    const_SpeedPID_P,
								 		    const_SpeedPID_I,
								 		    const_SpeedPID_maxIntegral,
								 		    const_RotationPID_D))
								  [[ share__ <- x__ | x__ <- {| share__,setL_speedCount,setL_rotationCount,setL_currAngle |} ]]
								 )
								)[[setL_speedCount <- set_speedCount,setL_rotationCount <- set_rotationCount,setL_currAngle <- set_currAngle]]
								)
							)
							 \ hideSet)
							[[
								leftMotorVelocity__.x____ <- leftMotorVelocity,
								rightMotorVelocity__.x____ <- rightMotorVelocity,
								angle__.x____ <- angle,
								gyroX__.x____ <- gyroX,
								gyroY__.x____ <- gyroY,
								gyroZ__.x____ <- gyroZ
								| x____ <- NIDS
							]]
						)
						 [| {| interrupt |} |] SKIP)
					)
					)
				
				Behaviour(id__,
						    const_BalanceSTM_maxAngle,
						    const_BalanceSTM_loopTime,
						    const_BalanceSTM_startupDelay,
						    const_BalanceSTM_speedUpdate,
						    const_BalanceSTM_rotationUpdate,
						    const_BalanceSTM_angleBudget,
						    const_BalanceSTM_speedBudget,
						    const_BalanceSTM_rotationBudget,
						    const_BalanceSTM_motorBudget,
						    const_AnglePID_P,
						    const_AnglePID_D,
						    const_SpeedPID_P,
						    const_SpeedPID_I,
						    const_SpeedPID_maxIntegral,
						    const_RotationPID_D) = 
					dbisim((MachineBody(id__,
							    const_BalanceSTM_maxAngle,
							    const_BalanceSTM_loopTime,
							    const_BalanceSTM_startupDelay,
							    const_BalanceSTM_speedUpdate,
							    const_BalanceSTM_rotationUpdate,
							    const_BalanceSTM_angleBudget,
							    const_BalanceSTM_speedBudget,
							    const_BalanceSTM_rotationBudget,
							    const_BalanceSTM_motorBudget,
							    const_AnglePID_P,
							    const_AnglePID_D,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral,
							    const_RotationPID_D)\ enteredSS)
					)
				
				IteratedBehaviour(id__,
						    const_BalanceSTM_maxAngle,
						    const_BalanceSTM_loopTime,
						    const_BalanceSTM_startupDelay,
						    const_BalanceSTM_speedUpdate,
						    const_BalanceSTM_rotationUpdate,
						    const_BalanceSTM_angleBudget,
						    const_BalanceSTM_speedBudget,
						    const_BalanceSTM_rotationBudget,
						    const_BalanceSTM_motorBudget,
						    const_AnglePID_P,
						    const_AnglePID_D,
						    const_SpeedPID_P,
						    const_SpeedPID_I,
						    const_SpeedPID_maxIntegral,
						    const_RotationPID_D) = 
					dbisim((MachineBody(id__,
							    const_BalanceSTM_maxAngle,
							    const_BalanceSTM_loopTime,
							    const_BalanceSTM_startupDelay,
							    const_BalanceSTM_speedUpdate,
							    const_BalanceSTM_rotationUpdate,
							    const_BalanceSTM_angleBudget,
							    const_BalanceSTM_speedBudget,
							    const_BalanceSTM_rotationBudget,
							    const_BalanceSTM_motorBudget,
							    const_AnglePID_P,
							    const_AnglePID_D,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral,
							    const_RotationPID_D)\ enteredSS)
					)
				
				Stateful(id__,
						    const_BalanceSTM_maxAngle,
						    const_BalanceSTM_loopTime,
						    const_BalanceSTM_startupDelay,
						    const_BalanceSTM_speedUpdate,
						    const_BalanceSTM_rotationUpdate,
						    const_BalanceSTM_angleBudget,
						    const_BalanceSTM_speedBudget,
						    const_BalanceSTM_rotationBudget,
						    const_BalanceSTM_motorBudget,
						    const_AnglePID_P,
						    const_AnglePID_D,
						    const_SpeedPID_P,
						    const_SpeedPID_I,
						    const_SpeedPID_maxIntegral,
						    const_RotationPID_D) = 
					((
						(Behaviour(id__,
								    const_BalanceSTM_maxAngle,
								    const_BalanceSTM_loopTime,
								    const_BalanceSTM_startupDelay,
								    const_BalanceSTM_speedUpdate,
								    const_BalanceSTM_rotationUpdate,
								    const_BalanceSTM_angleBudget,
								    const_BalanceSTM_speedBudget,
								    const_BalanceSTM_rotationBudget,
								    const_BalanceSTM_motorBudget,
								    const_AnglePID_P,
								    const_AnglePID_D,
								    const_SpeedPID_P,
								    const_SpeedPID_I,
								    const_SpeedPID_maxIntegral,
								    const_RotationPID_D) [| union(getsetLocalChannels,{terminate}) |] varMemory(id__,
								    const_BalanceSTM_maxAngle,
								    const_BalanceSTM_loopTime,
								    const_BalanceSTM_startupDelay,
								    const_BalanceSTM_speedUpdate,
								    const_BalanceSTM_rotationUpdate,
								    const_BalanceSTM_angleBudget,
								    const_BalanceSTM_speedBudget,
								    const_BalanceSTM_rotationBudget,
								    const_BalanceSTM_motorBudget,
								    const_AnglePID_P,
								    const_AnglePID_D,
								    const_SpeedPID_P,
								    const_SpeedPID_I,
								    const_SpeedPID_maxIntegral,
								    const_RotationPID_D))
					 	\getsetLocalChannels
					)
					)
				
				IteratedStateful(id__,
						    const_BalanceSTM_maxAngle,
						    const_BalanceSTM_loopTime,
						    const_BalanceSTM_startupDelay,
						    const_BalanceSTM_speedUpdate,
						    const_BalanceSTM_rotationUpdate,
						    const_BalanceSTM_angleBudget,
						    const_BalanceSTM_speedBudget,
						    const_BalanceSTM_rotationBudget,
						    const_BalanceSTM_motorBudget,
						    const_AnglePID_P,
						    const_AnglePID_D,
						    const_SpeedPID_P,
						    const_SpeedPID_I,
						    const_SpeedPID_maxIntegral,
						    const_RotationPID_D) =
					(dbisim(
						sbisim(
							dbisim(
								sbisim(
									dbisim(
										sbisim(
											dbisim(
												sbisim(
													dbisim(
														sbisim(
															dbisim(
																sbisim(
																	dbisim(
																		sbisim(
																			dbisim(
																				sbisim(
																					dbisim(
																						sbisim(
																							dbisim(
																								sbisim(
																									dbisim(
																										sbisim(
																											dbisim(
																												sbisim(
																													Behaviour(id__,
																															    const_BalanceSTM_maxAngle,
																															    const_BalanceSTM_loopTime,
																															    const_BalanceSTM_startupDelay,
																															    const_BalanceSTM_speedUpdate,
																															    const_BalanceSTM_rotationUpdate,
																															    const_BalanceSTM_angleBudget,
																															    const_BalanceSTM_speedBudget,
																															    const_BalanceSTM_rotationBudget,
																															    const_BalanceSTM_motorBudget,
																															    const_AnglePID_P,
																															    const_AnglePID_D,
																															    const_SpeedPID_P,
																															    const_SpeedPID_I,
																															    const_SpeedPID_maxIntegral,
																															    const_RotationPID_D)
																													[| {|get_rotationOutput,set_rotationOutput,terminate|} |]
																													Memory_rotationOutput(0)
																												)\{|get_rotationOutput,set_rotationOutput|}
																											)
																											[| {|get_speedOutput,set_speedOutput,terminate|} |]
																											Memory_speedOutput(0)
																										)\{|get_speedOutput,set_speedOutput|}
																									)
																									[| {|get_speedIntegral,set_speedIntegral,terminate|} |]
																									Memory_speedIntegral(0)
																								)\{|get_speedIntegral,set_speedIntegral|}
																							)
																							[| {|get_angleOutput,set_angleOutput,terminate|} |]
																							Memory_angleOutput(0)
																						)\{|get_angleOutput,set_angleOutput|}
																					)
																					[| {|get_rotationCount,set_rotationCount,terminate|} |]
																					Memory_rotationCount(0)
																				)\{|get_rotationCount,set_rotationCount|}
																			)
																			[| {|get_speedCount,set_speedCount,terminate|} |]
																			Memory_speedCount(0)
																		)\{|get_speedCount,set_speedCount|}
																	)
																	[| {|get_currRightVel,set_currRightVel,terminate|} |]
																	Memory_currRightVel(0)
																)\{|get_currRightVel,set_currRightVel|}
															)
															[| {|get_currLeftVel,set_currLeftVel,terminate|} |]
															Memory_currLeftVel(0)
														)\{|get_currLeftVel,set_currLeftVel|}
													)
													[| {|get_currGyroZ,set_currGyroZ,terminate|} |]
													Memory_currGyroZ(0)
												)\{|get_currGyroZ,set_currGyroZ|}
											)
											[| {|get_currGyroY,set_currGyroY,terminate|} |]
											Memory_currGyroY(0)
										)\{|get_currGyroY,set_currGyroY|}
									)
									[| {|get_currGyroX,set_currGyroX,terminate|} |]
									Memory_currGyroX(0)
								)\{|get_currGyroX,set_currGyroX|}
							)
							[| {|get_currAngle,set_currAngle,terminate|} |]
							Memory_currAngle(0)
						)\{|get_currAngle,set_currAngle|}
					)
					)
				
				-- Visible counterparts
				MachineBody_VS_O(id__,
						    const_BalanceSTM_maxAngle,
						    const_BalanceSTM_loopTime,
						    const_BalanceSTM_startupDelay,
						    const_BalanceSTM_speedUpdate,
						    const_BalanceSTM_rotationUpdate,
						    const_BalanceSTM_angleBudget,
						    const_BalanceSTM_speedBudget,
						    const_BalanceSTM_rotationBudget,
						    const_BalanceSTM_motorBudget,
						    const_AnglePID_P,
						    const_AnglePID_D,
						    const_SpeedPID_P,
						    const_SpeedPID_I,
						    const_SpeedPID_maxIntegral,
						    const_RotationPID_D) = 
					dbisim((
					let
						finalNodesEntered = {||}
					within
						((let
							-- IMPLEMENTATION NOTE:
							-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
							-- modules for defining the semantics of each node.
							enterSS = {|
							i0::enter,
							CalculateAngle::enter,
							CalculateSpeed::enter,
							CalculateRotation::enter,
							SetMotors::enter,
							j0::enter,
							j1::enter,
							j2::enter,
							StopMotors::enter,
							WaitForNextIteration::enter,
							Initialisation::enter,
							j3::enter
							|}
							hideSet = union(enterSS,{|exit,exited,internal__|})
						within 
							((let
								-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
								-- because CSPM modules are used for the semantics of Node.
								flowevts = union(enterSS,{|exit,exited,interrupt|})
								transSync = {|internal__.NID_j0,internal__.NID_CalculateSpeed,internal__.NID_CalculateAngle,internal__.NID_j0,internal__.NID_CalculateRotation,internal__.NID_j2,internal__.NID_j2,internal__.NID_WaitForNextIteration,internal__.NID_StopMotors,internal__.NID_SetMotors,internal__.NID_i0,internal__.NID_Initialisation,internal__.NID_j1,internal__.NID_j3,internal__.NID_j3|}
							within
								((
								 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
								   i0::VS_O__(id__,
								   		    const_BalanceSTM_maxAngle,
								   		    const_BalanceSTM_loopTime,
								   		    const_BalanceSTM_startupDelay,
								   		    const_BalanceSTM_speedUpdate,
								   		    const_BalanceSTM_rotationUpdate,
								   		    const_BalanceSTM_angleBudget,
								   		    const_BalanceSTM_speedBudget,
								   		    const_BalanceSTM_rotationBudget,
								   		    const_BalanceSTM_motorBudget,
								   		    const_AnglePID_P,
								   		    const_AnglePID_D,
								   		    const_SpeedPID_P,
								   		    const_SpeedPID_I,
								   		    const_SpeedPID_maxIntegral,
								   		    const_RotationPID_D)
								   [| { share__, terminate } |] (
								   CalculateAngle::VS_O__(id__,
								   		    const_BalanceSTM_maxAngle,
								   		    const_BalanceSTM_loopTime,
								   		    const_BalanceSTM_startupDelay,
								   		    const_BalanceSTM_speedUpdate,
								   		    const_BalanceSTM_rotationUpdate,
								   		    const_BalanceSTM_angleBudget,
								   		    const_BalanceSTM_speedBudget,
								   		    const_BalanceSTM_rotationBudget,
								   		    const_BalanceSTM_motorBudget,
								   		    const_AnglePID_P,
								   		    const_AnglePID_D,
								   		    const_SpeedPID_P,
								   		    const_SpeedPID_I,
								   		    const_SpeedPID_maxIntegral,
								   		    const_RotationPID_D)
								   [| { share__, terminate } |] (
								   CalculateSpeed::VS_O__(id__,
								   		    const_BalanceSTM_maxAngle,
								   		    const_BalanceSTM_loopTime,
								   		    const_BalanceSTM_startupDelay,
								   		    const_BalanceSTM_speedUpdate,
								   		    const_BalanceSTM_rotationUpdate,
								   		    const_BalanceSTM_angleBudget,
								   		    const_BalanceSTM_speedBudget,
								   		    const_BalanceSTM_rotationBudget,
								   		    const_BalanceSTM_motorBudget,
								   		    const_AnglePID_P,
								   		    const_AnglePID_D,
								   		    const_SpeedPID_P,
								   		    const_SpeedPID_I,
								   		    const_SpeedPID_maxIntegral,
								   		    const_RotationPID_D)
								   [| { share__, terminate } |] (
								   CalculateRotation::VS_O__(id__,
								   		    const_BalanceSTM_maxAngle,
								   		    const_BalanceSTM_loopTime,
								   		    const_BalanceSTM_startupDelay,
								   		    const_BalanceSTM_speedUpdate,
								   		    const_BalanceSTM_rotationUpdate,
								   		    const_BalanceSTM_angleBudget,
								   		    const_BalanceSTM_speedBudget,
								   		    const_BalanceSTM_rotationBudget,
								   		    const_BalanceSTM_motorBudget,
								   		    const_AnglePID_P,
								   		    const_AnglePID_D,
								   		    const_SpeedPID_P,
								   		    const_SpeedPID_I,
								   		    const_SpeedPID_maxIntegral,
								   		    const_RotationPID_D)
								   [| { share__, terminate } |] (
								   SetMotors::VS_O__(id__,
								   		    const_BalanceSTM_maxAngle,
								   		    const_BalanceSTM_loopTime,
								   		    const_BalanceSTM_startupDelay,
								   		    const_BalanceSTM_speedUpdate,
								   		    const_BalanceSTM_rotationUpdate,
								   		    const_BalanceSTM_angleBudget,
								   		    const_BalanceSTM_speedBudget,
								   		    const_BalanceSTM_rotationBudget,
								   		    const_BalanceSTM_motorBudget,
								   		    const_AnglePID_P,
								   		    const_AnglePID_D,
								   		    const_SpeedPID_P,
								   		    const_SpeedPID_I,
								   		    const_SpeedPID_maxIntegral,
								   		    const_RotationPID_D)
								   [| { share__, terminate } |] (
								   j0::VS_O__(id__,
								   		    const_BalanceSTM_maxAngle,
								   		    const_BalanceSTM_loopTime,
								   		    const_BalanceSTM_startupDelay,
								   		    const_BalanceSTM_speedUpdate,
								   		    const_BalanceSTM_rotationUpdate,
								   		    const_BalanceSTM_angleBudget,
								   		    const_BalanceSTM_speedBudget,
								   		    const_BalanceSTM_rotationBudget,
								   		    const_BalanceSTM_motorBudget,
								   		    const_AnglePID_P,
								   		    const_AnglePID_D,
								   		    const_SpeedPID_P,
								   		    const_SpeedPID_I,
								   		    const_SpeedPID_maxIntegral,
								   		    const_RotationPID_D)
								   [| { share__, terminate } |] (
								   j1::VS_O__(id__,
								   		    const_BalanceSTM_maxAngle,
								   		    const_BalanceSTM_loopTime,
								   		    const_BalanceSTM_startupDelay,
								   		    const_BalanceSTM_speedUpdate,
								   		    const_BalanceSTM_rotationUpdate,
								   		    const_BalanceSTM_angleBudget,
								   		    const_BalanceSTM_speedBudget,
								   		    const_BalanceSTM_rotationBudget,
								   		    const_BalanceSTM_motorBudget,
								   		    const_AnglePID_P,
								   		    const_AnglePID_D,
								   		    const_SpeedPID_P,
								   		    const_SpeedPID_I,
								   		    const_SpeedPID_maxIntegral,
								   		    const_RotationPID_D)
								   [| { share__, terminate } |] (
								   j2::VS_O__(id__,
								   		    const_BalanceSTM_maxAngle,
								   		    const_BalanceSTM_loopTime,
								   		    const_BalanceSTM_startupDelay,
								   		    const_BalanceSTM_speedUpdate,
								   		    const_BalanceSTM_rotationUpdate,
								   		    const_BalanceSTM_angleBudget,
								   		    const_BalanceSTM_speedBudget,
								   		    const_BalanceSTM_rotationBudget,
								   		    const_BalanceSTM_motorBudget,
								   		    const_AnglePID_P,
								   		    const_AnglePID_D,
								   		    const_SpeedPID_P,
								   		    const_SpeedPID_I,
								   		    const_SpeedPID_maxIntegral,
								   		    const_RotationPID_D)
								   [| { share__, terminate } |] (
								   StopMotors::VS_O__(id__,
								   		    const_BalanceSTM_maxAngle,
								   		    const_BalanceSTM_loopTime,
								   		    const_BalanceSTM_startupDelay,
								   		    const_BalanceSTM_speedUpdate,
								   		    const_BalanceSTM_rotationUpdate,
								   		    const_BalanceSTM_angleBudget,
								   		    const_BalanceSTM_speedBudget,
								   		    const_BalanceSTM_rotationBudget,
								   		    const_BalanceSTM_motorBudget,
								   		    const_AnglePID_P,
								   		    const_AnglePID_D,
								   		    const_SpeedPID_P,
								   		    const_SpeedPID_I,
								   		    const_SpeedPID_maxIntegral,
								   		    const_RotationPID_D)
								   [| { share__, terminate } |] (
								   WaitForNextIteration::VS_O__(id__,
								   		    const_BalanceSTM_maxAngle,
								   		    const_BalanceSTM_loopTime,
								   		    const_BalanceSTM_startupDelay,
								   		    const_BalanceSTM_speedUpdate,
								   		    const_BalanceSTM_rotationUpdate,
								   		    const_BalanceSTM_angleBudget,
								   		    const_BalanceSTM_speedBudget,
								   		    const_BalanceSTM_rotationBudget,
								   		    const_BalanceSTM_motorBudget,
								   		    const_AnglePID_P,
								   		    const_AnglePID_D,
								   		    const_SpeedPID_P,
								   		    const_SpeedPID_I,
								   		    const_SpeedPID_maxIntegral,
								   		    const_RotationPID_D)
								   [| { share__, terminate } |] (
								   Initialisation::VS_O__(id__,
								   		    const_BalanceSTM_maxAngle,
								   		    const_BalanceSTM_loopTime,
								   		    const_BalanceSTM_startupDelay,
								   		    const_BalanceSTM_speedUpdate,
								   		    const_BalanceSTM_rotationUpdate,
								   		    const_BalanceSTM_angleBudget,
								   		    const_BalanceSTM_speedBudget,
								   		    const_BalanceSTM_rotationBudget,
								   		    const_BalanceSTM_motorBudget,
								   		    const_AnglePID_P,
								   		    const_AnglePID_D,
								   		    const_SpeedPID_P,
								   		    const_SpeedPID_I,
								   		    const_SpeedPID_maxIntegral,
								   		    const_RotationPID_D)
								   [| { share__, terminate } |] (
								   j3::VS_O__(id__,
								   		    const_BalanceSTM_maxAngle,
								   		    const_BalanceSTM_loopTime,
								   		    const_BalanceSTM_startupDelay,
								   		    const_BalanceSTM_speedUpdate,
								   		    const_BalanceSTM_rotationUpdate,
								   		    const_BalanceSTM_angleBudget,
								   		    const_BalanceSTM_speedBudget,
								   		    const_BalanceSTM_rotationBudget,
								   		    const_BalanceSTM_motorBudget,
								   		    const_AnglePID_P,
								   		    const_AnglePID_D,
								   		    const_SpeedPID_P,
								   		    const_SpeedPID_I,
								   		    const_SpeedPID_maxIntegral,
								   		    const_RotationPID_D)
								   )
								   )
								   )
								   )
								   )
								   )
								   )
								   )
								   )
								   )
								   )
								 )
								 [[CalculateAngle::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_CalculateAngle|}]]
								 [[CalculateSpeed::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_CalculateSpeed|}]]
								 [[CalculateRotation::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_CalculateRotation|}]]
								 [[SetMotors::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_SetMotors|}]]
								 [[StopMotors::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_StopMotors|}]]
								 [[WaitForNextIteration::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_WaitForNextIteration|}]]
								 [[Initialisation::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_Initialisation|}]]
								 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
								 [[j0::interrupt <- x__ | x__ <- {|internal__.NID_j0,internal__.NID_j0|}]]
								 [[j1::interrupt <- x__ | x__ <- {|internal__.NID_j1|}]]
								 [[j2::interrupt <- x__ | x__ <- {|internal__.NID_j2,internal__.NID_j2|}]]
								 [[j3::interrupt <- x__ | x__ <- {|internal__.NID_j3,internal__.NID_j3|}]]
								 )
								  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
								  [[set_speedCount <- setL_speedCount,set_rotationCount <- setL_rotationCount,set_currAngle <- setL_currAngle]]
								 )
								 [| union(union(union(flowevts,transSync),{terminate}),{|share__
								 			,setL_speedCount
								 			,setL_rotationCount
								 			,setL_currAngle
								|}) |]
								 ((i0::enter -> Transitions(id__,
								 		    const_BalanceSTM_maxAngle,
								 		    const_BalanceSTM_loopTime,
								 		    const_BalanceSTM_startupDelay,
								 		    const_BalanceSTM_speedUpdate,
								 		    const_BalanceSTM_rotationUpdate,
								 		    const_BalanceSTM_angleBudget,
								 		    const_BalanceSTM_speedBudget,
								 		    const_BalanceSTM_rotationBudget,
								 		    const_BalanceSTM_motorBudget,
								 		    const_AnglePID_P,
								 		    const_AnglePID_D,
								 		    const_SpeedPID_P,
								 		    const_SpeedPID_I,
								 		    const_SpeedPID_maxIntegral,
								 		    const_RotationPID_D))
								  [[ share__ <- x__ | x__ <- {| share__,setL_speedCount,setL_rotationCount,setL_currAngle |} ]]
								 )
								)[[setL_speedCount <- set_speedCount,setL_rotationCount <- set_rotationCount,setL_currAngle <- set_currAngle]]
								)
							)
							 \ hideSet)
							[[
								leftMotorVelocity__.x____ <- leftMotorVelocity,
								rightMotorVelocity__.x____ <- rightMotorVelocity,
								angle__.x____ <- angle,
								gyroX__.x____ <- gyroX,
								gyroY__.x____ <- gyroY,
								gyroZ__.x____ <- gyroZ
								| x____ <- NIDS
							]]
						)
						 [| {| interrupt |} |] SKIP)
					)
					)
				
				Behaviour_VS_O(id__,
						    const_BalanceSTM_maxAngle,
						    const_BalanceSTM_loopTime,
						    const_BalanceSTM_startupDelay,
						    const_BalanceSTM_speedUpdate,
						    const_BalanceSTM_rotationUpdate,
						    const_BalanceSTM_angleBudget,
						    const_BalanceSTM_speedBudget,
						    const_BalanceSTM_rotationBudget,
						    const_BalanceSTM_motorBudget,
						    const_AnglePID_P,
						    const_AnglePID_D,
						    const_SpeedPID_P,
						    const_SpeedPID_I,
						    const_SpeedPID_maxIntegral,
						    const_RotationPID_D) = 
					dbisim((MachineBody_VS_O(id__,
							    const_BalanceSTM_maxAngle,
							    const_BalanceSTM_loopTime,
							    const_BalanceSTM_startupDelay,
							    const_BalanceSTM_speedUpdate,
							    const_BalanceSTM_rotationUpdate,
							    const_BalanceSTM_angleBudget,
							    const_BalanceSTM_speedBudget,
							    const_BalanceSTM_rotationBudget,
							    const_BalanceSTM_motorBudget,
							    const_AnglePID_P,
							    const_AnglePID_D,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral,
							    const_RotationPID_D))
					)
				
				IteratedBehaviour_VS_O(id__,
						    const_BalanceSTM_maxAngle,
						    const_BalanceSTM_loopTime,
						    const_BalanceSTM_startupDelay,
						    const_BalanceSTM_speedUpdate,
						    const_BalanceSTM_rotationUpdate,
						    const_BalanceSTM_angleBudget,
						    const_BalanceSTM_speedBudget,
						    const_BalanceSTM_rotationBudget,
						    const_BalanceSTM_motorBudget,
						    const_AnglePID_P,
						    const_AnglePID_D,
						    const_SpeedPID_P,
						    const_SpeedPID_I,
						    const_SpeedPID_maxIntegral,
						    const_RotationPID_D) = 
					dbisim((MachineBody_VS_O(id__,
							    const_BalanceSTM_maxAngle,
							    const_BalanceSTM_loopTime,
							    const_BalanceSTM_startupDelay,
							    const_BalanceSTM_speedUpdate,
							    const_BalanceSTM_rotationUpdate,
							    const_BalanceSTM_angleBudget,
							    const_BalanceSTM_speedBudget,
							    const_BalanceSTM_rotationBudget,
							    const_BalanceSTM_motorBudget,
							    const_AnglePID_P,
							    const_AnglePID_D,
							    const_SpeedPID_P,
							    const_SpeedPID_I,
							    const_SpeedPID_maxIntegral,
							    const_RotationPID_D))
					)
				
				Stateful_VS_O(id__,
						    const_BalanceSTM_maxAngle,
						    const_BalanceSTM_loopTime,
						    const_BalanceSTM_startupDelay,
						    const_BalanceSTM_speedUpdate,
						    const_BalanceSTM_rotationUpdate,
						    const_BalanceSTM_angleBudget,
						    const_BalanceSTM_speedBudget,
						    const_BalanceSTM_rotationBudget,
						    const_BalanceSTM_motorBudget,
						    const_AnglePID_P,
						    const_AnglePID_D,
						    const_SpeedPID_P,
						    const_SpeedPID_I,
						    const_SpeedPID_maxIntegral,
						    const_RotationPID_D) = 
					dbisim((
						(Behaviour_VS_O(id__,
								    const_BalanceSTM_maxAngle,
								    const_BalanceSTM_loopTime,
								    const_BalanceSTM_startupDelay,
								    const_BalanceSTM_speedUpdate,
								    const_BalanceSTM_rotationUpdate,
								    const_BalanceSTM_angleBudget,
								    const_BalanceSTM_speedBudget,
								    const_BalanceSTM_rotationBudget,
								    const_BalanceSTM_motorBudget,
								    const_AnglePID_P,
								    const_AnglePID_D,
								    const_SpeedPID_P,
								    const_SpeedPID_I,
								    const_SpeedPID_maxIntegral,
								    const_RotationPID_D) [| union(getsetLocalChannels,{terminate}) |] varMemory(id__,
								    const_BalanceSTM_maxAngle,
								    const_BalanceSTM_loopTime,
								    const_BalanceSTM_startupDelay,
								    const_BalanceSTM_speedUpdate,
								    const_BalanceSTM_rotationUpdate,
								    const_BalanceSTM_angleBudget,
								    const_BalanceSTM_speedBudget,
								    const_BalanceSTM_rotationBudget,
								    const_BalanceSTM_motorBudget,
								    const_AnglePID_P,
								    const_AnglePID_D,
								    const_SpeedPID_P,
								    const_SpeedPID_I,
								    const_SpeedPID_maxIntegral,
								    const_RotationPID_D))
					 	\getsetLocalChannels
					)
					)
				
				IteratedStateful_VS_O(id__,
						    const_BalanceSTM_maxAngle,
						    const_BalanceSTM_loopTime,
						    const_BalanceSTM_startupDelay,
						    const_BalanceSTM_speedUpdate,
						    const_BalanceSTM_rotationUpdate,
						    const_BalanceSTM_angleBudget,
						    const_BalanceSTM_speedBudget,
						    const_BalanceSTM_rotationBudget,
						    const_BalanceSTM_motorBudget,
						    const_AnglePID_P,
						    const_AnglePID_D,
						    const_SpeedPID_P,
						    const_SpeedPID_I,
						    const_SpeedPID_maxIntegral,
						    const_RotationPID_D) =
					(dbisim(
						sbisim(
							dbisim(
								sbisim(
									dbisim(
										sbisim(
											dbisim(
												sbisim(
													dbisim(
														sbisim(
															dbisim(
																sbisim(
																	dbisim(
																		sbisim(
																			dbisim(
																				sbisim(
																					dbisim(
																						sbisim(
																							dbisim(
																								sbisim(
																									dbisim(
																										sbisim(
																											dbisim(
																												sbisim(
																													Behaviour_VS_O(id__,
																															    const_BalanceSTM_maxAngle,
																															    const_BalanceSTM_loopTime,
																															    const_BalanceSTM_startupDelay,
																															    const_BalanceSTM_speedUpdate,
																															    const_BalanceSTM_rotationUpdate,
																															    const_BalanceSTM_angleBudget,
																															    const_BalanceSTM_speedBudget,
																															    const_BalanceSTM_rotationBudget,
																															    const_BalanceSTM_motorBudget,
																															    const_AnglePID_P,
																															    const_AnglePID_D,
																															    const_SpeedPID_P,
																															    const_SpeedPID_I,
																															    const_SpeedPID_maxIntegral,
																															    const_RotationPID_D)
																													[| {|get_rotationOutput,set_rotationOutput,terminate|} |]
																													Memory_rotationOutput(0)
																												)\{|get_rotationOutput,set_rotationOutput|}
																											)
																											[| {|get_speedOutput,set_speedOutput,terminate|} |]
																											Memory_speedOutput(0)
																										)\{|get_speedOutput,set_speedOutput|}
																									)
																									[| {|get_speedIntegral,set_speedIntegral,terminate|} |]
																									Memory_speedIntegral(0)
																								)\{|get_speedIntegral,set_speedIntegral|}
																							)
																							[| {|get_angleOutput,set_angleOutput,terminate|} |]
																							Memory_angleOutput(0)
																						)\{|get_angleOutput,set_angleOutput|}
																					)
																					[| {|get_rotationCount,set_rotationCount,terminate|} |]
																					Memory_rotationCount(0)
																				)\{|get_rotationCount,set_rotationCount|}
																			)
																			[| {|get_speedCount,set_speedCount,terminate|} |]
																			Memory_speedCount(0)
																		)\{|get_speedCount,set_speedCount|}
																	)
																	[| {|get_currRightVel,set_currRightVel,terminate|} |]
																	Memory_currRightVel(0)
																)\{|get_currRightVel,set_currRightVel|}
															)
															[| {|get_currLeftVel,set_currLeftVel,terminate|} |]
															Memory_currLeftVel(0)
														)\{|get_currLeftVel,set_currLeftVel|}
													)
													[| {|get_currGyroZ,set_currGyroZ,terminate|} |]
													Memory_currGyroZ(0)
												)\{|get_currGyroZ,set_currGyroZ|}
											)
											[| {|get_currGyroY,set_currGyroY,terminate|} |]
											Memory_currGyroY(0)
										)\{|get_currGyroY,set_currGyroY|}
									)
									[| {|get_currGyroX,set_currGyroX,terminate|} |]
									Memory_currGyroX(0)
								)\{|get_currGyroX,set_currGyroX|}
							)
							[| {|get_currAngle,set_currAngle,terminate|} |]
							Memory_currAngle(0)
						)\{|get_currAngle,set_currAngle|}
					)
					)
				
				-- END
				
				-- Memory
				-- Memory variables
				Memory_currAngle(currAngle) =
					get_currAngle!currAngle -> Memory_currAngle(currAngle)
					[]
					set_currAngle?x__ -> Memory_currAngle(x__)
					[]
					terminate -> SKIP
				Memory_currGyroX(currGyroX) =
					get_currGyroX!currGyroX -> Memory_currGyroX(currGyroX)
					[]
					set_currGyroX?x__ -> Memory_currGyroX(x__)
					[]
					terminate -> SKIP
				Memory_currGyroY(currGyroY) =
					get_currGyroY!currGyroY -> Memory_currGyroY(currGyroY)
					[]
					set_currGyroY?x__ -> Memory_currGyroY(x__)
					[]
					terminate -> SKIP
				Memory_currGyroZ(currGyroZ) =
					get_currGyroZ!currGyroZ -> Memory_currGyroZ(currGyroZ)
					[]
					set_currGyroZ?x__ -> Memory_currGyroZ(x__)
					[]
					terminate -> SKIP
				Memory_currLeftVel(currLeftVel) =
					get_currLeftVel!currLeftVel -> Memory_currLeftVel(currLeftVel)
					[]
					set_currLeftVel?x__ -> Memory_currLeftVel(x__)
					[]
					terminate -> SKIP
				Memory_currRightVel(currRightVel) =
					get_currRightVel!currRightVel -> Memory_currRightVel(currRightVel)
					[]
					set_currRightVel?x__ -> Memory_currRightVel(x__)
					[]
					terminate -> SKIP
				Memory_speedCount(speedCount) =
					get_speedCount!speedCount -> Memory_speedCount(speedCount)
					[]
					set_speedCount?x__ -> Memory_speedCount(x__)
					[]
					terminate -> SKIP
				Memory_rotationCount(rotationCount) =
					get_rotationCount!rotationCount -> Memory_rotationCount(rotationCount)
					[]
					set_rotationCount?x__ -> Memory_rotationCount(x__)
					[]
					terminate -> SKIP
				Memory_angleOutput(angleOutput) =
					get_angleOutput!angleOutput -> Memory_angleOutput(angleOutput)
					[]
					set_angleOutput?x__ -> Memory_angleOutput(x__)
					[]
					terminate -> SKIP
				Memory_speedIntegral(speedIntegral) =
					get_speedIntegral!speedIntegral -> Memory_speedIntegral(speedIntegral)
					[]
					set_speedIntegral?x__ -> Memory_speedIntegral(x__)
					[]
					terminate -> SKIP
				Memory_speedOutput(speedOutput) =
					get_speedOutput!speedOutput -> Memory_speedOutput(speedOutput)
					[]
					set_speedOutput?x__ -> Memory_speedOutput(x__)
					[]
					terminate -> SKIP
				Memory_rotationOutput(rotationOutput) =
					get_rotationOutput!rotationOutput -> Memory_rotationOutput(rotationOutput)
					[]
					set_rotationOutput?x__ -> Memory_rotationOutput(x__)
					[]
					terminate -> SKIP
				
				-- varMemory process
				varMemory(id__,
						    const_BalanceSTM_maxAngle,
						    const_BalanceSTM_loopTime,
						    const_BalanceSTM_startupDelay,
						    const_BalanceSTM_speedUpdate,
						    const_BalanceSTM_rotationUpdate,
						    const_BalanceSTM_angleBudget,
						    const_BalanceSTM_speedBudget,
						    const_BalanceSTM_rotationBudget,
						    const_BalanceSTM_motorBudget,
						    const_AnglePID_P,
						    const_AnglePID_D,
						    const_SpeedPID_P,
						    const_SpeedPID_I,
						    const_SpeedPID_maxIntegral,
						    const_RotationPID_D) = Memory_currAngle(0)
				[| { terminate } |] (
				Memory_currGyroX(0)
				[| { terminate } |] (
				Memory_currGyroY(0)
				[| { terminate } |] (
				Memory_currGyroZ(0)
				[| { terminate } |] (
				Memory_currLeftVel(0)
				[| { terminate } |] (
				Memory_currRightVel(0)
				[| { terminate } |] (
				Memory_speedCount(0)
				[| { terminate } |] (
				Memory_rotationCount(0)
				[| { terminate } |] (
				Memory_angleOutput(0)
				[| { terminate } |] (
				Memory_speedIntegral(0)
				[| { terminate } |] (
				Memory_speedOutput(0)
				[| { terminate } |] (
				Memory_rotationOutput(0)
				)
				)
				)
				)
				)
				)
				)
				)
				)
				)
				)
				
				getsetLocalChannels = {|get_currAngle,set_currAngle,get_currGyroX,set_currGyroX,get_currGyroY,set_currGyroY,get_currGyroZ,set_currGyroZ,get_currLeftVel,set_currLeftVel,get_currRightVel,set_currRightVel,get_speedCount,set_speedCount,get_rotationCount,set_rotationCount,get_angleOutput,set_angleOutput,get_speedIntegral,set_speedIntegral,get_speedOutput,set_speedOutput,get_rotationOutput,set_rotationOutput|}
				
				-- Definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
				FVS__(id__,
						    const_BalanceSTM_maxAngle,
						    const_BalanceSTM_loopTime,
						    const_BalanceSTM_startupDelay,
						    const_BalanceSTM_speedUpdate,
						    const_BalanceSTM_rotationUpdate,
						    const_BalanceSTM_angleBudget,
						    const_BalanceSTM_speedBudget,
						    const_BalanceSTM_rotationBudget,
						    const_BalanceSTM_motorBudget,
						    const_AnglePID_P,
						    const_AnglePID_D,
						    const_SpeedPID_P,
						    const_SpeedPID_I,
						    const_SpeedPID_maxIntegral,
						    const_RotationPID_D) = STM_VS_O(id__,
						    const_BalanceSTM_maxAngle,
						    const_BalanceSTM_loopTime,
						    const_BalanceSTM_startupDelay,
						    const_BalanceSTM_speedUpdate,
						    const_BalanceSTM_rotationUpdate,
						    const_BalanceSTM_angleBudget,
						    const_BalanceSTM_speedBudget,
						    const_BalanceSTM_rotationBudget,
						    const_BalanceSTM_motorBudget,
						    const_AnglePID_P,
						    const_AnglePID_D,
						    const_SpeedPID_P,
						    const_SpeedPID_I,
						    const_SpeedPID_maxIntegral,
						    const_RotationPID_D)
				
				D__(id__,
						    const_BalanceSTM_maxAngle,
						    const_BalanceSTM_loopTime,
						    const_BalanceSTM_startupDelay,
						    const_BalanceSTM_speedUpdate,
						    const_BalanceSTM_rotationUpdate,
						    const_BalanceSTM_angleBudget,
						    const_BalanceSTM_speedBudget,
						    const_BalanceSTM_rotationBudget,
						    const_BalanceSTM_motorBudget,
						    const_AnglePID_P,
						    const_AnglePID_D,
						    const_SpeedPID_P,
						    const_SpeedPID_I,
						    const_SpeedPID_maxIntegral,
						    const_RotationPID_D) = STM(id__,
						    const_BalanceSTM_maxAngle,
						    const_BalanceSTM_loopTime,
						    const_BalanceSTM_startupDelay,
						    const_BalanceSTM_speedUpdate,
						    const_BalanceSTM_rotationUpdate,
						    const_BalanceSTM_angleBudget,
						    const_BalanceSTM_speedBudget,
						    const_BalanceSTM_rotationBudget,
						    const_BalanceSTM_motorBudget,
						    const_AnglePID_P,
						    const_AnglePID_D,
						    const_SpeedPID_P,
						    const_SpeedPID_I,
						    const_SpeedPID_maxIntegral,
						    const_RotationPID_D) \ internal_events
				O__(id__,
						    const_BalanceSTM_maxAngle,
						    const_BalanceSTM_loopTime,
						    const_BalanceSTM_startupDelay,
						    const_BalanceSTM_speedUpdate,
						    const_BalanceSTM_rotationUpdate,
						    const_BalanceSTM_angleBudget,
						    const_BalanceSTM_speedBudget,
						    const_BalanceSTM_rotationBudget,
						    const_BalanceSTM_motorBudget,
						    const_AnglePID_P,
						    const_AnglePID_D,
						    const_SpeedPID_P,
						    const_SpeedPID_I,
						    const_SpeedPID_maxIntegral,
						    const_RotationPID_D) = sbisim(diamond(D__(id__,
						    const_BalanceSTM_maxAngle,
						    const_BalanceSTM_loopTime,
						    const_BalanceSTM_startupDelay,
						    const_BalanceSTM_speedUpdate,
						    const_BalanceSTM_rotationUpdate,
						    const_BalanceSTM_angleBudget,
						    const_BalanceSTM_speedBudget,
						    const_BalanceSTM_rotationBudget,
						    const_BalanceSTM_motorBudget,
						    const_AnglePID_P,
						    const_AnglePID_D,
						    const_SpeedPID_P,
						    const_SpeedPID_I,
						    const_SpeedPID_maxIntegral,
						    const_RotationPID_D)))
				VS__(id__,
						    const_BalanceSTM_maxAngle,
						    const_BalanceSTM_loopTime,
						    const_BalanceSTM_startupDelay,
						    const_BalanceSTM_speedUpdate,
						    const_BalanceSTM_rotationUpdate,
						    const_BalanceSTM_angleBudget,
						    const_BalanceSTM_speedBudget,
						    const_BalanceSTM_rotationBudget,
						    const_BalanceSTM_motorBudget,
						    const_AnglePID_P,
						    const_AnglePID_D,
						    const_SpeedPID_P,
						    const_SpeedPID_I,
						    const_SpeedPID_maxIntegral,
						    const_RotationPID_D) = FVS__(id__,
						    const_BalanceSTM_maxAngle,
						    const_BalanceSTM_loopTime,
						    const_BalanceSTM_startupDelay,
						    const_BalanceSTM_speedUpdate,
						    const_BalanceSTM_rotationUpdate,
						    const_BalanceSTM_angleBudget,
						    const_BalanceSTM_speedBudget,
						    const_BalanceSTM_rotationBudget,
						    const_BalanceSTM_motorBudget,
						    const_AnglePID_P,
						    const_AnglePID_D,
						    const_SpeedPID_P,
						    const_SpeedPID_I,
						    const_SpeedPID_maxIntegral,
						    const_RotationPID_D)
				VS_O__(id__,
						    const_BalanceSTM_maxAngle,
						    const_BalanceSTM_loopTime,
						    const_BalanceSTM_startupDelay,
						    const_BalanceSTM_speedUpdate,
						    const_BalanceSTM_rotationUpdate,
						    const_BalanceSTM_angleBudget,
						    const_BalanceSTM_speedBudget,
						    const_BalanceSTM_rotationBudget,
						    const_BalanceSTM_motorBudget,
						    const_AnglePID_P,
						    const_AnglePID_D,
						    const_SpeedPID_P,
						    const_SpeedPID_I,
						    const_SpeedPID_maxIntegral,
						    const_RotationPID_D) = sbisim(diamond(FVS__(id__,
						    const_BalanceSTM_maxAngle,
						    const_BalanceSTM_loopTime,
						    const_BalanceSTM_startupDelay,
						    const_BalanceSTM_speedUpdate,
						    const_BalanceSTM_rotationUpdate,
						    const_BalanceSTM_angleBudget,
						    const_BalanceSTM_speedBudget,
						    const_BalanceSTM_rotationBudget,
						    const_BalanceSTM_motorBudget,
						    const_AnglePID_P,
						    const_AnglePID_D,
						    const_SpeedPID_P,
						    const_SpeedPID_I,
						    const_SpeedPID_maxIntegral,
						    const_RotationPID_D)))
				HEXT__(id__,
						    const_BalanceSTM_maxAngle,
						    const_BalanceSTM_loopTime,
						    const_BalanceSTM_startupDelay,
						    const_BalanceSTM_speedUpdate,
						    const_BalanceSTM_rotationUpdate,
						    const_BalanceSTM_angleBudget,
						    const_BalanceSTM_speedBudget,
						    const_BalanceSTM_rotationBudget,
						    const_BalanceSTM_motorBudget,
						    const_AnglePID_P,
						    const_AnglePID_D,
						    const_SpeedPID_P,
						    const_SpeedPID_I,
						    const_SpeedPID_maxIntegral,
						    const_RotationPID_D) = O__(id__,
						    const_BalanceSTM_maxAngle,
						    const_BalanceSTM_loopTime,
						    const_BalanceSTM_startupDelay,
						    const_BalanceSTM_speedUpdate,
						    const_BalanceSTM_rotationUpdate,
						    const_BalanceSTM_angleBudget,
						    const_BalanceSTM_speedBudget,
						    const_BalanceSTM_rotationBudget,
						    const_BalanceSTM_motorBudget,
						    const_AnglePID_P,
						    const_AnglePID_D,
						    const_SpeedPID_P,
						    const_SpeedPID_I,
						    const_SpeedPID_maxIntegral,
						    const_RotationPID_D) [|shared_variable_events|] SKIP
				HUP__(id__,
						    const_BalanceSTM_maxAngle,
						    const_BalanceSTM_loopTime,
						    const_BalanceSTM_startupDelay,
						    const_BalanceSTM_speedUpdate,
						    const_BalanceSTM_rotationUpdate,
						    const_BalanceSTM_angleBudget,
						    const_BalanceSTM_speedBudget,
						    const_BalanceSTM_rotationBudget,
						    const_BalanceSTM_motorBudget,
						    const_AnglePID_P,
						    const_AnglePID_D,
						    const_SpeedPID_P,
						    const_SpeedPID_I,
						    const_SpeedPID_maxIntegral,
						    const_RotationPID_D) = O__(id__,
						    const_BalanceSTM_maxAngle,
						    const_BalanceSTM_loopTime,
						    const_BalanceSTM_startupDelay,
						    const_BalanceSTM_speedUpdate,
						    const_BalanceSTM_rotationUpdate,
						    const_BalanceSTM_angleBudget,
						    const_BalanceSTM_speedBudget,
						    const_BalanceSTM_rotationBudget,
						    const_BalanceSTM_motorBudget,
						    const_AnglePID_P,
						    const_AnglePID_D,
						    const_SpeedPID_P,
						    const_SpeedPID_I,
						    const_SpeedPID_maxIntegral,
						    const_RotationPID_D) [|{share__}|] SKIP
				
				-- Shared memory
				-- Shared memory variables
				
				-- sharedVarMemory process
				sharedVarMemory(id__,
						    const_BalanceSTM_maxAngle,
						    const_BalanceSTM_loopTime,
						    const_BalanceSTM_startupDelay,
						    const_BalanceSTM_speedUpdate,
						    const_BalanceSTM_rotationUpdate,
						    const_BalanceSTM_angleBudget,
						    const_BalanceSTM_speedBudget,
						    const_BalanceSTM_rotationBudget,
						    const_BalanceSTM_motorBudget,
						    const_AnglePID_P,
						    const_AnglePID_D,
						    const_SpeedPID_P,
						    const_SpeedPID_I,
						    const_SpeedPID_maxIntegral,
						    const_RotationPID_D) = terminate -> SKIP
				
				sharedVarSync = {||}
				
				sharedVarHide = {||}
			endmodule
			
				-- undefined operations
				CALL__setLeftMotorSpeed(id__,
						    param_speed) 	= setLeftMotorSpeedCall.param_speed -> SKIP
				CALL__enableInterrupts(id__) 	= enableInterruptsCall -> SKIP
				CALL__setRightMotorSpeed(id__,
						    param_speed) 	= setRightMotorSpeedCall.param_speed -> SKIP
				CALL__disableInterrupts(id__) 	= disableInterruptsCall -> SKIP
				
				-- declaring controller memory
				Memory(id__) = SKIP
				
				D__(id__,
						    const_Segway_SegwayController_stm_ref0_maxAngle,
						    const_Segway_SegwayController_stm_ref0_loopTime,
						    const_Segway_SegwayController_stm_ref0_startupDelay,
						    const_Segway_SegwayController_stm_ref0_speedUpdate,
						    const_Segway_SegwayController_stm_ref0_rotationUpdate,
						    const_Segway_SegwayController_stm_ref0_angleBudget,
						    const_Segway_SegwayController_stm_ref0_speedBudget,
						    const_Segway_SegwayController_stm_ref0_rotationBudget,
						    const_Segway_SegwayController_stm_ref0_motorBudget,
						   	const_Segway_SegwayController_op_ref0_P,
						   	const_Segway_SegwayController_op_ref0_D,
						   	const_Segway_SegwayController_op_ref1_P,
						   	const_Segway_SegwayController_op_ref1_I,
						   	const_Segway_SegwayController_op_ref1_maxIntegral,
						   	const_Segway_SegwayController_op_ref2_D) = 	((
						let
							const_BalanceSTM_maxAngle = const_Segway_SegwayController_stm_ref0_maxAngle
							const_BalanceSTM_loopTime = const_Segway_SegwayController_stm_ref0_loopTime
							const_BalanceSTM_startupDelay = const_Segway_SegwayController_stm_ref0_startupDelay
							const_BalanceSTM_speedUpdate = const_Segway_SegwayController_stm_ref0_speedUpdate
							const_BalanceSTM_rotationUpdate = const_Segway_SegwayController_stm_ref0_rotationUpdate
							const_BalanceSTM_angleBudget = const_Segway_SegwayController_stm_ref0_angleBudget
							const_BalanceSTM_speedBudget = const_Segway_SegwayController_stm_ref0_speedBudget
							const_BalanceSTM_rotationBudget = const_Segway_SegwayController_stm_ref0_rotationBudget
							const_BalanceSTM_motorBudget = const_Segway_SegwayController_stm_ref0_motorBudget
							const_AnglePID_P = const_Segway_SegwayController_op_ref0_P
							const_AnglePID_D = const_Segway_SegwayController_op_ref0_D
							const_SpeedPID_P = const_Segway_SegwayController_op_ref1_P
							const_SpeedPID_I = const_Segway_SegwayController_op_ref1_I
							const_SpeedPID_maxIntegral = const_Segway_SegwayController_op_ref1_maxIntegral
							const_RotationPID_D = const_Segway_SegwayController_op_ref2_D
						within 
						stm_ref0::D__(id__,
								    const_BalanceSTM_maxAngle,
								    const_BalanceSTM_loopTime,
								    const_BalanceSTM_startupDelay,
								    const_BalanceSTM_speedUpdate,
								    const_BalanceSTM_rotationUpdate,
								    const_BalanceSTM_angleBudget,
								    const_BalanceSTM_speedBudget,
								    const_BalanceSTM_rotationBudget,
								    const_BalanceSTM_motorBudget,
								    const_AnglePID_P,
								    const_AnglePID_D,
								    const_SpeedPID_P,
								    const_SpeedPID_I,
								    const_SpeedPID_maxIntegral,
								    const_RotationPID_D)[[
							stm_ref0::terminate <- terminate,
							stm_ref0::leftMotorVelocity <- leftMotorVelocity,
							stm_ref0::rightMotorVelocity <- rightMotorVelocity,
							stm_ref0::angle <- angle,
							stm_ref0::gyroX <- gyroX,
							stm_ref0::gyroY <- gyroY,
							stm_ref0::gyroZ <- gyroZ,
							stm_ref0::setLeftMotorSpeedCall <- setLeftMotorSpeedCall,
							stm_ref0::enableInterruptsCall <- enableInterruptsCall,
							stm_ref0::setRightMotorSpeedCall <- setRightMotorSpeedCall,
							stm_ref0::disableInterruptsCall <- disableInterruptsCall
						]]
					)
						[|
							union(
								{|
								|},
								{|
								|}
							)
						|]
					Memory(id__)
				)
				\ union(
					{|
					|},
					{|
					|}
				)
				[|{|terminate|}|>SKIP
				
				-- VS version
				VS__(id__,
						    const_Segway_SegwayController_stm_ref0_maxAngle,
						    const_Segway_SegwayController_stm_ref0_loopTime,
						    const_Segway_SegwayController_stm_ref0_startupDelay,
						    const_Segway_SegwayController_stm_ref0_speedUpdate,
						    const_Segway_SegwayController_stm_ref0_rotationUpdate,
						    const_Segway_SegwayController_stm_ref0_angleBudget,
						    const_Segway_SegwayController_stm_ref0_speedBudget,
						    const_Segway_SegwayController_stm_ref0_rotationBudget,
						    const_Segway_SegwayController_stm_ref0_motorBudget,
						   	const_Segway_SegwayController_op_ref0_P,
						   	const_Segway_SegwayController_op_ref0_D,
						   	const_Segway_SegwayController_op_ref1_P,
						   	const_Segway_SegwayController_op_ref1_I,
						   	const_Segway_SegwayController_op_ref1_maxIntegral,
						   	const_Segway_SegwayController_op_ref2_D) = 	((
						let
							const_BalanceSTM_maxAngle = const_Segway_SegwayController_stm_ref0_maxAngle
							const_BalanceSTM_loopTime = const_Segway_SegwayController_stm_ref0_loopTime
							const_BalanceSTM_startupDelay = const_Segway_SegwayController_stm_ref0_startupDelay
							const_BalanceSTM_speedUpdate = const_Segway_SegwayController_stm_ref0_speedUpdate
							const_BalanceSTM_rotationUpdate = const_Segway_SegwayController_stm_ref0_rotationUpdate
							const_BalanceSTM_angleBudget = const_Segway_SegwayController_stm_ref0_angleBudget
							const_BalanceSTM_speedBudget = const_Segway_SegwayController_stm_ref0_speedBudget
							const_BalanceSTM_rotationBudget = const_Segway_SegwayController_stm_ref0_rotationBudget
							const_BalanceSTM_motorBudget = const_Segway_SegwayController_stm_ref0_motorBudget
							const_AnglePID_P = const_Segway_SegwayController_op_ref0_P
							const_AnglePID_D = const_Segway_SegwayController_op_ref0_D
							const_SpeedPID_P = const_Segway_SegwayController_op_ref1_P
							const_SpeedPID_I = const_Segway_SegwayController_op_ref1_I
							const_SpeedPID_maxIntegral = const_Segway_SegwayController_op_ref1_maxIntegral
							const_RotationPID_D = const_Segway_SegwayController_op_ref2_D
						within 
						stm_ref0::VS__(id__,
								    const_BalanceSTM_maxAngle,
								    const_BalanceSTM_loopTime,
								    const_BalanceSTM_startupDelay,
								    const_BalanceSTM_speedUpdate,
								    const_BalanceSTM_rotationUpdate,
								    const_BalanceSTM_angleBudget,
								    const_BalanceSTM_speedBudget,
								    const_BalanceSTM_rotationBudget,
								    const_BalanceSTM_motorBudget,
								    const_AnglePID_P,
								    const_AnglePID_D,
								    const_SpeedPID_P,
								    const_SpeedPID_I,
								    const_SpeedPID_maxIntegral,
								    const_RotationPID_D)[[
							stm_ref0::terminate <- terminate,
							stm_ref0::leftMotorVelocity <- leftMotorVelocity,
							stm_ref0::rightMotorVelocity <- rightMotorVelocity,
							stm_ref0::angle <- angle,
							stm_ref0::gyroX <- gyroX,
							stm_ref0::gyroY <- gyroY,
							stm_ref0::gyroZ <- gyroZ,
							stm_ref0::setLeftMotorSpeedCall <- setLeftMotorSpeedCall,
							stm_ref0::enableInterruptsCall <- enableInterruptsCall,
							stm_ref0::setRightMotorSpeedCall <- setRightMotorSpeedCall,
							stm_ref0::disableInterruptsCall <- disableInterruptsCall
						]]
					)
						[|
							union(
								{|
								|},
								{|
								|}
							)
						|]
					Memory(id__)
				)
				\ union(
					{|
					|},
					{|
					|}
				)
				[|{|terminate|}|>SKIP
			
				-- O version (optimised) THESE TWO PROCESSES SHOULD BE KEPT IN SYNC WITH THE ABOVE TWO
				O__(id__,
						    const_Segway_SegwayController_stm_ref0_maxAngle,
						    const_Segway_SegwayController_stm_ref0_loopTime,
						    const_Segway_SegwayController_stm_ref0_startupDelay,
						    const_Segway_SegwayController_stm_ref0_speedUpdate,
						    const_Segway_SegwayController_stm_ref0_rotationUpdate,
						    const_Segway_SegwayController_stm_ref0_angleBudget,
						    const_Segway_SegwayController_stm_ref0_speedBudget,
						    const_Segway_SegwayController_stm_ref0_rotationBudget,
						    const_Segway_SegwayController_stm_ref0_motorBudget,
						   	const_Segway_SegwayController_op_ref0_P,
						   	const_Segway_SegwayController_op_ref0_D,
						   	const_Segway_SegwayController_op_ref1_P,
						   	const_Segway_SegwayController_op_ref1_I,
						   	const_Segway_SegwayController_op_ref1_maxIntegral,
						   	const_Segway_SegwayController_op_ref2_D) = sbisim(diamond(	((
						let
							const_BalanceSTM_maxAngle = const_Segway_SegwayController_stm_ref0_maxAngle
							const_BalanceSTM_loopTime = const_Segway_SegwayController_stm_ref0_loopTime
							const_BalanceSTM_startupDelay = const_Segway_SegwayController_stm_ref0_startupDelay
							const_BalanceSTM_speedUpdate = const_Segway_SegwayController_stm_ref0_speedUpdate
							const_BalanceSTM_rotationUpdate = const_Segway_SegwayController_stm_ref0_rotationUpdate
							const_BalanceSTM_angleBudget = const_Segway_SegwayController_stm_ref0_angleBudget
							const_BalanceSTM_speedBudget = const_Segway_SegwayController_stm_ref0_speedBudget
							const_BalanceSTM_rotationBudget = const_Segway_SegwayController_stm_ref0_rotationBudget
							const_BalanceSTM_motorBudget = const_Segway_SegwayController_stm_ref0_motorBudget
							const_AnglePID_P = const_Segway_SegwayController_op_ref0_P
							const_AnglePID_D = const_Segway_SegwayController_op_ref0_D
							const_SpeedPID_P = const_Segway_SegwayController_op_ref1_P
							const_SpeedPID_I = const_Segway_SegwayController_op_ref1_I
							const_SpeedPID_maxIntegral = const_Segway_SegwayController_op_ref1_maxIntegral
							const_RotationPID_D = const_Segway_SegwayController_op_ref2_D
						within 
						stm_ref0::O__(id__,
								    const_BalanceSTM_maxAngle,
								    const_BalanceSTM_loopTime,
								    const_BalanceSTM_startupDelay,
								    const_BalanceSTM_speedUpdate,
								    const_BalanceSTM_rotationUpdate,
								    const_BalanceSTM_angleBudget,
								    const_BalanceSTM_speedBudget,
								    const_BalanceSTM_rotationBudget,
								    const_BalanceSTM_motorBudget,
								    const_AnglePID_P,
								    const_AnglePID_D,
								    const_SpeedPID_P,
								    const_SpeedPID_I,
								    const_SpeedPID_maxIntegral,
								    const_RotationPID_D)[[
							stm_ref0::terminate <- terminate,
							stm_ref0::leftMotorVelocity <- leftMotorVelocity,
							stm_ref0::rightMotorVelocity <- rightMotorVelocity,
							stm_ref0::angle <- angle,
							stm_ref0::gyroX <- gyroX,
							stm_ref0::gyroY <- gyroY,
							stm_ref0::gyroZ <- gyroZ,
							stm_ref0::setLeftMotorSpeedCall <- setLeftMotorSpeedCall,
							stm_ref0::enableInterruptsCall <- enableInterruptsCall,
							stm_ref0::setRightMotorSpeedCall <- setRightMotorSpeedCall,
							stm_ref0::disableInterruptsCall <- disableInterruptsCall
						]]
					)
						[|
							union(
								{|
								|},
								{|
								|}
							)
						|]
					dbisim(Memory(id__))
				)
				\ union(
					{|
					|},
					{|
					|}
				)
				[|{|terminate|}|>SKIP
				))
								
				-- VS_O version
				VS_O__(id__,
						    const_Segway_SegwayController_stm_ref0_maxAngle,
						    const_Segway_SegwayController_stm_ref0_loopTime,
						    const_Segway_SegwayController_stm_ref0_startupDelay,
						    const_Segway_SegwayController_stm_ref0_speedUpdate,
						    const_Segway_SegwayController_stm_ref0_rotationUpdate,
						    const_Segway_SegwayController_stm_ref0_angleBudget,
						    const_Segway_SegwayController_stm_ref0_speedBudget,
						    const_Segway_SegwayController_stm_ref0_rotationBudget,
						    const_Segway_SegwayController_stm_ref0_motorBudget,
						   	const_Segway_SegwayController_op_ref0_P,
						   	const_Segway_SegwayController_op_ref0_D,
						   	const_Segway_SegwayController_op_ref1_P,
						   	const_Segway_SegwayController_op_ref1_I,
						   	const_Segway_SegwayController_op_ref1_maxIntegral,
						   	const_Segway_SegwayController_op_ref2_D) = sbisim(diamond(	((
						let
							const_BalanceSTM_maxAngle = const_Segway_SegwayController_stm_ref0_maxAngle
							const_BalanceSTM_loopTime = const_Segway_SegwayController_stm_ref0_loopTime
							const_BalanceSTM_startupDelay = const_Segway_SegwayController_stm_ref0_startupDelay
							const_BalanceSTM_speedUpdate = const_Segway_SegwayController_stm_ref0_speedUpdate
							const_BalanceSTM_rotationUpdate = const_Segway_SegwayController_stm_ref0_rotationUpdate
							const_BalanceSTM_angleBudget = const_Segway_SegwayController_stm_ref0_angleBudget
							const_BalanceSTM_speedBudget = const_Segway_SegwayController_stm_ref0_speedBudget
							const_BalanceSTM_rotationBudget = const_Segway_SegwayController_stm_ref0_rotationBudget
							const_BalanceSTM_motorBudget = const_Segway_SegwayController_stm_ref0_motorBudget
							const_AnglePID_P = const_Segway_SegwayController_op_ref0_P
							const_AnglePID_D = const_Segway_SegwayController_op_ref0_D
							const_SpeedPID_P = const_Segway_SegwayController_op_ref1_P
							const_SpeedPID_I = const_Segway_SegwayController_op_ref1_I
							const_SpeedPID_maxIntegral = const_Segway_SegwayController_op_ref1_maxIntegral
							const_RotationPID_D = const_Segway_SegwayController_op_ref2_D
						within 
						stm_ref0::VS_O__(id__,
								    const_BalanceSTM_maxAngle,
								    const_BalanceSTM_loopTime,
								    const_BalanceSTM_startupDelay,
								    const_BalanceSTM_speedUpdate,
								    const_BalanceSTM_rotationUpdate,
								    const_BalanceSTM_angleBudget,
								    const_BalanceSTM_speedBudget,
								    const_BalanceSTM_rotationBudget,
								    const_BalanceSTM_motorBudget,
								    const_AnglePID_P,
								    const_AnglePID_D,
								    const_SpeedPID_P,
								    const_SpeedPID_I,
								    const_SpeedPID_maxIntegral,
								    const_RotationPID_D)[[
							stm_ref0::terminate <- terminate,
							stm_ref0::leftMotorVelocity <- leftMotorVelocity,
							stm_ref0::rightMotorVelocity <- rightMotorVelocity,
							stm_ref0::angle <- angle,
							stm_ref0::gyroX <- gyroX,
							stm_ref0::gyroY <- gyroY,
							stm_ref0::gyroZ <- gyroZ,
							stm_ref0::setLeftMotorSpeedCall <- setLeftMotorSpeedCall,
							stm_ref0::enableInterruptsCall <- enableInterruptsCall,
							stm_ref0::setRightMotorSpeedCall <- setRightMotorSpeedCall,
							stm_ref0::disableInterruptsCall <- disableInterruptsCall
						]]
					)
						[|
							union(
								{|
								|},
								{|
								|}
							)
						|]
					dbisim(Memory(id__))
				)
				\ union(
					{|
					|},
					{|
					|}
				)
				[|{|terminate|}|>SKIP
				))
			
				HEXT(id__,
						    const_Segway_SegwayController_stm_ref0_maxAngle,
						    const_Segway_SegwayController_stm_ref0_loopTime,
						    const_Segway_SegwayController_stm_ref0_startupDelay,
						    const_Segway_SegwayController_stm_ref0_speedUpdate,
						    const_Segway_SegwayController_stm_ref0_rotationUpdate,
						    const_Segway_SegwayController_stm_ref0_angleBudget,
						    const_Segway_SegwayController_stm_ref0_speedBudget,
						    const_Segway_SegwayController_stm_ref0_rotationBudget,
						    const_Segway_SegwayController_stm_ref0_motorBudget,
						   	const_Segway_SegwayController_op_ref0_P,
						   	const_Segway_SegwayController_op_ref0_D,
						   	const_Segway_SegwayController_op_ref1_P,
						   	const_Segway_SegwayController_op_ref1_I,
						   	const_Segway_SegwayController_op_ref1_maxIntegral,
						   	const_Segway_SegwayController_op_ref2_D) = O__(id__,
						    const_Segway_SegwayController_stm_ref0_maxAngle,
						    const_Segway_SegwayController_stm_ref0_loopTime,
						    const_Segway_SegwayController_stm_ref0_startupDelay,
						    const_Segway_SegwayController_stm_ref0_speedUpdate,
						    const_Segway_SegwayController_stm_ref0_rotationUpdate,
						    const_Segway_SegwayController_stm_ref0_angleBudget,
						    const_Segway_SegwayController_stm_ref0_speedBudget,
						    const_Segway_SegwayController_stm_ref0_rotationBudget,
						    const_Segway_SegwayController_stm_ref0_motorBudget,
						   	const_Segway_SegwayController_op_ref0_P,
						   	const_Segway_SegwayController_op_ref0_D,
						   	const_Segway_SegwayController_op_ref1_P,
						   	const_Segway_SegwayController_op_ref1_I,
						   	const_Segway_SegwayController_op_ref1_maxIntegral,
						   	const_Segway_SegwayController_op_ref2_D) [|shared_variable_events|] SKIP			
	
		endmodule
	
	-- declaring module memory
	Memory(id__) = SKIP
	
	D__(id__,
			    const_Segway_SegwayController_stm_ref0_maxAngle,
			    const_Segway_SegwayController_stm_ref0_loopTime,
			    const_Segway_SegwayController_stm_ref0_startupDelay,
			    const_Segway_SegwayController_stm_ref0_speedUpdate,
			    const_Segway_SegwayController_stm_ref0_rotationUpdate,
			    const_Segway_SegwayController_stm_ref0_angleBudget,
			    const_Segway_SegwayController_stm_ref0_speedBudget,
			    const_Segway_SegwayController_stm_ref0_rotationBudget,
			    const_Segway_SegwayController_stm_ref0_motorBudget,
			   	const_Segway_SegwayController_op_ref0_P,
			   	const_Segway_SegwayController_op_ref0_D,
			   	const_Segway_SegwayController_op_ref1_P,
			   	const_Segway_SegwayController_op_ref1_I,
			   	const_Segway_SegwayController_op_ref1_maxIntegral,
			   	const_Segway_SegwayController_op_ref2_D) = 	(
			(
				(SKIP)
					[|{||}|]
				(
					(
						SegwayController::D__(id__,
								    const_Segway_SegwayController_stm_ref0_maxAngle,
								    const_Segway_SegwayController_stm_ref0_loopTime,
								    const_Segway_SegwayController_stm_ref0_startupDelay,
								    const_Segway_SegwayController_stm_ref0_speedUpdate,
								    const_Segway_SegwayController_stm_ref0_rotationUpdate,
								    const_Segway_SegwayController_stm_ref0_angleBudget,
								    const_Segway_SegwayController_stm_ref0_speedBudget,
								    const_Segway_SegwayController_stm_ref0_rotationBudget,
								    const_Segway_SegwayController_stm_ref0_motorBudget,
								   	const_Segway_SegwayController_op_ref0_P,
								   	const_Segway_SegwayController_op_ref0_D,
								   	const_Segway_SegwayController_op_ref1_P,
								   	const_Segway_SegwayController_op_ref1_I,
								   	const_Segway_SegwayController_op_ref1_maxIntegral,
								   	const_Segway_SegwayController_op_ref2_D)[[
							SegwayController::terminate <- terminate,
							SegwayController::angle <- angle,
							SegwayController::gyroX <- gyroX,
							SegwayController::gyroY <- gyroY,
							SegwayController::gyroZ <- gyroZ,
							SegwayController::leftMotorVelocity <- leftMotorVelocity,
							SegwayController::rightMotorVelocity <- rightMotorVelocity,
							SegwayController::setLeftMotorSpeedCall <- setLeftMotorSpeedCall,
							SegwayController::enableInterruptsCall <- enableInterruptsCall,
							SegwayController::setRightMotorSpeedCall <- setRightMotorSpeedCall,
							SegwayController::disableInterruptsCall <- disableInterruptsCall
						]]
					)
						[|
							union(
								{|
								|},
								{|
								|}
							)
						|]
					Memory(id__)
				)
			)
			\ Union({
				{|
				|},
				{|
				|},
				{|
				|}
			})
			[|{|terminate|}|>SKIP
		)
		\{|terminate|}
	
	-- visible state equivalent
	
	VS__(id__,
			    const_Segway_SegwayController_stm_ref0_maxAngle,
			    const_Segway_SegwayController_stm_ref0_loopTime,
			    const_Segway_SegwayController_stm_ref0_startupDelay,
			    const_Segway_SegwayController_stm_ref0_speedUpdate,
			    const_Segway_SegwayController_stm_ref0_rotationUpdate,
			    const_Segway_SegwayController_stm_ref0_angleBudget,
			    const_Segway_SegwayController_stm_ref0_speedBudget,
			    const_Segway_SegwayController_stm_ref0_rotationBudget,
			    const_Segway_SegwayController_stm_ref0_motorBudget,
			   	const_Segway_SegwayController_op_ref0_P,
			   	const_Segway_SegwayController_op_ref0_D,
			   	const_Segway_SegwayController_op_ref1_P,
			   	const_Segway_SegwayController_op_ref1_I,
			   	const_Segway_SegwayController_op_ref1_maxIntegral,
			   	const_Segway_SegwayController_op_ref2_D) = 	(
			(
				(SKIP)
					[|{||}|]
				(
					(
						SegwayController::VS__(id__,
								    const_Segway_SegwayController_stm_ref0_maxAngle,
								    const_Segway_SegwayController_stm_ref0_loopTime,
								    const_Segway_SegwayController_stm_ref0_startupDelay,
								    const_Segway_SegwayController_stm_ref0_speedUpdate,
								    const_Segway_SegwayController_stm_ref0_rotationUpdate,
								    const_Segway_SegwayController_stm_ref0_angleBudget,
								    const_Segway_SegwayController_stm_ref0_speedBudget,
								    const_Segway_SegwayController_stm_ref0_rotationBudget,
								    const_Segway_SegwayController_stm_ref0_motorBudget,
								   	const_Segway_SegwayController_op_ref0_P,
								   	const_Segway_SegwayController_op_ref0_D,
								   	const_Segway_SegwayController_op_ref1_P,
								   	const_Segway_SegwayController_op_ref1_I,
								   	const_Segway_SegwayController_op_ref1_maxIntegral,
								   	const_Segway_SegwayController_op_ref2_D)[[
							SegwayController::terminate <- terminate,
							SegwayController::angle <- angle,
							SegwayController::gyroX <- gyroX,
							SegwayController::gyroY <- gyroY,
							SegwayController::gyroZ <- gyroZ,
							SegwayController::leftMotorVelocity <- leftMotorVelocity,
							SegwayController::rightMotorVelocity <- rightMotorVelocity,
							SegwayController::setLeftMotorSpeedCall <- setLeftMotorSpeedCall,
							SegwayController::enableInterruptsCall <- enableInterruptsCall,
							SegwayController::setRightMotorSpeedCall <- setRightMotorSpeedCall,
							SegwayController::disableInterruptsCall <- disableInterruptsCall
						]]
					)
						[|
							union(
								{|
								|},
								{|
								|}
							)
						|]
					Memory(id__)
				)
			)
			\ Union({
				{|
				|},
				{|
				|},
				{|
				|}
			})
			[|{|terminate|}|>SKIP
		)
		\{|terminate|}
	
	-- O version (optimised)
	
	O__(id__,
			    const_Segway_SegwayController_stm_ref0_maxAngle,
			    const_Segway_SegwayController_stm_ref0_loopTime,
			    const_Segway_SegwayController_stm_ref0_startupDelay,
			    const_Segway_SegwayController_stm_ref0_speedUpdate,
			    const_Segway_SegwayController_stm_ref0_rotationUpdate,
			    const_Segway_SegwayController_stm_ref0_angleBudget,
			    const_Segway_SegwayController_stm_ref0_speedBudget,
			    const_Segway_SegwayController_stm_ref0_rotationBudget,
			    const_Segway_SegwayController_stm_ref0_motorBudget,
			   	const_Segway_SegwayController_op_ref0_P,
			   	const_Segway_SegwayController_op_ref0_D,
			   	const_Segway_SegwayController_op_ref1_P,
			   	const_Segway_SegwayController_op_ref1_I,
			   	const_Segway_SegwayController_op_ref1_maxIntegral,
			   	const_Segway_SegwayController_op_ref2_D) = sbisim(diamond(	(
			(
				(SKIP)
					[|{||}|]
				(
					(
						SegwayController::O__(id__,
								    const_Segway_SegwayController_stm_ref0_maxAngle,
								    const_Segway_SegwayController_stm_ref0_loopTime,
								    const_Segway_SegwayController_stm_ref0_startupDelay,
								    const_Segway_SegwayController_stm_ref0_speedUpdate,
								    const_Segway_SegwayController_stm_ref0_rotationUpdate,
								    const_Segway_SegwayController_stm_ref0_angleBudget,
								    const_Segway_SegwayController_stm_ref0_speedBudget,
								    const_Segway_SegwayController_stm_ref0_rotationBudget,
								    const_Segway_SegwayController_stm_ref0_motorBudget,
								   	const_Segway_SegwayController_op_ref0_P,
								   	const_Segway_SegwayController_op_ref0_D,
								   	const_Segway_SegwayController_op_ref1_P,
								   	const_Segway_SegwayController_op_ref1_I,
								   	const_Segway_SegwayController_op_ref1_maxIntegral,
								   	const_Segway_SegwayController_op_ref2_D)[[
							SegwayController::terminate <- terminate,
							SegwayController::angle <- angle,
							SegwayController::gyroX <- gyroX,
							SegwayController::gyroY <- gyroY,
							SegwayController::gyroZ <- gyroZ,
							SegwayController::leftMotorVelocity <- leftMotorVelocity,
							SegwayController::rightMotorVelocity <- rightMotorVelocity,
							SegwayController::setLeftMotorSpeedCall <- setLeftMotorSpeedCall,
							SegwayController::enableInterruptsCall <- enableInterruptsCall,
							SegwayController::setRightMotorSpeedCall <- setRightMotorSpeedCall,
							SegwayController::disableInterruptsCall <- disableInterruptsCall
						]]
					)
						[|
							union(
								{|
								|},
								{|
								|}
							)
						|]
					dbisim(Memory(id__))
				)
			)
			\ Union({
				{|
				|},
				{|
				|},
				{|
				|}
			})
			[|{|terminate|}|>SKIP
		)
		\{|terminate|}
	))
	
	-- visible state optimised equivalent
	
	VS_O__(id__,
			    const_Segway_SegwayController_stm_ref0_maxAngle,
			    const_Segway_SegwayController_stm_ref0_loopTime,
			    const_Segway_SegwayController_stm_ref0_startupDelay,
			    const_Segway_SegwayController_stm_ref0_speedUpdate,
			    const_Segway_SegwayController_stm_ref0_rotationUpdate,
			    const_Segway_SegwayController_stm_ref0_angleBudget,
			    const_Segway_SegwayController_stm_ref0_speedBudget,
			    const_Segway_SegwayController_stm_ref0_rotationBudget,
			    const_Segway_SegwayController_stm_ref0_motorBudget,
			   	const_Segway_SegwayController_op_ref0_P,
			   	const_Segway_SegwayController_op_ref0_D,
			   	const_Segway_SegwayController_op_ref1_P,
			   	const_Segway_SegwayController_op_ref1_I,
			   	const_Segway_SegwayController_op_ref1_maxIntegral,
			   	const_Segway_SegwayController_op_ref2_D) = sbisim(diamond(	(
			(
				(SKIP)
					[|{||}|]
				(
					(
						SegwayController::VS_O__(id__,
								    const_Segway_SegwayController_stm_ref0_maxAngle,
								    const_Segway_SegwayController_stm_ref0_loopTime,
								    const_Segway_SegwayController_stm_ref0_startupDelay,
								    const_Segway_SegwayController_stm_ref0_speedUpdate,
								    const_Segway_SegwayController_stm_ref0_rotationUpdate,
								    const_Segway_SegwayController_stm_ref0_angleBudget,
								    const_Segway_SegwayController_stm_ref0_speedBudget,
								    const_Segway_SegwayController_stm_ref0_rotationBudget,
								    const_Segway_SegwayController_stm_ref0_motorBudget,
								   	const_Segway_SegwayController_op_ref0_P,
								   	const_Segway_SegwayController_op_ref0_D,
								   	const_Segway_SegwayController_op_ref1_P,
								   	const_Segway_SegwayController_op_ref1_I,
								   	const_Segway_SegwayController_op_ref1_maxIntegral,
								   	const_Segway_SegwayController_op_ref2_D)[[
							SegwayController::terminate <- terminate,
							SegwayController::angle <- angle,
							SegwayController::gyroX <- gyroX,
							SegwayController::gyroY <- gyroY,
							SegwayController::gyroZ <- gyroZ,
							SegwayController::leftMotorVelocity <- leftMotorVelocity,
							SegwayController::rightMotorVelocity <- rightMotorVelocity,
							SegwayController::setLeftMotorSpeedCall <- setLeftMotorSpeedCall,
							SegwayController::enableInterruptsCall <- enableInterruptsCall,
							SegwayController::setRightMotorSpeedCall <- setRightMotorSpeedCall,
							SegwayController::disableInterruptsCall <- disableInterruptsCall
						]]
					)
						[|
							union(
								{|
								|},
								{|
								|}
							)
						|]
					dbisim(Memory(id__))
				)
			)
			\ Union({
				{|
				|},
				{|
				|},
				{|
				|}
			})
			[|{|terminate|}|>SKIP
		)
		\{|terminate|}
	))
	
	-- O version (optimised) with visible assignments
	
	AS_O__(id__,
			    const_Segway_SegwayController_stm_ref0_maxAngle,
			    const_Segway_SegwayController_stm_ref0_loopTime,
			    const_Segway_SegwayController_stm_ref0_startupDelay,
			    const_Segway_SegwayController_stm_ref0_speedUpdate,
			    const_Segway_SegwayController_stm_ref0_rotationUpdate,
			    const_Segway_SegwayController_stm_ref0_angleBudget,
			    const_Segway_SegwayController_stm_ref0_speedBudget,
			    const_Segway_SegwayController_stm_ref0_rotationBudget,
			    const_Segway_SegwayController_stm_ref0_motorBudget,
			   	const_Segway_SegwayController_op_ref0_P,
			   	const_Segway_SegwayController_op_ref0_D,
			   	const_Segway_SegwayController_op_ref1_P,
			   	const_Segway_SegwayController_op_ref1_I,
			   	const_Segway_SegwayController_op_ref1_maxIntegral,
			   	const_Segway_SegwayController_op_ref2_D) = sbisim(diamond(	(
			(
				(SKIP)
					[|{||}|]
				(
					(
						SegwayController::O__(id__,
								    const_Segway_SegwayController_stm_ref0_maxAngle,
								    const_Segway_SegwayController_stm_ref0_loopTime,
								    const_Segway_SegwayController_stm_ref0_startupDelay,
								    const_Segway_SegwayController_stm_ref0_speedUpdate,
								    const_Segway_SegwayController_stm_ref0_rotationUpdate,
								    const_Segway_SegwayController_stm_ref0_angleBudget,
								    const_Segway_SegwayController_stm_ref0_speedBudget,
								    const_Segway_SegwayController_stm_ref0_rotationBudget,
								    const_Segway_SegwayController_stm_ref0_motorBudget,
								   	const_Segway_SegwayController_op_ref0_P,
								   	const_Segway_SegwayController_op_ref0_D,
								   	const_Segway_SegwayController_op_ref1_P,
								   	const_Segway_SegwayController_op_ref1_I,
								   	const_Segway_SegwayController_op_ref1_maxIntegral,
								   	const_Segway_SegwayController_op_ref2_D)[[
							SegwayController::terminate <- terminate,
							SegwayController::angle <- angle,
							SegwayController::gyroX <- gyroX,
							SegwayController::gyroY <- gyroY,
							SegwayController::gyroZ <- gyroZ,
							SegwayController::leftMotorVelocity <- leftMotorVelocity,
							SegwayController::rightMotorVelocity <- rightMotorVelocity,
							SegwayController::setLeftMotorSpeedCall <- setLeftMotorSpeedCall,
							SegwayController::enableInterruptsCall <- enableInterruptsCall,
							SegwayController::setRightMotorSpeedCall <- setRightMotorSpeedCall,
							SegwayController::disableInterruptsCall <- disableInterruptsCall
						]]
					)
						[|
							union(
								{|
								|},
								{|
								|}
							)
						|]
					dbisim(Memory(id__))
				)
			)
			\ Union({
				{|
				|},
				{|
				|},
				{|
				|}
			})
			[|{|terminate|}|>SKIP
		)
		\{|terminate|}
	))
	
endmodule
