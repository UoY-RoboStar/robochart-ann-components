\documentclass{article}
\usepackage{czt}

\begin{document}


\begin{zsection}
  \SECTION BNN\_TEST \parents circus\_toolkit
\end{zsection}

In this case, Value is of the type Nat. 
\begin{zed}
  Value ~~==~~ \nat
\end{zed}
layerNo, is 3, size of each layer, 3, 1, and 3. 
input size is 6. 

Channels, layerRes0-
\begin{circus}
  \circchannel layerRes01: Value \\
  \circchannel layerRes02: Value \\
  \circchannel layerRes03: Value \\
  \circchannel layerRes04: Value \\
  \circchannel layerRes05: Value \\
  \circchannel layerRes06: Value \\
  
  
  \circchannel layerRes11: Value \\
  \circchannel layerRes12: Value \\
  \circchannel layerRes13: Value \\
  
  \circchannel layerRes21: Value \\
  
  \circchannel layerRes31: Value \\
  \circchannel layerRes32: Value \\
  \circchannel layerRes33: Value \\
  
  
  \circchannel nodeOut111: Value \\
  \circchannel nodeOut112: Value \\
  \circchannel nodeOut211: Value \\
  \circchannel\ endc \\
\end{circus}

\begin{circus}
  \circchannel in1 : Value \\
  \circchannel in2 : Value \\
  \circchannel in3 : Value \\
  \circchannel in4 : Value \\
  \circchannel in5 : Value \\
  \circchannel in6 : Value \\
  \circchannel out1 : Value \\
  \circchannel out2 : Value \\
  \circchannel out3 : Value \\
\end{circus}

\begin{circus}
  \circchannelset ANNHiddenEvts == \lchanset layerRes11 \rchanset
\end{circus}

Need a different activation function, sign function, very similar, main difference is we define it 
from both types, the difference is, it only returns 0 or 1. 

\begin{axdef}
  sign : Value \fun Value %
  \where %
  \forall x : Value @ \\%
  \t1 %
  (x = 0 \implies (x,0) \in sign) \land \\% 
  (x > 0 \implies (x,1) \in sign)
\end{axdef}


\begin{circus}
  \circprocess\ BNN\_TEST \circdef \ \circbegin \\%
      Collator \circdef l, n, i : \nat; sum : Value \circspot \\
      \lcircguard l = 1 \land n = 1 \land i = 0 \rcircguard \circguard layerRes11~!(sign(sum + ( 0 ))) \then \Skip \\%
      \extchoice
      \lcircguard l = 1 \land n = 1 \land i = 1 \rcircguard \circguard nodeOut111~?x  \then Collator(l, n, (i-1), (sum+x)) \\%
      \extchoice
      \lcircguard l = 1 \land n = 1 \land i = 2 \rcircguard \circguard layerRes11~!(sign(sum + ( 0 ))) \then \Skip \\%
      \extchoice
      \lcircguard l = 1 \land n = 1 \land i = 3 \rcircguard \circguard nodeOut111~?x  \then Collator(l, n, (i-1), (sum+x)) \\%
      \extchoice
      \lcircguard l = 1 \land n = 1 \land i = 4 \rcircguard \circguard layerRes11~!(sign(sum + ( 0 ))) \then \Skip \\%
      \extchoice
      \lcircguard l = 1 \land n = 1 \land i = 5 \rcircguard \circguard nodeOut111~?x  \then Collator(l, n, (i-1), (sum+x)) \\%
      \extchoice
      \lcircguard l = 1 \land n = 1 \land i = 6 \rcircguard \circguard nodeOut111~?x  \then Collator(l, n, (i-1), (sum+x)) \\%
      
      \extchoice
      
      \lcircguard l = 2 \land n = 1 \land i = 0 \rcircguard \circguard layerRes21~!(sign(sum + ( 0  ))) \then \Skip \\%
      \extchoice
      \lcircguard l = 2 \land n = 1 \land i = 1 \rcircguard \circguard nodeOut211~?x \then Collator(l, n, (i-1), (sum+x)) \\%
      
      NodeIn \circdef l, n, i : \nat \circspot \\%
      \lcircguard l = 1 \land n = 1 \land i = 1 \rcircguard \circguard layerRes01~?x \then nodeOut111~!(x * (1)) \then \Skip \\%
      \extchoice \\%
      \lcircguard l = 1 \land n = 1 \land i = 2 \rcircguard \circguard layerRes01~?x \then nodeOut112~!(x * (0 )) \then \Skip \\%
      \extchoice \\%
      \lcircguard l = 2 \land n = 1 \land i = 1 \rcircguard \circguard layerRes11~?x \then nodeOut211~!(x * (0 )) \then \Skip \\%
      
    
      Node \circdef l, n, inpSize : \nat \circspot \\%
        \lcircguard l = 1 \land n = 1 \rcircguard \circguard
        ((\Interleave i: 1 \upto inpSize \circspot NodeIn(l, n, i)) \\%
        \lpar | \lchanset nodeOut111, nodeOut112 \rchanset | \rpar \\%
        Collator(l, n, inpSize, 0) \circhide \lchanset nodeOut111, nodeOut112, nodeOut211 \rchanset \\   
        ) \\
        \extchoice \\
        \lcircguard l = 2 \land n = 1 \rcircguard \circguard
        ((\Interleave i: 1 \upto inpSize \circspot NodeIn(l, n, i)) \\%
        \lpar | \lchanset nodeOut211 \rchanset | \rpar \\%
        Collator(l, n, inpSize, 0) \circhide \lchanset nodeOut111, nodeOut112, nodeOut211 \rchanset \\   
        ) \\%
        
      HiddenLayer \circdef l, s, inpSize : \nat \circspot \\%
      (\lpar \lchanset layerRes01, layerRes02 \rchanset \rpar i : 1 \upto s \circspot Node(l, i, inpSize)) \\%
        
      HiddenLayers \circdef \\%
      HiddenLayer(1, 1, 2) \\%
      
      OutputLayer \circdef \\%
      (\lpar \lchanset layerRes11 \rchanset \rpar i : 1 \upto 1 \circspot Node(2, 1, 1)) \\%
      
      ANN \circdef \\%
      (((HiddenLayers \lpar | \lchanset layerRes11 \rchanset | \rpar OutputLayer) \circhide ANNHiddenEvts) \circseq ANN) \circinterrupt endc \then \Skip\\%
      
      ANNRenamed \circdef \\%
      (ANN) \lcircrename layerRes01, layerRes02, layerRes21 := adiff\_in, anewError\_in, angleOutputE\_out \rcircrename \\%
      
    \circspot ANNRenamed \\%
  \circend
\end{circus}    


\end{document}